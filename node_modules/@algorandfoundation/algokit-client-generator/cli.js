'use strict';

var commander = require('commander');
var load = require('./schema/load.js');
var path = require('path');
var generate = require('./client/generate.js');
var writer = require('./output/writer.js');
var colorConsole = require('./util/color-console.js');
var generatorContext = require('./client/generator-context.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);

function cli(workingDirectory, args) {
    // Pre 13 commander allowed `-pn` however the latest version doesn't. Rewrite it to `--pn` for backwards compatibility.
    const processedArgs = args.map((arg) => (arg === '-pn' ? '--pn' : arg));
    const program = new commander.Command();
    program
        .command('generate')
        .description('Generates a TypeScript client for the given application.json file')
        .requiredOption('-a --application <path>', 'Specifies the application.json file')
        .requiredOption('-o --output <path>', 'Specifies the output file path')
        .option('--pn --preserve-names', 'Preserve names from application.json spec instead of sanitizing them')
        .addOption(new commander.Option('-m --mode <mode>', "Generate client in specified mode. The 'full' mode includes all features, 'minimal' generates a smaller client without deployment features.")
        .choices(generatorContext.generateModes)
        .default('full'))
        .allowExcessArguments(true) // Maintains backwards compatibility with pre 13 commanded
        .action(async ({ application, output, preserveNames, mode, }) => {
        await generateClientCommand({
            application,
            output,
            preserveNames: Boolean(preserveNames),
            mode: (mode ?? 'full'),
            workingDirectory,
        });
        colorConsole.colorConsole.success `Operation completed successfully`;
    })
        .configureOutput({
        writeErr(str) {
            colorConsole.colorConsole.error `${str}`;
        },
    });
    try {
        program.parse(processedArgs);
    }
    catch (err) {
        if (err instanceof Error) {
            colorConsole.colorConsole.error `Unhandled error: \n\n${err.stack}`;
        }
        else {
            colorConsole.colorConsole.error `Unhandled error: \n\n${err}`;
        }
        process.exit(-1);
    }
}
async function generateClientCommand({ application, output, preserveNames, mode, workingDirectory, }) {
    const fs = await import('fs');
    const resolvedAppJsonPath = path__namespace.resolve(workingDirectory, application);
    const resolvedOutPath = path__namespace.resolve(workingDirectory, output);
    const resolvedOutDir = path__namespace.dirname(resolvedOutPath);
    colorConsole.colorConsole.info `Reading application.json file from path ${resolvedAppJsonPath}`;
    const spec = await load.loadApplicationJson(resolvedAppJsonPath);
    colorConsole.colorConsole.info `Generating TS client for ${spec.name}`;
    const parts = generate.generate(spec, { preserveNames, mode });
    if (!fs.existsSync(resolvedOutDir)) {
        colorConsole.colorConsole.warn `Output directory ${resolvedOutDir} does not exist and will be created.`;
        fs.mkdirSync(resolvedOutDir, { recursive: true });
    }
    colorConsole.colorConsole.info `Writing TS client to ${resolvedOutPath}`;
    const file = await createAwaitableWriteStream(resolvedOutPath);
    writer.writeDocumentPartsToStream(parts, file);
    await file.finish();
}
async function createAwaitableWriteStream(path) {
    const fs = await import('fs');
    const stream = fs.createWriteStream(path, {
        flags: 'w',
    });
    const finish = new Promise((resolve, reject) => {
        stream.on('error', (err) => {
            reject(err);
        });
        stream.on('finish', () => {
            resolve();
        });
    });
    return {
        write(chunk) {
            stream.write(chunk);
        },
        finish() {
            stream.end();
            return finish;
        },
    };
}

exports.cli = cli;
exports.generateClientCommand = generateClientCommand;
//# sourceMappingURL=cli.js.map
