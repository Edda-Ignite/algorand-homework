'use strict';

var writer = require('../output/writer.js');
var paramsFactory = require('./params-factory.js');
var appClient = require('./app-client.js');
var deployTypes = require('./deploy-types.js');
var utilityTypes = require('./utility-types.js');
var imports = require('./imports.js');
var generatorContext = require('./generator-context.js');
var appTypes = require('./app-types.js');
var callComposerTypes = require('./call-composer-types.js');
var appFactory = require('./app-factory.js');

function convertStructs(s, sanitizer) {
    return s.map(({ name, type }) => ({
        name: sanitizer.makeSafePropertyIdentifier(name),
        type: typeof type === 'string' ? type : convertStructs(type, sanitizer),
    }));
}
function shrinkAppSpec(app, options) {
    const strippedAppSpec = structuredClone(app);
    // Only keep the source info if it is needed for error mapping
    const shrinkSourceInfo = (sourceInfo) => {
        return sourceInfo
            .filter((entry) => entry.errorMessage)
            .map((entry) => ({
            pc: entry.pc,
            errorMessage: entry.errorMessage,
            // Keep minimal context for error mapping if available
            ...(entry.teal !== undefined && { teal: entry.teal }),
        }));
    };
    // Keep only source info entries that can be used for approval and clear program error mapping
    if (strippedAppSpec.sourceInfo?.approval?.sourceInfo && strippedAppSpec.sourceInfo.approval.sourceInfo.length > 0) {
        strippedAppSpec.sourceInfo.approval.sourceInfo = shrinkSourceInfo(strippedAppSpec.sourceInfo.approval.sourceInfo);
    }
    if (strippedAppSpec.sourceInfo?.clear?.sourceInfo && strippedAppSpec.sourceInfo.clear.sourceInfo.length > 0) {
        strippedAppSpec.sourceInfo.clear.sourceInfo = shrinkSourceInfo(strippedAppSpec.sourceInfo.clear.sourceInfo);
    }
    if (strippedAppSpec.compilerInfo) {
        delete strippedAppSpec.compilerInfo;
    }
    // These are used for deploying but not for calling deployed apps
    if (options.mode === 'minimal') {
        if (strippedAppSpec.source) {
            delete strippedAppSpec.source;
        }
        if (strippedAppSpec.byteCode) {
            delete strippedAppSpec.byteCode;
        }
        if (strippedAppSpec.templateVariables) {
            delete strippedAppSpec.templateVariables;
        }
        if (strippedAppSpec.scratchVariables) {
            delete strippedAppSpec.scratchVariables;
        }
    }
    return strippedAppSpec;
}
function* generate(app, options) {
    const resolvedOptions = {
        // Set defaults
        preserveNames: false,
        mode: 'full',
        ...options,
    };
    const reduceAppSpec = shrinkAppSpec(app, resolvedOptions);
    const ctx = generatorContext.createGeneratorContext(reduceAppSpec, resolvedOptions);
    yield `/* eslint-disable */`;
    yield `/**`;
    yield ` * This file was automatically generated by @algorandfoundation/algokit-client-generator.`;
    yield ` * DO NOT MODIFY IT BY HAND.`;
    yield ` * requires: @algorandfoundation/algokit-utils: ^7`;
    yield ` */`;
    yield* imports.imports(ctx);
    // Change the structs definition to sanitize property names according to the defined rules
    // for instance, this may (unless you passed in --preserve-names) convert properties like my_prop to myProp
    reduceAppSpec.structs = Object.fromEntries(Object.keys(reduceAppSpec.structs).map((key) => [key, convertStructs(reduceAppSpec.structs[key], ctx.sanitizer)]));
    yield* writer.inline('export const APP_SPEC: Arc56Contract = ', JSON.stringify(reduceAppSpec), ' as unknown as Arc56Contract');
    yield writer.NewLine;
    yield* utilityTypes.utilityTypes();
    yield writer.NewLine;
    yield* appTypes.appTypes(ctx);
    if (ctx.mode === 'full') {
        yield* deployTypes.deployTypes(ctx);
    }
    yield writer.NewLine;
    // Write a call factory
    yield* paramsFactory.paramsFactory(ctx);
    yield writer.NewLine;
    // Write a factory in full mode
    if (ctx.mode === 'full') {
        yield* appFactory.appFactory(ctx);
    }
    // Write a client
    yield* appClient.appClient(ctx);
    yield* callComposerTypes.callComposerType(ctx);
}

exports.generate = generate;
//# sourceMappingURL=generate.js.map
