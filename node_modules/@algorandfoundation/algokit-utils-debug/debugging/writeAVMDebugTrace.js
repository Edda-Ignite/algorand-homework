'use strict';

var algosdk = require('algosdk');
var constants = require('../constants.js');
var utils = require('../utils.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

/**
 * Removes old trace files when total size exceeds buffer limit
 */
async function cleanupOldFiles(bufferSizeMb, outputRootDir) {
    const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
    const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
    let totalSize = (await Promise.all((await fs.promises.readdir(outputRootDir)).map(async (file) => (await fs.promises.stat(path.join(outputRootDir, file))).size))).reduce((a, b) => a + b, 0);
    if (totalSize > bufferSizeMb * 1024 * 1024) {
        const files = await fs.promises.readdir(outputRootDir);
        const fileStats = await Promise.all(files.map(async (file) => {
            const stats = await fs.promises.stat(path.join(outputRootDir, file));
            return { file, mtime: stats.mtime, size: stats.size };
        }));
        // Sort by modification time (oldest first)
        fileStats.sort((a, b) => a.mtime.getTime() - b.mtime.getTime());
        // Remove oldest files until we're under the buffer size
        while (totalSize > bufferSizeMb * 1024 * 1024 && fileStats.length > 0) {
            const oldestFile = fileStats.shift();
            totalSize -= oldestFile.size;
            await fs.promises.unlink(path.join(outputRootDir, oldestFile.file));
        }
    }
}
/**
 * Generates a descriptive filename for a debug trace based on transaction types
 */
function generateDebugTraceFilename(simulateResponse, timestamp) {
    const txnGroups = simulateResponse.txnGroups;
    const txnTypesCount = txnGroups.reduce((acc, txnGroup) => {
        txnGroup.txnResults.forEach(({ txnResult }) => {
            const { type } = txnResult.txn.txn;
            if (!acc.has(type)) {
                acc.set(type, { type, count: 0 });
            }
            const entry = acc.get(type);
            entry.count++;
        });
        return acc;
    }, new Map());
    const txnTypesStr = Array.from(txnTypesCount.values())
        .map(({ count, type }) => `${count}${type}`)
        .join('_');
    const lastRound = simulateResponse.lastRound;
    return `${timestamp}_lr${lastRound}_${txnTypesStr}.trace.avm.json`;
}
/**
 * Generates an AVM debug trace from the provided simulation response and persists it to a file.
 *
 * @param input - The AVMTracesEventData containing the simulation response and other relevant information.
 * @returns An object containing the output file path and the trace content as a string.
 *
 * @example
 * const eventData: AVMTracesEventData = {
 *   simulateResponse: // ... simulation response object
 * };
 *
 * const result = await writeAVMDebugTrace(eventData);
 * console.log(`Debug trace saved to: ${result.outputPath}`);
 * console.log(`Trace content: ${result.traceContent}`);
 */
async function writeAVMDebugTrace(input, bufferSizeMb) {
    try {
        const simulateResponse = input.simulateResponse;
        const projectRoot = await utils.getProjectRoot();
        const timestamp = utils.formatTimestampUTC(new Date());
        const outputRootDir = utils.joinPaths(projectRoot, constants.DEBUG_TRACES_DIR);
        const filename = generateDebugTraceFilename(simulateResponse, timestamp);
        const outputFilePath = utils.joinPaths(outputRootDir, filename);
        await utils.createDirForFilePathIfNotExists(outputFilePath);
        await cleanupOldFiles(bufferSizeMb, outputRootDir);
        const content = 'get_obj_for_encoding' in simulateResponse && typeof simulateResponse.get_obj_for_encoding === 'function'
            ? JSON.stringify(simulateResponse.get_obj_for_encoding(), null, 2)
            : 'encodeJSON' in algosdk && typeof algosdk.encodeJSON === 'function'
                ? algosdk.encodeJSON(simulateResponse, { space: 2 })
                : '';
        await utils.writeToFile(outputFilePath, content);
    }
    catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        throw err;
    }
}

exports.cleanupOldFiles = cleanupOldFiles;
exports.generateDebugTraceFilename = generateDebugTraceFilename;
exports.writeAVMDebugTrace = writeAVMDebugTrace;
//# sourceMappingURL=writeAVMDebugTrace.js.map
