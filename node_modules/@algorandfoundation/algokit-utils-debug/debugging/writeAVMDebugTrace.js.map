{"version":3,"file":"writeAVMDebugTrace.js","sources":["../../src/debugging/writeAVMDebugTrace.ts"],"sourcesContent":["import { AVMTracesEventData } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\nimport { DEBUG_TRACES_DIR } from '../constants'\nimport { createDirForFilePathIfNotExists, formatTimestampUTC, getProjectRoot, joinPaths, writeToFile } from '../utils'\n\ntype TxnTypeCount = {\n  type: string\n  count: number\n}\n\n/**\n * Removes old trace files when total size exceeds buffer limit\n */\nexport async function cleanupOldFiles(bufferSizeMb: number, outputRootDir: string): Promise<void> {\n  const fs = await import('fs')\n  const path = await import('path')\n\n  let totalSize = (\n    await Promise.all(\n      (await fs.promises.readdir(outputRootDir)).map(async (file) => (await fs.promises.stat(path.join(outputRootDir, file))).size),\n    )\n  ).reduce((a, b) => a + b, 0)\n\n  if (totalSize > bufferSizeMb * 1024 * 1024) {\n    const files = await fs.promises.readdir(outputRootDir)\n    const fileStats = await Promise.all(\n      files.map(async (file) => {\n        const stats = await fs.promises.stat(path.join(outputRootDir, file))\n        return { file, mtime: stats.mtime, size: stats.size }\n      }),\n    )\n\n    // Sort by modification time (oldest first)\n    fileStats.sort((a, b) => a.mtime.getTime() - b.mtime.getTime())\n\n    // Remove oldest files until we're under the buffer size\n    while (totalSize > bufferSizeMb * 1024 * 1024 && fileStats.length > 0) {\n      const oldestFile = fileStats.shift()!\n      totalSize -= oldestFile.size\n      await fs.promises.unlink(path.join(outputRootDir, oldestFile.file))\n    }\n  }\n}\n\n/**\n * Generates a descriptive filename for a debug trace based on transaction types\n */\nexport function generateDebugTraceFilename(simulateResponse: AVMTracesEventData['simulateResponse'], timestamp: string): string {\n  const txnGroups = simulateResponse.txnGroups\n  const txnTypesCount = txnGroups.reduce((acc: Map<string, TxnTypeCount>, txnGroup) => {\n    txnGroup.txnResults.forEach(({ txnResult }) => {\n      const { type } = txnResult.txn.txn\n      if (!acc.has(type)) {\n        acc.set(type, { type, count: 0 })\n      }\n      const entry = acc.get(type)!\n      entry.count++\n    })\n    return acc\n  }, new Map())\n\n  const txnTypesStr = Array.from(txnTypesCount.values())\n    .map(({ count, type }) => `${count}${type}`)\n    .join('_')\n\n  const lastRound = simulateResponse.lastRound\n  return `${timestamp}_lr${lastRound}_${txnTypesStr}.trace.avm.json`\n}\n\n/**\n * Generates an AVM debug trace from the provided simulation response and persists it to a file.\n *\n * @param input - The AVMTracesEventData containing the simulation response and other relevant information.\n * @returns An object containing the output file path and the trace content as a string.\n *\n * @example\n * const eventData: AVMTracesEventData = {\n *   simulateResponse: // ... simulation response object\n * };\n *\n * const result = await writeAVMDebugTrace(eventData);\n * console.log(`Debug trace saved to: ${result.outputPath}`);\n * console.log(`Trace content: ${result.traceContent}`);\n */\nexport async function writeAVMDebugTrace(input: AVMTracesEventData, bufferSizeMb: number): Promise<void> {\n  try {\n    const simulateResponse = input.simulateResponse\n    const projectRoot = await getProjectRoot()\n    const timestamp = formatTimestampUTC(new Date())\n    const outputRootDir = joinPaths(projectRoot, DEBUG_TRACES_DIR)\n    const filename = generateDebugTraceFilename(simulateResponse, timestamp)\n    const outputFilePath = joinPaths(outputRootDir, filename)\n\n    await createDirForFilePathIfNotExists(outputFilePath)\n    await cleanupOldFiles(bufferSizeMb, outputRootDir)\n\n    const content: string =\n      'get_obj_for_encoding' in simulateResponse && typeof simulateResponse.get_obj_for_encoding === 'function'\n        ? JSON.stringify(simulateResponse.get_obj_for_encoding(), null, 2)\n        : 'encodeJSON' in algosdk && typeof algosdk.encodeJSON === 'function'\n          ? algosdk.encodeJSON(simulateResponse, { space: 2 })\n          : ''\n\n    await writeToFile(outputFilePath, content)\n  } catch (error) {\n    const err = error instanceof Error ? error : new Error(String(error))\n    throw err\n  }\n}\n"],"names":["getProjectRoot","formatTimestampUTC","joinPaths","DEBUG_TRACES_DIR","createDirForFilePathIfNotExists","writeToFile"],"mappings":"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"}