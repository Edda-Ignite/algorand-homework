import algosdk from 'algosdk';
import { DEBUG_TRACES_DIR } from '../constants.mjs';
import { getProjectRoot, formatTimestampUTC, joinPaths, createDirForFilePathIfNotExists, writeToFile } from '../utils.mjs';

/**
 * Removes old trace files when total size exceeds buffer limit
 */
async function cleanupOldFiles(bufferSizeMb, outputRootDir) {
    const fs = await import('fs');
    const path = await import('path');
    let totalSize = (await Promise.all((await fs.promises.readdir(outputRootDir)).map(async (file) => (await fs.promises.stat(path.join(outputRootDir, file))).size))).reduce((a, b) => a + b, 0);
    if (totalSize > bufferSizeMb * 1024 * 1024) {
        const files = await fs.promises.readdir(outputRootDir);
        const fileStats = await Promise.all(files.map(async (file) => {
            const stats = await fs.promises.stat(path.join(outputRootDir, file));
            return { file, mtime: stats.mtime, size: stats.size };
        }));
        // Sort by modification time (oldest first)
        fileStats.sort((a, b) => a.mtime.getTime() - b.mtime.getTime());
        // Remove oldest files until we're under the buffer size
        while (totalSize > bufferSizeMb * 1024 * 1024 && fileStats.length > 0) {
            const oldestFile = fileStats.shift();
            totalSize -= oldestFile.size;
            await fs.promises.unlink(path.join(outputRootDir, oldestFile.file));
        }
    }
}
/**
 * Generates a descriptive filename for a debug trace based on transaction types
 */
function generateDebugTraceFilename(simulateResponse, timestamp) {
    const txnGroups = simulateResponse.txnGroups;
    const txnTypesCount = txnGroups.reduce((acc, txnGroup) => {
        txnGroup.txnResults.forEach(({ txnResult }) => {
            const { type } = txnResult.txn.txn;
            if (!acc.has(type)) {
                acc.set(type, { type, count: 0 });
            }
            const entry = acc.get(type);
            entry.count++;
        });
        return acc;
    }, new Map());
    const txnTypesStr = Array.from(txnTypesCount.values())
        .map(({ count, type }) => `${count}${type}`)
        .join('_');
    const lastRound = simulateResponse.lastRound;
    return `${timestamp}_lr${lastRound}_${txnTypesStr}.trace.avm.json`;
}
/**
 * Generates an AVM debug trace from the provided simulation response and persists it to a file.
 *
 * @param input - The AVMTracesEventData containing the simulation response and other relevant information.
 * @returns An object containing the output file path and the trace content as a string.
 *
 * @example
 * const eventData: AVMTracesEventData = {
 *   simulateResponse: // ... simulation response object
 * };
 *
 * const result = await writeAVMDebugTrace(eventData);
 * console.log(`Debug trace saved to: ${result.outputPath}`);
 * console.log(`Trace content: ${result.traceContent}`);
 */
async function writeAVMDebugTrace(input, bufferSizeMb) {
    try {
        const simulateResponse = input.simulateResponse;
        const projectRoot = await getProjectRoot();
        const timestamp = formatTimestampUTC(new Date());
        const outputRootDir = joinPaths(projectRoot, DEBUG_TRACES_DIR);
        const filename = generateDebugTraceFilename(simulateResponse, timestamp);
        const outputFilePath = joinPaths(outputRootDir, filename);
        await createDirForFilePathIfNotExists(outputFilePath);
        await cleanupOldFiles(bufferSizeMb, outputRootDir);
        const content = 'get_obj_for_encoding' in simulateResponse && typeof simulateResponse.get_obj_for_encoding === 'function'
            ? JSON.stringify(simulateResponse.get_obj_for_encoding(), null, 2)
            : 'encodeJSON' in algosdk && typeof algosdk.encodeJSON === 'function'
                ? algosdk.encodeJSON(simulateResponse, { space: 2 })
                : '';
        await writeToFile(outputFilePath, content);
    }
    catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        throw err;
    }
}

export { cleanupOldFiles, generateDebugTraceFilename, writeAVMDebugTrace };
//# sourceMappingURL=writeAVMDebugTrace.mjs.map
