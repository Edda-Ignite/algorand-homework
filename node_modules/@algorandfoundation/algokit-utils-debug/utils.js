'use strict';

var algokitUtils = require('@algorandfoundation/algokit-utils');
var constants = require('./constants.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

async function writeToFile(filePath, content) {
    const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
    const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
    await fs.promises.writeFile(filePath, content, 'utf8');
}
async function createDirForFilePathIfNotExists(filePath) {
    const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
    const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
    try {
        await fs.promises.access(path.dirname(filePath));
    }
    catch (error) {
        const err = error;
        if (err.code === 'ENOENT') {
            await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
        }
        else {
            throw err;
        }
    }
}
async function getProjectRoot() {
    const projectRoot = algokitUtils.Config.projectRoot;
    if (!projectRoot) {
        const algokitProjectRoot = process.env.ALGOKIT_PROJECT_ROOT;
        if (algokitProjectRoot) {
            const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
            if (fs.existsSync(algokitProjectRoot)) {
                algokitUtils.Config.configure({ projectRoot: algokitProjectRoot });
                return algokitProjectRoot;
            }
        }
        const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
        const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
        let currentPath = process.cwd();
        for (let i = 0; i < (algokitUtils.Config.maxSearchDepth || constants.DEFAULT_MAX_SEARCH_DEPTH); i++) {
            if (fs.existsSync(`${currentPath}/.algokit.toml`)) {
                algokitUtils.Config.configure({ projectRoot: currentPath });
                return currentPath;
            }
            currentPath = path.dirname(currentPath);
        }
    }
    if (!projectRoot) {
        throw new Error('No project root found. Please run this command from within a valid AlgoKit project (must contain a .algokit.toml file).');
    }
    return projectRoot;
}
function joinPaths(...parts) {
    const separator = typeof process !== 'undefined' && process.platform === 'win32' ? '\\' : '/';
    return parts.join(separator).replace(/\/+/g, separator);
}
/**
 * Formats a date to YYYYMMDD_HHMMSS in UTC, equivalent to algokit-utils-py format:
 * datetime.now(tz=timezone.utc).strftime("%Y%m%d_%H%M%S")
 */
function formatTimestampUTC(date) {
    // Get UTC components
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0'); // Months are zero-based
    const day = String(date.getUTCDate()).padStart(2, '0');
    const hours = String(date.getUTCHours()).padStart(2, '0');
    const minutes = String(date.getUTCMinutes()).padStart(2, '0');
    const seconds = String(date.getUTCSeconds()).padStart(2, '0');
    // Format the datetime string
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
}

exports.createDirForFilePathIfNotExists = createDirForFilePathIfNotExists;
exports.formatTimestampUTC = formatTimestampUTC;
exports.getProjectRoot = getProjectRoot;
exports.joinPaths = joinPaths;
exports.writeToFile = writeToFile;
//# sourceMappingURL=utils.js.map
