import type { Props } from '../typescript-helpers';
import type { Expression, Statement } from './nodes';
import { ArrayLength, ArrayReplace, AssignmentExpression, AssignmentStatement, BigUIntBinaryOperation, Block, BoolConstant, BooleanBinaryOperation, BytesComparisonExpression, BytesConstant, BytesEncoding, CheckedMaybe, concreteNodes, Copy, ExpressionStatement, IntegerConstant, MethodDocumentation, Not, NumericComparisonExpression, ReinterpretCast, SingleEvaluation, StringConstant, SubmitInnerTransaction, TupleExpression, TupleItemExpression, UInt64BinaryOperation, VoidConstant } from './nodes';
import type { SourceLocation } from './source-location';
import { wtypes } from './wtypes';
type ConcreteNodes = typeof concreteNodes;
declare const explicitNodeFactory: {
    voidConstant(props: {
        sourceLocation: SourceLocation;
    }): VoidConstant;
    bytesConstant(props: {
        value: Uint8Array;
        encoding?: BytesEncoding;
        sourceLocation: SourceLocation;
        wtype?: wtypes.WType;
    }): BytesConstant;
    stringConstant(props: {
        value: string;
        sourceLocation: SourceLocation;
        wtype?: wtypes.WType;
    }): StringConstant;
    uInt64Constant({ value, tealAlias, sourceLocation, }: {
        value: bigint;
        tealAlias?: string;
        sourceLocation: SourceLocation;
    }): IntegerConstant;
    bigUIntConstant({ value, sourceLocation }: {
        value: bigint;
        sourceLocation: SourceLocation;
    }): IntegerConstant;
    not(props: {
        expr: Expression;
        sourceLocation: SourceLocation;
    }): Not;
    uInt64BinaryOperation(props: Omit<Props<UInt64BinaryOperation>, "wtype">): UInt64BinaryOperation | IntegerConstant;
    bigUIntBinaryOperation(props: Omit<Props<BigUIntBinaryOperation>, "wtype">): BigUIntBinaryOperation | IntegerConstant;
    numericComparisonExpression(props: Omit<Props<NumericComparisonExpression>, "wtype">): NumericComparisonExpression;
    bytesComparisonExpression(props: Omit<Props<BytesComparisonExpression>, "wtype">): BytesComparisonExpression;
    boolConstant(props: {
        value: boolean;
        sourceLocation: SourceLocation;
        wtype?: wtypes.WType;
    }): BoolConstant;
    singleEvaluation({ source }: {
        source: Expression;
    }): SingleEvaluation;
    expressionStatement({ expr }: {
        expr: Expression;
    }): ExpressionStatement | AssignmentStatement;
    block({ sourceLocation, comment, label }: {
        sourceLocation: SourceLocation;
        comment?: string;
        label?: string;
    }, ...statements: Array<Statement | Statement[]>): Block;
    booleanBinaryOperation(props: Omit<Props<BooleanBinaryOperation>, "wtype">): BoolConstant | BooleanBinaryOperation;
    assignmentExpression({ target, value, sourceLocation, }: {
        target: AssignmentExpression["target"];
        value: Expression;
        sourceLocation: SourceLocation;
    }): AssignmentExpression;
    assignmentStatement({ target, value, sourceLocation, }: {
        target: AssignmentStatement["target"];
        value: Expression;
        sourceLocation: SourceLocation;
    }): AssignmentStatement;
    tupleExpression(props: Omit<Props<TupleExpression>, "wtype"> & {
        wtype?: wtypes.WTuple;
    }): TupleExpression;
    methodDocumentation(props?: {
        description?: string | null;
        args?: Map<string, string>;
        returns?: string | null;
    }): MethodDocumentation;
    copy({ value, sourceLocation }: {
        value: Expression;
        sourceLocation: SourceLocation;
    }): Copy;
    checkedMaybe({ expr, comment }: {
        expr: Expression;
        comment: string;
    }): CheckedMaybe;
    tupleItemExpression(props: Omit<Props<TupleItemExpression>, "wtype">): TupleItemExpression;
    reinterpretCast({ expr, wtype, sourceLocation }: {
        expr: Expression;
        wtype: wtypes.WType;
        sourceLocation: SourceLocation;
    }): BytesConstant | ReinterpretCast;
    arrayLength({ array, sourceLocation }: {
        array: Expression;
        sourceLocation: SourceLocation;
    }): ArrayLength;
    arrayReplace({ base, index, value, sourceLocation, }: {
        base: Expression;
        index: Expression;
        value: Expression;
        sourceLocation: SourceLocation;
    }): ArrayReplace;
    submitInnerTransaction({ itxns, sourceLocation }: Omit<Props<SubmitInnerTransaction>, "wtype">): SubmitInnerTransaction;
};
type ExplicitNodeFactory = typeof explicitNodeFactory;
type DefaultNodeFactory<TKey extends keyof ConcreteNodes> = (...args: ConstructorParameters<ConcreteNodes[TKey]>) => InstanceType<ConcreteNodes[TKey]>;
export type NodeFactory = {
    [key in keyof ConcreteNodes]: FactoryMethod<key>;
};
type FactoryMethod<TKey extends keyof ConcreteNodes> = TKey extends keyof ExplicitNodeFactory ? ExplicitNodeFactory[TKey] : DefaultNodeFactory<TKey>;
export declare const nodeFactory: NodeFactory;
export {};
