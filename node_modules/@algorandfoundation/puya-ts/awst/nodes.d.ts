import type { Props } from '../typescript-helpers';
import type { ContractReference, LogicSigReference, OnCompletionAction } from './models';
import type { SourceLocation } from './source-location';
import type { TxnField } from './txn-fields';
import type { wtypes } from './wtypes';
export declare abstract class Node {
    constructor(props: Props<Node>);
    readonly sourceLocation: SourceLocation;
}
export declare abstract class Statement extends Node {
    constructor(props: Props<Statement>);
    abstract accept<T>(visitor: StatementVisitor<T>): T;
}
export declare abstract class Expression extends Node {
    constructor(props: Props<Expression>);
    readonly wtype: wtypes.WType;
    abstract accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ExpressionStatement extends Statement {
    constructor(props: Props<ExpressionStatement>);
    readonly expr: Expression;
    readonly sourceLocation: SourceLocation;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class Block extends Statement {
    constructor(props: Props<Block>);
    readonly body: Array<Statement>;
    readonly label: string | null;
    readonly comment: string | null;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class Goto extends Statement {
    constructor(props: Props<Goto>);
    readonly target: string;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class IfElse extends Statement {
    constructor(props: Props<IfElse>);
    readonly condition: Expression;
    readonly ifBranch: Block;
    readonly elseBranch: Block | null;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class Switch extends Statement {
    constructor(props: Props<Switch>);
    readonly value: Expression;
    readonly cases: Map<Expression, Block>;
    readonly defaultCase: Block | null;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class WhileLoop extends Statement {
    constructor(props: Props<WhileLoop>);
    readonly condition: Expression;
    readonly loopBody: Block;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class LoopExit extends Statement {
    constructor(props: Props<LoopExit>);
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class LoopContinue extends Statement {
    constructor(props: Props<LoopContinue>);
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class ReturnStatement extends Statement {
    constructor(props: Props<ReturnStatement>);
    readonly value: Expression | null;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class AssertExpression extends Expression {
    constructor(props: Props<AssertExpression>);
    readonly condition: Expression | null;
    readonly errorMessage: string | null;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class IntegerConstant extends Expression {
    constructor(props: Props<IntegerConstant>);
    readonly wtype: wtypes.WType;
    readonly value: bigint;
    readonly tealAlias: string | null;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class DecimalConstant extends Expression {
    constructor(props: Props<DecimalConstant>);
    readonly wtype: wtypes.ARC4UFixedNxM;
    readonly value: string;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class BoolConstant extends Expression {
    constructor(props: Props<BoolConstant>);
    readonly value: boolean;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare enum BytesEncoding {
    unknown = "unknown",
    base16 = "base16",
    base32 = "base32",
    base64 = "base64",
    utf8 = "utf8"
}
export declare class BytesConstant extends Expression {
    constructor(props: Props<BytesConstant>);
    readonly wtype: wtypes.WType;
    readonly value: Uint8Array;
    readonly encoding: BytesEncoding;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class StringConstant extends Expression {
    constructor(props: Props<StringConstant>);
    readonly value: string;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class VoidConstant extends Expression {
    constructor(props: Props<VoidConstant>);
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class TemplateVar extends Expression {
    constructor(props: Props<TemplateVar>);
    readonly wtype: wtypes.WType;
    readonly name: string;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class MethodConstant extends Expression {
    constructor(props: Props<MethodConstant>);
    readonly wtype: wtypes.WType;
    readonly value: string;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class AddressConstant extends Expression {
    constructor(props: Props<AddressConstant>);
    readonly wtype: wtypes.WType;
    readonly value: string;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ARC4Encode extends Expression {
    constructor(props: Props<ARC4Encode>);
    readonly value: Expression;
    readonly wtype: wtypes.ARC4Type;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class Copy extends Expression {
    constructor(props: Props<Copy>);
    readonly value: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ArrayConcat extends Expression {
    constructor(props: Props<ArrayConcat>);
    readonly left: Expression;
    readonly right: Expression;
    readonly wtype: wtypes.ARC4DynamicArray | wtypes.StackArray;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ArrayExtend extends Expression {
    constructor(props: Props<ArrayExtend>);
    readonly base: Expression;
    readonly other: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ArrayPop extends Expression {
    constructor(props: Props<ArrayPop>);
    readonly base: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ArrayReplace extends Expression {
    constructor(props: Props<ArrayReplace>);
    readonly base: Expression;
    readonly index: Expression;
    readonly value: Expression;
    readonly wtype: wtypes.StackArray;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ARC4Decode extends Expression {
    constructor(props: Props<ARC4Decode>);
    readonly value: Expression;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class IntrinsicCall extends Expression {
    constructor(props: Props<IntrinsicCall>);
    readonly opCode: string;
    readonly immediates: Array<string | bigint>;
    readonly stackArgs: Array<Expression>;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class CreateInnerTransaction extends Expression {
    constructor(props: Props<CreateInnerTransaction>);
    readonly wtype: wtypes.WInnerTransactionFields;
    readonly fields: Map<TxnField, Expression>;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class UpdateInnerTransaction extends Expression {
    constructor(props: Props<UpdateInnerTransaction>);
    readonly itxn: Expression;
    readonly fields: Map<TxnField, Expression>;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class GroupTransactionReference extends Expression {
    constructor(props: Props<GroupTransactionReference>);
    readonly index: Expression;
    readonly wtype: wtypes.WGroupTransaction;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class CheckedMaybe extends Expression {
    constructor(props: Props<CheckedMaybe>);
    readonly expr: Expression;
    readonly comment: string;
    readonly wtype: wtypes.WType;
    readonly sourceLocation: SourceLocation;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class TupleExpression extends Expression {
    constructor(props: Props<TupleExpression>);
    readonly items: Array<Expression>;
    readonly wtype: wtypes.WTuple;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class TupleItemExpression extends Expression {
    constructor(props: Props<TupleItemExpression>);
    readonly base: Expression;
    readonly index: bigint;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class VarExpression extends Expression {
    constructor(props: Props<VarExpression>);
    readonly name: string;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class InnerTransactionField extends Expression {
    constructor(props: Props<InnerTransactionField>);
    readonly itxn: Expression;
    readonly field: TxnField;
    readonly arrayIndex: Expression | null;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class SubmitInnerTransaction extends Expression {
    constructor(props: Props<SubmitInnerTransaction>);
    readonly itxns: Array<Expression>;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class FieldExpression extends Expression {
    constructor(props: Props<FieldExpression>);
    readonly base: Expression;
    readonly name: string;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class IndexExpression extends Expression {
    constructor(props: Props<IndexExpression>);
    readonly base: Expression;
    readonly index: Expression;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class SliceExpression extends Expression {
    constructor(props: Props<SliceExpression>);
    readonly base: Expression;
    readonly beginIndex: Expression | null;
    readonly endIndex: Expression | null;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class IntersectionSliceExpression extends Expression {
    constructor(props: Props<IntersectionSliceExpression>);
    readonly base: Expression;
    readonly beginIndex: Expression | bigint | null;
    readonly endIndex: Expression | bigint | null;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class AppStateExpression extends Expression {
    constructor(props: Props<AppStateExpression>);
    readonly key: Expression;
    readonly existsAssertionMessage: string | null;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class AppAccountStateExpression extends Expression {
    constructor(props: Props<AppAccountStateExpression>);
    readonly key: Expression;
    readonly existsAssertionMessage: string | null;
    readonly account: Expression;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class BoxValueExpression extends Expression {
    constructor(props: Props<BoxValueExpression>);
    readonly key: Expression;
    readonly existsAssertionMessage: string | null;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class SingleEvaluation extends Expression {
    constructor(props: Props<SingleEvaluation>);
    readonly source: Expression;
    readonly id: symbol;
    readonly wtype: wtypes.WType;
    readonly sourceLocation: SourceLocation;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ReinterpretCast extends Expression {
    constructor(props: Props<ReinterpretCast>);
    readonly expr: Expression;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class NewArray extends Expression {
    constructor(props: Props<NewArray>);
    readonly wtype: wtypes.ARC4DynamicArray | wtypes.ARC4StaticArray | wtypes.ReferenceArray | wtypes.StackArray;
    readonly values: Array<Expression>;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ArrayLength extends Expression {
    constructor(props: Props<ArrayLength>);
    readonly array: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ConditionalExpression extends Expression {
    constructor(props: Props<ConditionalExpression>);
    readonly condition: Expression;
    readonly trueExpr: Expression;
    readonly falseExpr: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class AssignmentStatement extends Statement {
    constructor(props: Props<AssignmentStatement>);
    readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly value: Expression;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class AssignmentExpression extends Expression {
    constructor(props: Props<AssignmentExpression>);
    readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly value: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare enum EqualityComparison {
    eq = "==",
    ne = "!="
}
export declare enum NumericComparison {
    eq = "==",
    ne = "!=",
    lt = "<",
    lte = "<=",
    gt = ">",
    gte = ">="
}
export declare class NumericComparisonExpression extends Expression {
    constructor(props: Props<NumericComparisonExpression>);
    readonly wtype: wtypes.WType;
    readonly lhs: Expression;
    readonly operator: NumericComparison;
    readonly rhs: Expression;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class BytesComparisonExpression extends Expression {
    constructor(props: Props<BytesComparisonExpression>);
    readonly wtype: wtypes.WType;
    readonly lhs: Expression;
    readonly operator: EqualityComparison;
    readonly rhs: Expression;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class SubroutineID {
    constructor(props: Props<SubroutineID>);
    readonly target: string;
}
export declare class InstanceMethodTarget {
    constructor(props: Props<InstanceMethodTarget>);
    readonly memberName: string;
}
export declare class InstanceSuperMethodTarget {
    constructor(props: Props<InstanceSuperMethodTarget>);
    readonly memberName: string;
}
export declare class ContractMethodTarget {
    constructor(props: Props<ContractMethodTarget>);
    readonly cref: ContractReference;
    readonly memberName: string;
}
export declare class CallArg {
    constructor(props: Props<CallArg>);
    readonly name: string | null;
    readonly value: Expression;
}
export declare class SubroutineCallExpression extends Expression {
    constructor(props: Props<SubroutineCallExpression>);
    readonly target: SubroutineID | InstanceMethodTarget | InstanceSuperMethodTarget | ContractMethodTarget;
    readonly args: Array<CallArg>;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class PuyaLibData {
    constructor(props: Props<PuyaLibData>);
    readonly id: string;
    readonly params: Map<string, wtypes.WType>;
    readonly wtype: wtypes.WType;
}
export declare enum PuyaLibFunction {
    ensureBudget = "ensure_budget",
    isSubstring = "is_substring"
}
export declare class PuyaLibCall extends Expression {
    constructor(props: Props<PuyaLibCall>);
    readonly func: PuyaLibFunction;
    readonly args: Array<CallArg>;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare enum UInt64BinaryOperator {
    add = "+",
    sub = "-",
    mult = "*",
    floorDiv = "//",
    mod = "%",
    pow = "**",
    lshift = "<<",
    rshift = ">>",
    bitOr = "|",
    bitXor = "^",
    bitAnd = "&"
}
export declare enum BigUIntBinaryOperator {
    add = "+",
    sub = "-",
    mult = "*",
    floorDiv = "//",
    mod = "%",
    bitOr = "|",
    bitXor = "^",
    bitAnd = "&"
}
export declare enum BytesBinaryOperator {
    add = "+",
    bitOr = "|",
    bitXor = "^",
    bitAnd = "&"
}
export declare enum BytesUnaryOperator {
    bitInvert = "~"
}
export declare enum UInt64UnaryOperator {
    bitInvert = "~"
}
export declare enum UInt64PostfixUnaryOperator {
    increment = "++",
    decrement = "--"
}
export declare class UInt64UnaryOperation extends Expression {
    constructor(props: Props<UInt64UnaryOperation>);
    readonly op: UInt64UnaryOperator;
    readonly expr: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class UInt64PostfixUnaryOperation extends Expression {
    constructor(props: Props<UInt64PostfixUnaryOperation>);
    readonly op: UInt64PostfixUnaryOperator;
    readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare enum BigUIntPostfixUnaryOperator {
    increment = "++",
    decrement = "--"
}
export declare class BigUIntPostfixUnaryOperation extends Expression {
    constructor(props: Props<BigUIntPostfixUnaryOperation>);
    readonly op: BigUIntPostfixUnaryOperator;
    readonly target: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class BytesUnaryOperation extends Expression {
    constructor(props: Props<BytesUnaryOperation>);
    readonly op: BytesUnaryOperator;
    readonly expr: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class UInt64BinaryOperation extends Expression {
    constructor(props: Props<UInt64BinaryOperation>);
    readonly left: Expression;
    readonly op: UInt64BinaryOperator;
    readonly right: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class BigUIntBinaryOperation extends Expression {
    constructor(props: Props<BigUIntBinaryOperation>);
    readonly left: Expression;
    readonly op: BigUIntBinaryOperator;
    readonly right: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class BytesBinaryOperation extends Expression {
    constructor(props: Props<BytesBinaryOperation>);
    readonly left: Expression;
    readonly op: BytesBinaryOperator;
    readonly right: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare enum BinaryBooleanOperator {
    and = "and",
    or = "or"
}
export declare class BooleanBinaryOperation extends Expression {
    constructor(props: Props<BooleanBinaryOperation>);
    readonly left: Expression;
    readonly op: BinaryBooleanOperator;
    readonly right: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class Not extends Expression {
    constructor(props: Props<Not>);
    readonly expr: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class UInt64AugmentedAssignment extends Statement {
    constructor(props: Props<UInt64AugmentedAssignment>);
    readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly op: UInt64BinaryOperator;
    readonly value: Expression;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class BigUIntAugmentedAssignment extends Statement {
    constructor(props: Props<BigUIntAugmentedAssignment>);
    readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly op: BigUIntBinaryOperator;
    readonly value: Expression;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class BytesAugmentedAssignment extends Statement {
    constructor(props: Props<BytesAugmentedAssignment>);
    readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly op: BytesBinaryOperator;
    readonly value: Expression;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class Emit extends Expression {
    constructor(props: Props<Emit>);
    readonly signature: string;
    readonly value: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class Range extends Expression {
    constructor(props: Props<Range>);
    readonly wtype: wtypes.WType;
    readonly start: Expression;
    readonly stop: Expression;
    readonly step: Expression;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class Enumeration extends Expression {
    constructor(props: Props<Enumeration>);
    readonly expr: Expression;
    readonly wtype: wtypes.WEnumeration;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class Reversed extends Expression {
    constructor(props: Props<Reversed>);
    readonly expr: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class ForInLoop extends Statement {
    constructor(props: Props<ForInLoop>);
    readonly sequence: Expression;
    readonly items: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly loopBody: Block;
    accept<T>(visitor: StatementVisitor<T>): T;
}
export declare class StateGet extends Expression {
    constructor(props: Props<StateGet>);
    readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly default: Expression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class StateGetEx extends Expression {
    constructor(props: Props<StateGetEx>);
    readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly wtype: wtypes.WTuple;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class StateExists extends Expression {
    constructor(props: Props<StateExists>);
    readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class StateDelete extends Expression {
    constructor(props: Props<StateDelete>);
    readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression;
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class NewStruct extends Expression {
    constructor(props: Props<NewStruct>);
    readonly wtype: wtypes.WStructType | wtypes.ARC4Struct;
    readonly values: Map<string, Expression>;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare abstract class RootNode extends Node {
    constructor(props: Props<RootNode>);
    abstract accept<T>(visitor: RootNodeVisitor<T>): T;
}
export declare class SubroutineArgument {
    constructor(props: Props<SubroutineArgument>);
    readonly name: string;
    readonly sourceLocation: SourceLocation;
    readonly wtype: wtypes.WType;
}
export declare class MethodDocumentation {
    constructor(props: Props<MethodDocumentation>);
    readonly description: string | null;
    readonly args: Map<string, string>;
    readonly returns: string | null;
}
export declare abstract class _Function extends Node {
    constructor(props: Props<_Function>);
    readonly args: Array<SubroutineArgument>;
    readonly returnType: wtypes.WType;
    readonly body: Block;
    readonly documentation: MethodDocumentation;
    readonly inline: boolean | null;
}
declare const Subroutine_base: import("polytype").Polytype.ClusteredConstructor<[typeof _Function, typeof RootNode]>;
export declare class Subroutine extends Subroutine_base {
    constructor(props: Props<Subroutine>);
    readonly id: string;
    readonly name: string;
    accept<T>(visitor: RootNodeVisitor<T>): T;
}
export declare abstract class ContractMemberNode extends Node {
    constructor(props: Props<ContractMemberNode>);
    abstract accept<T>(visitor: ContractMemberNodeVisitor<T>): T;
}
declare const ContractMethod_base: import("polytype").Polytype.ClusteredConstructor<[typeof _Function, typeof ContractMemberNode]>;
export declare class ContractMethod extends ContractMethod_base {
    constructor(props: Props<ContractMethod>);
    readonly cref: ContractReference;
    readonly memberName: string;
    readonly arc4MethodConfig: ARC4BareMethodConfig | ARC4ABIMethodConfig | null;
    accept<T>(visitor: ContractMemberNodeVisitor<T>): T;
}
export declare enum AppStorageKind {
    appGlobal = 1,
    accountLocal = 2,
    box = 3
}
export declare class AppStorageDefinition extends ContractMemberNode {
    constructor(props: Props<AppStorageDefinition>);
    readonly memberName: string;
    readonly kind: AppStorageKind;
    readonly storageWtype: wtypes.WType;
    readonly keyWtype: wtypes.WType | null;
    readonly key: BytesConstant;
    readonly description: string | null;
    accept<T>(visitor: ContractMemberNodeVisitor<T>): T;
}
export declare class LogicSignature extends RootNode {
    constructor(props: Props<LogicSignature>);
    readonly id: LogicSigReference;
    readonly shortName: string;
    readonly program: Subroutine;
    readonly docstring: string | null;
    readonly reservedScratchSpace: Set<bigint>;
    readonly avmVersion: bigint | null;
    accept<T>(visitor: RootNodeVisitor<T>): T;
}
export declare class CompiledContract extends Expression {
    constructor(props: Props<CompiledContract>);
    readonly contract: ContractReference;
    readonly allocationOverrides: Map<TxnField, Expression>;
    readonly prefix: string | null;
    readonly templateVariables: Map<string, Expression>;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class CompiledLogicSig extends Expression {
    constructor(props: Props<CompiledLogicSig>);
    readonly logicSig: LogicSigReference;
    readonly prefix: string | null;
    readonly templateVariables: Map<string, Expression>;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class StateTotals {
    constructor(props: Props<StateTotals>);
    readonly globalUints: bigint | null;
    readonly localUints: bigint | null;
    readonly globalBytes: bigint | null;
    readonly localBytes: bigint | null;
}
export declare class ARC4Router extends Expression {
    constructor(props: Props<ARC4Router>);
    readonly wtype: wtypes.WType;
    accept<T>(visitor: ExpressionVisitor<T>): T;
}
export declare class Contract extends RootNode {
    constructor(props: Props<Contract>);
    readonly id: ContractReference;
    readonly name: string;
    readonly description: string | null;
    readonly methodResolutionOrder: Array<ContractReference>;
    readonly approvalProgram: ContractMethod;
    readonly clearProgram: ContractMethod;
    readonly methods: Array<ContractMethod>;
    readonly appState: Array<AppStorageDefinition>;
    readonly stateTotals: StateTotals | null;
    readonly reservedScratchSpace: Set<bigint>;
    readonly avmVersion: bigint | null;
    accept<T>(visitor: RootNodeVisitor<T>): T;
}
export declare enum ARC4CreateOption {
    allow = 1,
    require = 2,
    disallow = 3
}
export declare class ARC4BareMethodConfig {
    constructor(props: Props<ARC4BareMethodConfig>);
    readonly sourceLocation: SourceLocation;
    readonly allowedCompletionTypes: Array<OnCompletionAction>;
    readonly create: ARC4CreateOption;
}
export declare class ABIMethodArgConstantDefault {
    constructor(props: Props<ABIMethodArgConstantDefault>);
    readonly value: Expression;
}
export declare class ABIMethodArgMemberDefault {
    constructor(props: Props<ABIMethodArgMemberDefault>);
    readonly name: string;
}
export declare class ARC4ABIMethodConfig {
    constructor(props: Props<ARC4ABIMethodConfig>);
    readonly sourceLocation: SourceLocation;
    readonly allowedCompletionTypes: Array<OnCompletionAction>;
    readonly create: ARC4CreateOption;
    readonly name: string;
    readonly readonly: boolean;
    readonly defaultArgs: Map<string, ABIMethodArgMemberDefault | ABIMethodArgConstantDefault>;
}
export type LValue = VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression;
export type Constant = IntegerConstant | BoolConstant | BytesConstant | StringConstant | DecimalConstant | MethodConstant | AddressConstant;
export type AWST = Contract | LogicSignature | Subroutine;
export type ARC4MethodConfig = ARC4BareMethodConfig | ARC4ABIMethodConfig;
export declare const concreteNodes: {
    readonly expressionStatement: typeof ExpressionStatement;
    readonly block: typeof Block;
    readonly goto: typeof Goto;
    readonly ifElse: typeof IfElse;
    readonly switch: typeof Switch;
    readonly whileLoop: typeof WhileLoop;
    readonly loopExit: typeof LoopExit;
    readonly loopContinue: typeof LoopContinue;
    readonly returnStatement: typeof ReturnStatement;
    readonly assertExpression: typeof AssertExpression;
    readonly integerConstant: typeof IntegerConstant;
    readonly decimalConstant: typeof DecimalConstant;
    readonly boolConstant: typeof BoolConstant;
    readonly bytesConstant: typeof BytesConstant;
    readonly stringConstant: typeof StringConstant;
    readonly voidConstant: typeof VoidConstant;
    readonly templateVar: typeof TemplateVar;
    readonly methodConstant: typeof MethodConstant;
    readonly addressConstant: typeof AddressConstant;
    readonly aRC4Encode: typeof ARC4Encode;
    readonly copy: typeof Copy;
    readonly arrayConcat: typeof ArrayConcat;
    readonly arrayExtend: typeof ArrayExtend;
    readonly arrayPop: typeof ArrayPop;
    readonly arrayReplace: typeof ArrayReplace;
    readonly aRC4Decode: typeof ARC4Decode;
    readonly intrinsicCall: typeof IntrinsicCall;
    readonly createInnerTransaction: typeof CreateInnerTransaction;
    readonly updateInnerTransaction: typeof UpdateInnerTransaction;
    readonly groupTransactionReference: typeof GroupTransactionReference;
    readonly checkedMaybe: typeof CheckedMaybe;
    readonly tupleExpression: typeof TupleExpression;
    readonly tupleItemExpression: typeof TupleItemExpression;
    readonly varExpression: typeof VarExpression;
    readonly innerTransactionField: typeof InnerTransactionField;
    readonly submitInnerTransaction: typeof SubmitInnerTransaction;
    readonly fieldExpression: typeof FieldExpression;
    readonly indexExpression: typeof IndexExpression;
    readonly sliceExpression: typeof SliceExpression;
    readonly intersectionSliceExpression: typeof IntersectionSliceExpression;
    readonly appStateExpression: typeof AppStateExpression;
    readonly appAccountStateExpression: typeof AppAccountStateExpression;
    readonly boxValueExpression: typeof BoxValueExpression;
    readonly singleEvaluation: typeof SingleEvaluation;
    readonly reinterpretCast: typeof ReinterpretCast;
    readonly newArray: typeof NewArray;
    readonly arrayLength: typeof ArrayLength;
    readonly conditionalExpression: typeof ConditionalExpression;
    readonly assignmentStatement: typeof AssignmentStatement;
    readonly assignmentExpression: typeof AssignmentExpression;
    readonly numericComparisonExpression: typeof NumericComparisonExpression;
    readonly bytesComparisonExpression: typeof BytesComparisonExpression;
    readonly subroutineID: typeof SubroutineID;
    readonly instanceMethodTarget: typeof InstanceMethodTarget;
    readonly instanceSuperMethodTarget: typeof InstanceSuperMethodTarget;
    readonly contractMethodTarget: typeof ContractMethodTarget;
    readonly callArg: typeof CallArg;
    readonly subroutineCallExpression: typeof SubroutineCallExpression;
    readonly puyaLibData: typeof PuyaLibData;
    readonly puyaLibCall: typeof PuyaLibCall;
    readonly uInt64UnaryOperation: typeof UInt64UnaryOperation;
    readonly uInt64PostfixUnaryOperation: typeof UInt64PostfixUnaryOperation;
    readonly bigUIntPostfixUnaryOperation: typeof BigUIntPostfixUnaryOperation;
    readonly bytesUnaryOperation: typeof BytesUnaryOperation;
    readonly uInt64BinaryOperation: typeof UInt64BinaryOperation;
    readonly bigUIntBinaryOperation: typeof BigUIntBinaryOperation;
    readonly bytesBinaryOperation: typeof BytesBinaryOperation;
    readonly booleanBinaryOperation: typeof BooleanBinaryOperation;
    readonly not: typeof Not;
    readonly uInt64AugmentedAssignment: typeof UInt64AugmentedAssignment;
    readonly bigUIntAugmentedAssignment: typeof BigUIntAugmentedAssignment;
    readonly bytesAugmentedAssignment: typeof BytesAugmentedAssignment;
    readonly emit: typeof Emit;
    readonly range: typeof Range;
    readonly enumeration: typeof Enumeration;
    readonly reversed: typeof Reversed;
    readonly forInLoop: typeof ForInLoop;
    readonly stateGet: typeof StateGet;
    readonly stateGetEx: typeof StateGetEx;
    readonly stateExists: typeof StateExists;
    readonly stateDelete: typeof StateDelete;
    readonly newStruct: typeof NewStruct;
    readonly subroutineArgument: typeof SubroutineArgument;
    readonly methodDocumentation: typeof MethodDocumentation;
    readonly subroutine: typeof Subroutine;
    readonly contractMethod: typeof ContractMethod;
    readonly appStorageDefinition: typeof AppStorageDefinition;
    readonly logicSignature: typeof LogicSignature;
    readonly compiledContract: typeof CompiledContract;
    readonly compiledLogicSig: typeof CompiledLogicSig;
    readonly stateTotals: typeof StateTotals;
    readonly aRC4Router: typeof ARC4Router;
    readonly contract: typeof Contract;
    readonly aRC4BareMethodConfig: typeof ARC4BareMethodConfig;
    readonly aBIMethodArgConstantDefault: typeof ABIMethodArgConstantDefault;
    readonly aBIMethodArgMemberDefault: typeof ABIMethodArgMemberDefault;
    readonly aRC4ABIMethodConfig: typeof ARC4ABIMethodConfig;
    readonly uInt64Constant: typeof IntegerConstant;
    readonly bigUIntConstant: typeof IntegerConstant;
};
export interface ExpressionVisitor<T> {
    visitAssertExpression(expression: AssertExpression): T;
    visitIntegerConstant(expression: IntegerConstant): T;
    visitDecimalConstant(expression: DecimalConstant): T;
    visitBoolConstant(expression: BoolConstant): T;
    visitBytesConstant(expression: BytesConstant): T;
    visitStringConstant(expression: StringConstant): T;
    visitVoidConstant(expression: VoidConstant): T;
    visitTemplateVar(expression: TemplateVar): T;
    visitMethodConstant(expression: MethodConstant): T;
    visitAddressConstant(expression: AddressConstant): T;
    visitARC4Encode(expression: ARC4Encode): T;
    visitCopy(expression: Copy): T;
    visitArrayConcat(expression: ArrayConcat): T;
    visitArrayExtend(expression: ArrayExtend): T;
    visitArrayPop(expression: ArrayPop): T;
    visitArrayReplace(expression: ArrayReplace): T;
    visitARC4Decode(expression: ARC4Decode): T;
    visitIntrinsicCall(expression: IntrinsicCall): T;
    visitCreateInnerTransaction(expression: CreateInnerTransaction): T;
    visitUpdateInnerTransaction(expression: UpdateInnerTransaction): T;
    visitGroupTransactionReference(expression: GroupTransactionReference): T;
    visitCheckedMaybe(expression: CheckedMaybe): T;
    visitTupleExpression(expression: TupleExpression): T;
    visitTupleItemExpression(expression: TupleItemExpression): T;
    visitVarExpression(expression: VarExpression): T;
    visitInnerTransactionField(expression: InnerTransactionField): T;
    visitSubmitInnerTransaction(expression: SubmitInnerTransaction): T;
    visitFieldExpression(expression: FieldExpression): T;
    visitIndexExpression(expression: IndexExpression): T;
    visitSliceExpression(expression: SliceExpression): T;
    visitIntersectionSliceExpression(expression: IntersectionSliceExpression): T;
    visitAppStateExpression(expression: AppStateExpression): T;
    visitAppAccountStateExpression(expression: AppAccountStateExpression): T;
    visitBoxValueExpression(expression: BoxValueExpression): T;
    visitSingleEvaluation(expression: SingleEvaluation): T;
    visitReinterpretCast(expression: ReinterpretCast): T;
    visitNewArray(expression: NewArray): T;
    visitArrayLength(expression: ArrayLength): T;
    visitConditionalExpression(expression: ConditionalExpression): T;
    visitAssignmentExpression(expression: AssignmentExpression): T;
    visitNumericComparisonExpression(expression: NumericComparisonExpression): T;
    visitBytesComparisonExpression(expression: BytesComparisonExpression): T;
    visitSubroutineCallExpression(expression: SubroutineCallExpression): T;
    visitPuyaLibCall(expression: PuyaLibCall): T;
    visitUInt64UnaryOperation(expression: UInt64UnaryOperation): T;
    visitUInt64PostfixUnaryOperation(expression: UInt64PostfixUnaryOperation): T;
    visitBigUIntPostfixUnaryOperation(expression: BigUIntPostfixUnaryOperation): T;
    visitBytesUnaryOperation(expression: BytesUnaryOperation): T;
    visitUInt64BinaryOperation(expression: UInt64BinaryOperation): T;
    visitBigUIntBinaryOperation(expression: BigUIntBinaryOperation): T;
    visitBytesBinaryOperation(expression: BytesBinaryOperation): T;
    visitBooleanBinaryOperation(expression: BooleanBinaryOperation): T;
    visitNot(expression: Not): T;
    visitEmit(expression: Emit): T;
    visitRange(expression: Range): T;
    visitEnumeration(expression: Enumeration): T;
    visitReversed(expression: Reversed): T;
    visitStateGet(expression: StateGet): T;
    visitStateGetEx(expression: StateGetEx): T;
    visitStateExists(expression: StateExists): T;
    visitStateDelete(expression: StateDelete): T;
    visitNewStruct(expression: NewStruct): T;
    visitCompiledContract(expression: CompiledContract): T;
    visitCompiledLogicSig(expression: CompiledLogicSig): T;
    visitARC4Router(expression: ARC4Router): T;
}
export interface StatementVisitor<T> {
    visitExpressionStatement(statement: ExpressionStatement): T;
    visitBlock(statement: Block): T;
    visitGoto(statement: Goto): T;
    visitIfElse(statement: IfElse): T;
    visitSwitch(statement: Switch): T;
    visitWhileLoop(statement: WhileLoop): T;
    visitLoopExit(statement: LoopExit): T;
    visitLoopContinue(statement: LoopContinue): T;
    visitReturnStatement(statement: ReturnStatement): T;
    visitAssignmentStatement(statement: AssignmentStatement): T;
    visitUInt64AugmentedAssignment(statement: UInt64AugmentedAssignment): T;
    visitBigUIntAugmentedAssignment(statement: BigUIntAugmentedAssignment): T;
    visitBytesAugmentedAssignment(statement: BytesAugmentedAssignment): T;
    visitForInLoop(statement: ForInLoop): T;
}
export interface ContractMemberNodeVisitor<T> {
    visitContractMethod(contractMemberNode: ContractMethod): T;
    visitAppStorageDefinition(contractMemberNode: AppStorageDefinition): T;
}
export interface RootNodeVisitor<T> {
    visitSubroutine(rootNode: Subroutine): T;
    visitLogicSignature(rootNode: LogicSignature): T;
    visitContract(rootNode: Contract): T;
}
export {};
