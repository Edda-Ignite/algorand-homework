import ts from 'typescript';
import type { Expression, LValue, MethodDocumentation, Statement } from '../../awst/nodes';
import { SourceLocation } from '../../awst/source-location';
import type { Expressions } from '../../visitor/syntax-names';
import type { Visitor } from '../../visitor/visitor';
import { AwstBuildContext } from '../context/awst-build-context';
import { InstanceBuilder, NodeBuilder } from '../eb';
import type { PType } from '../ptypes';
import { TextVisitor } from './text-visitor';
export declare abstract class BaseVisitor implements Visitor<Expressions, NodeBuilder> {
    private baseAccept;
    readonly textVisitor: TextVisitor;
    get context(): AwstBuildContext;
    protected constructor();
    logNotSupported(node: ts.Node | undefined, message: string): void;
    throwNotSupported(node: ts.Node, message: string): never;
    visitBigIntLiteral(node: ts.BigIntLiteral): InstanceBuilder;
    visitRegularExpressionLiteral(node: ts.RegularExpressionLiteral): InstanceBuilder;
    visitFalseKeyword(node: ts.FalseLiteral): InstanceBuilder;
    visitTrueKeyword(node: ts.TrueLiteral): InstanceBuilder;
    sourceLocation(node: ts.Node): SourceLocation;
    visitStringLiteral(node: ts.StringLiteral): InstanceBuilder;
    visitNoSubstitutionTemplateLiteral(node: ts.NoSubstitutionTemplateLiteral): InstanceBuilder;
    visitNumericLiteral(node: ts.NumericLiteral): InstanceBuilder;
    visitIdentifier(node: ts.Identifier): NodeBuilder;
    visitImportKeyword(node: ts.ImportExpression): NodeBuilder;
    visitNullKeyword(node: ts.NullLiteral): NodeBuilder;
    visitPrivateIdentifier(node: ts.PrivateIdentifier): NodeBuilder;
    visitSuperKeyword(node: ts.SuperExpression): NodeBuilder;
    visitThisKeyword(node: ts.ThisExpression): NodeBuilder;
    visitFunctionExpression(node: ts.FunctionExpression): NodeBuilder;
    visitClassExpression(node: ts.ClassExpression): NodeBuilder;
    visitObjectLiteralExpression(node: ts.ObjectLiteralExpression): NodeBuilder;
    visitArrayLiteralExpression(node: ts.ArrayLiteralExpression): NodeBuilder;
    visitSpreadElement(node: ts.SpreadElement): NodeBuilder;
    visitPropertyAccessExpression(node: ts.PropertyAccessExpression): NodeBuilder;
    visitElementAccessExpression(node: ts.ElementAccessExpression): NodeBuilder;
    visitCallExpression(node: ts.CallExpression): NodeBuilder;
    visitNewExpression(node: ts.NewExpression): NodeBuilder;
    visitTaggedTemplateExpression(node: ts.TaggedTemplateExpression): NodeBuilder;
    visitTypeAssertionExpression(node: ts.TypeAssertion): NodeBuilder;
    visitParenthesizedExpression(node: ts.ParenthesizedExpression): NodeBuilder;
    /**
     * `delete obj.prop`
     *
     * Not supported currently as typescript requires 'prop' to be optional and we don't support optional values
     */
    visitDeleteExpression(node: ts.DeleteExpression): NodeBuilder;
    visitTypeOfExpression(node: ts.TypeOfExpression): NodeBuilder;
    visitVoidExpression(node: ts.VoidExpression): NodeBuilder;
    visitAwaitExpression(node: ts.AwaitExpression): NodeBuilder;
    visitPrefixUnaryExpression(node: ts.PrefixUnaryExpression): NodeBuilder;
    visitPostfixUnaryExpression(node: ts.PostfixUnaryExpression): NodeBuilder;
    evaluateCondition(nodeOrBuilder: ts.Expression | NodeBuilder, negate?: boolean): Expression;
    private getBinaryOpKind;
    visitBinaryExpression(node: ts.BinaryExpression): NodeBuilder;
    visitConditionalExpression(node: ts.ConditionalExpression): NodeBuilder;
    createConditionalExpression({ condition, ptype, whenFalse, whenTrue, sourceLocation, }: {
        ptype: PType;
        condition: Expression;
        whenTrue: InstanceBuilder;
        whenFalse: InstanceBuilder;
        sourceLocation: SourceLocation;
    }): InstanceBuilder;
    visitTemplateExpression(node: ts.TemplateExpression): NodeBuilder;
    visitYieldExpression(node: ts.YieldExpression): NodeBuilder;
    visitOmittedExpression(node: ts.OmittedExpression): NodeBuilder;
    visitExpressionWithTypeArguments(node: ts.ExpressionWithTypeArguments): NodeBuilder;
    visitAsExpression(node: ts.AsExpression): NodeBuilder;
    visitNonNullExpression(node: ts.NonNullExpression): NodeBuilder;
    visitSatisfiesExpression(node: ts.SatisfiesExpression): NodeBuilder;
    handleAssignmentStatement(target: InstanceBuilder, source: InstanceBuilder, sourceLocation: SourceLocation): Statement;
    handleAssignment(target: InstanceBuilder, source: InstanceBuilder, sourceLocation: SourceLocation): InstanceBuilder;
    /**
     * Given a target and source type, produce a type that represents the result of an assignment expression.
     *
     * This will largely represent the sourceType verbatim with the exception of numeric literal types which need
     * to be narrowed using the targetType.
     *
     * Eg. a `number` on the rhs should be narrowed to whatever the lhs is for example uint64.
     * @param targetType The type of the assignment target
     * @param sourceType The type of the assignment source
     * @param sourceLocation
     * @private
     */
    private buildAssignmentExpressionType;
    buildLValue(target: InstanceBuilder, assignmentType: PType, sourceLocation: SourceLocation): LValue;
    protected parseMemberModifiers(node: {
        modifiers?: readonly ts.ModifierLike[];
    }): {
        isStatic: boolean;
        isPublic: boolean;
    };
    protected getNodeDescription(node: ts.Node): string | null;
    protected getMethodDocumentation(node: ts.FunctionDeclaration | ts.MethodDeclaration | ts.ConstructorDeclaration): MethodDocumentation;
}
