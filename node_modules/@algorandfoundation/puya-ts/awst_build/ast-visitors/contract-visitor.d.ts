import ts from 'typescript';
import type * as awst from '../../awst/nodes';
import type { ClassElements } from '../../visitor/syntax-names';
import type { Visitor } from '../../visitor/visitor';
import type { ContractClassPType } from '../ptypes';
import { BaseVisitor } from './base-visitor';
export declare class ContractVisitor extends BaseVisitor implements Visitor<ClassElements, void> {
    private _ctor?;
    private _methods;
    private readonly _contractPType;
    private readonly _propertyInitialization;
    accept: <TNode extends ts.Node>(node: TNode) => import("../../visitor/visitor").MethodReturnType<import("../../visitor/visitor").VisitorMethod<import("../../visitor/visitor").KindForNode<import("../../visitor/syntax-names").MapBaseType<TNode>>>, ContractVisitor>;
    private readonly metaData;
    constructor(classDec: ts.ClassDeclaration, ptype: ContractClassPType);
    get result(): [] | [awst.Contract];
    private acceptAndIgnoreBuildErrors;
    private makeDefaultConstructor;
    visitClassStaticBlockDeclaration(node: ts.ClassStaticBlockDeclaration): void;
    visitConstructor(node: ts.ConstructorDeclaration): void;
    visitGetAccessor(node: ts.GetAccessorDeclaration): void;
    visitIndexSignature(node: ts.IndexSignatureDeclaration): void;
    visitMethodDeclaration(node: ts.MethodDeclaration): void;
    visitPropertyDeclaration(node: ts.PropertyDeclaration): void;
    visitSemicolonClassElement(node: ts.SemicolonClassElement): void;
    visitSetAccessor(node: ts.SetAccessorDeclaration): void;
    static buildContract(classDec: ts.ClassDeclaration, ptype: ContractClassPType): () => [] | [awst.Contract];
}
