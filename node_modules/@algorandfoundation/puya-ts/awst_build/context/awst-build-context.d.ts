import ts from 'typescript';
import type { awst } from '../../awst';
import type { ContractReference, LogicSigReference } from '../../awst/models';
import type { AppStorageDefinition, ARC4MethodConfig } from '../../awst/nodes';
import { SourceLocation } from '../../awst/source-location';
import type { NodeBuilder } from '../eb';
import type { AppStorageDeclaration } from '../models/app-storage-declaration';
import type { ContractClassModel } from '../models/contract-class-model';
import { CompilationSet } from '../models/contract-class-model';
import type { LogicSigClassModel } from '../models/logic-sig-class-model';
import type { ContractClassPType, PType } from '../ptypes';
import { EvaluationContext } from './evaluation-context';
import { SwitchLoopContext } from './switch-loop-context';
export declare abstract class AwstBuildContext {
    /**
     * Get the source location of a node in the current source file
     * @param node
     */
    abstract getSourceLocation(node: ts.Node): SourceLocation;
    /**
     * Get NodeBuilder instance for the given identifier.
     * @param node
     */
    abstract getBuilderForNode(node: ts.Identifier): NodeBuilder;
    /**
     * Reflect the PType of the given node
     * @param node
     */
    abstract getPTypeForNode(node: ts.Node): PType;
    /**
     * Reflect generic type parameters for a call expression
     * @param node
     */
    abstract getTypeParameters(node: ts.CallExpression | ts.NewExpression): PType[];
    /**
     * Resolve the given identifier to a unique variable name that accounts
     * for shadowed variable names.
     * @param node
     */
    abstract resolveVariableName(node: ts.Identifier): string;
    /**
     * Resolve the given parameter declaration to a unique parameter name to be used
     * in destructuring assignments where no explicit parameter name is available.
     * @param node
     */
    abstract resolveDestructuredParamName(node: ts.ParameterDeclaration): string;
    /**
     * Generate a unique variable name for a discarded value.
     */
    abstract generateDiscardedVarName(): string;
    /**
     * Add a named constant to the current context
     * @param identifier The identifier of the constant declaration in this source file
     * @param value The compile time constant value
     */
    abstract addConstant(identifier: ts.Identifier, value: awst.Constant | awst.TemplateVar): void;
    /**
     * Retrieve the evaluation context
     */
    abstract get evaluationCtx(): EvaluationContext;
    /**
     * Retrieve the switch loop context
     */
    abstract get switchLoopCtx(): SwitchLoopContext;
    abstract addStorageDeclaration(declaration: AppStorageDeclaration): void;
    abstract addArc4Config(methodData: {
        contractReference: ContractReference;
        sourceLocation: SourceLocation;
        arc4MethodConfig: ARC4MethodConfig;
        memberName: string;
    }): void;
    abstract getArc4Config(contractType: ContractClassPType, memberName: string): ARC4MethodConfig | undefined;
    abstract getArc4Config(contractType: ContractClassPType): ARC4MethodConfig[];
    abstract getStorageDeclaration(contractType: ContractClassPType, memberName: string): AppStorageDeclaration | undefined;
    abstract getStorageDefinitionsForContract(contractType: ContractClassPType): AppStorageDefinition[];
    abstract addToCompilationSet(compilationTarget: ContractReference, contract: ContractClassModel): void;
    abstract addToCompilationSet(compilationTarget: LogicSigReference, logicSig: LogicSigClassModel): void;
    abstract get compilationSet(): CompilationSet;
    protected abstract createChildContext(): AwstBuildContext;
    static get current(): AwstBuildContext;
    private static asyncStore;
    static run<R>(program: ts.Program, cb: () => R): R;
    runInChildContext<R>(cb: (deferred: RunDeferred) => R): R;
}
type RunDeferred = <T>(action: () => T) => () => T;
export {};
