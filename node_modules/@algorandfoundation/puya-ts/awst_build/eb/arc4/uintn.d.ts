import type { Expression } from '../../../awst/nodes';
import type { SourceLocation } from '../../../awst/source-location';
import type { LibClassType, PType } from '../../ptypes';
import { UintNType } from '../../ptypes/arc4-types';
import type { InstanceBuilder, NodeBuilder } from '../index';
import { ClassBuilder } from '../index';
import { Arc4EncodedBaseExpressionBuilder } from './base';
export declare class UintNClassBuilder extends ClassBuilder {
    readonly ptype: LibClassType;
    newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder;
}
export declare const classBuilderForUintNAlias: (aliasClass: LibClassType, aliasInstance: UintNType) => {
    new (sourceLocation: SourceLocation): {
        readonly ptype: LibClassType;
        newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder;
        call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
        readonly sourceLocation: SourceLocation;
        readonly typeDescription: string;
        taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder;
        hasProperty(_name: string): boolean;
        memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder;
        indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder;
        boolEval(sourceLocation: SourceLocation, negate?: boolean): Expression;
    };
};
export declare class UintNExpressionBuilder extends Arc4EncodedBaseExpressionBuilder<UintNType> {
    constructor(expr: Expression, ptype: PType);
}
