import type { ContractMethodTarget, InstanceMethodTarget, InstanceSuperMethodTarget, MethodConstant, SubroutineID } from '../../awst/nodes';
import type { SourceLocation } from '../../awst/source-location';
import type { ContractClassPType, PType } from '../ptypes';
import { FunctionPType } from '../ptypes';
import type { NodeBuilder } from './index';
import { FunctionBuilder } from './index';
export declare abstract class SubroutineExpressionBuilder extends FunctionBuilder {
    readonly ptype: FunctionPType;
    readonly target: SubroutineID | InstanceMethodTarget | InstanceSuperMethodTarget | ContractMethodTarget;
    protected constructor(sourceLocation: SourceLocation, ptype: FunctionPType, target: SubroutineID | InstanceMethodTarget | InstanceSuperMethodTarget | ContractMethodTarget);
    call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
}
/**
 * Invoke a contract method on the current contract (ie. this.someMethod())
 */
export declare class ContractMethodExpressionBuilder extends SubroutineExpressionBuilder {
    readonly contractType: ContractClassPType;
    readonly target: ContractMethodTarget;
    constructor(sourceLocation: SourceLocation, ptype: FunctionPType, contractType: ContractClassPType);
    getMethodSelector(sourceLocation?: SourceLocation): MethodConstant;
}
/**
 * Invoke a contract method on the super contract (ie. super.someMethod())
 */
export declare class BaseContractMethodExpressionBuilder extends SubroutineExpressionBuilder {
    constructor(sourceLocation: SourceLocation, ptype: FunctionPType);
}
/**
 * Invoke a free subroutine (ie. someMethod())
 */
export declare class FreeSubroutineExpressionBuilder extends SubroutineExpressionBuilder {
    constructor(sourceLocation: SourceLocation, ptype: PType);
}
