import { awst } from '../../awst';
import type { Expression } from '../../awst/nodes';
import type { SourceLocation } from '../../awst/source-location';
import type { DecoratorData } from '../models/decorator-data';
import type { LibClassType, PType, PTypeOrClass } from '../ptypes';
export declare enum BuilderComparisonOp {
    eq = "===",
    ne = "!==",
    lt = "<",
    lte = "<=",
    gt = ">",
    gte = ">="
}
export declare enum BuilderUnaryOp {
    inc = "++",
    dec = "--",
    bit_inv = "~",
    neg = "-",
    pos = "+"
}
export declare enum BuilderBinaryOp {
    add = "+",
    sub = "-",
    mult = "*",
    div = "/",
    mod = "%",
    pow = "**",
    matMult = "@",
    lshift = "<<",
    rshift = ">>",
    bitOr = "|",
    bitXor = "^",
    bitAnd = "&",
    /**
     * Eval left, return right
     * let y = 2
     * // x == 4
     * const x = (y * 3, y - 2)
     */
    comma = ","
}
export declare abstract class NodeBuilder {
    readonly sourceLocation: SourceLocation;
    constructor(sourceLocation: SourceLocation);
    abstract readonly ptype: PType | undefined;
    get typeDescription(): string;
    call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
    newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder;
    taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder;
    hasProperty(_name: string): boolean;
    memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder;
    indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder;
    boolEval(sourceLocation: SourceLocation, negate?: boolean): awst.Expression;
}
export declare abstract class InstanceBuilder<TPType extends PType = PType> extends NodeBuilder {
    constructor(sourceLocation: SourceLocation);
    abstract get ptype(): TPType;
    abstract resolve(): awst.Expression;
    abstract resolveLValue(): awst.LValue;
    /**
     * Returns a boolean indicating if the current builder can be resolved to the target type.
     * Resolvable meaning it may have a different type, but would be assignable to the target type in TypeScript
     * without a cast.
     * @param ptype
     */
    resolvableToPType(ptype: PTypeOrClass): boolean;
    /**
     * Attempts to resolve the value held by this builder to the target type.
     * @param ptype
     */
    resolveToPType(ptype: PTypeOrClass): InstanceBuilder;
    singleEvaluation(): InstanceBuilder;
    toBytes(sourceLocation: SourceLocation): awst.Expression;
    toString(sourceLocation: SourceLocation): awst.Expression;
    prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    postfixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder;
    binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    iterate(sourceLocation: SourceLocation): awst.Expression;
    augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    reinterpretCast(target: PType, sourceLocation?: SourceLocation): InstanceBuilder<PType>;
}
export declare abstract class ClassBuilder extends NodeBuilder {
    abstract readonly ptype: LibClassType;
    abstract newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder;
    call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
}
export declare abstract class FunctionBuilder extends NodeBuilder {
    readonly ptype: PType | undefined;
    constructor(location: SourceLocation);
    abstract call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
}
export declare abstract class ParameterlessFunctionBuilder extends FunctionBuilder {
    private readonly expression;
    private readonly definition;
    constructor(expression: Expression, definition: (expr: Expression, sourceLocation: SourceLocation) => NodeBuilder);
    call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
}
export declare abstract class InstanceExpressionBuilder<TPType extends PType> extends InstanceBuilder<PType> {
    #private;
    protected _expr: awst.Expression;
    get ptype(): TPType;
    constructor(_expr: awst.Expression, ptype: TPType);
    resolve(): awst.Expression;
    resolveLValue(): awst.LValue;
}
export declare function requireLValue(expr: awst.Expression): awst.LValue;
export declare class DecoratorDataBuilder extends NodeBuilder {
    private readonly data;
    get ptype(): PType | undefined;
    constructor(sourceLocation: SourceLocation, data: DecoratorData);
    resolveDecoratorData(): DecoratorData;
}
