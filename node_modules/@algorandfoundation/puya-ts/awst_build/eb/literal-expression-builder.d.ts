import type { awst } from '../../awst';
import type { Expression, LValue } from '../../awst/nodes';
import type { SourceLocation } from '../../awst/source-location';
import type { PType, PTypeOrClass } from '../ptypes';
import type { BuilderBinaryOp, BuilderComparisonOp, BuilderUnaryOp, NodeBuilder } from './index';
import { InstanceBuilder } from './index';
export declare abstract class LiteralExpressionBuilder extends InstanceBuilder {
    resolve(): Expression;
    resolveLValue(): LValue;
    abstract resolvableToPType(ptype: PTypeOrClass): boolean;
    abstract resolveToPType(ptype: PTypeOrClass): InstanceBuilder;
    private throwInvalidExpression;
    compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder;
    binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder;
    call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
    taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder;
    indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder;
    singleEvaluation(): InstanceBuilder;
    toBytes(sourceLocation: SourceLocation): awst.Expression;
    prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    postfixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    iterate(sourceLocation: SourceLocation): awst.Expression;
    augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    hasProperty(_name: string): boolean;
}
