import { type BoxValueExpression, type Expression } from '../../../../awst/nodes';
import type { SourceLocation } from '../../../../awst/source-location';
import { AppStorageDeclaration } from '../../../models/app-storage-declaration';
import type { BoxPType, BoxRefPType } from '../../../ptypes';
import { BoxMapPType, type ContractClassPType, type PType } from '../../../ptypes';
import { InstanceExpressionBuilder } from '../../index';
import { ValueProxy } from '../value-proxy';
export declare abstract class BoxProxyExpressionBuilder<TProxyType extends BoxMapPType | BoxRefPType | BoxPType> extends InstanceExpressionBuilder<TProxyType> {
    buildStorageDeclaration(memberName: string, memberLocation: SourceLocation, memberDescription: string | null, contractType: ContractClassPType): AppStorageDeclaration;
    toBytes(sourceLocation: SourceLocation): Expression;
}
/**
 * Wraps the box value expression and watches for certain expressions which can be optimized.
 *
 * For example box.value.bytes.slice(...) can be optimized to use box_extract directly rather
 * than reading the entire box into memory and then slicing it. All unhandled scenarios are proxied
 * through to the underlying builder for the given type.
 */
export declare class BoxValueExpressionBuilder extends ValueProxy<PType> {
    constructor(boxValue: BoxValueExpression, ptype: PType);
}
export declare function boxValue({ key, sourceLocation, contentType, }: {
    key: Expression;
    sourceLocation: SourceLocation;
    contentType: PType;
}): BoxValueExpression;
export declare function boxLength(box: BoxValueExpression, sourceLocation: SourceLocation): import("../../index").InstanceBuilder<PType>;
export declare function boxExists(box: BoxValueExpression, sourceLocation: SourceLocation): import("../../index").InstanceBuilder<PType>;
