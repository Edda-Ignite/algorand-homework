import { awst } from '../../awst';
import type { Expression } from '../../awst/nodes';
import type { SourceLocation } from '../../awst/source-location';
import type { InstanceType, PType, PTypeOrClass } from '../ptypes';
import type { InstanceBuilder, NodeBuilder } from './index';
import { BuilderBinaryOp, BuilderComparisonOp, FunctionBuilder, InstanceExpressionBuilder } from './index';
export declare class StringFunctionBuilder extends FunctionBuilder {
    taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder;
    call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
}
export declare class StringExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
    constructor(expr: Expression);
    resolvableToPType(ptype: PTypeOrClass): boolean;
    resolveToPType(ptype: PTypeOrClass): InstanceBuilder;
    boolEval(sourceLocation: SourceLocation, negate?: boolean): Expression;
    memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder;
    compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder;
    binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder;
    toBytes(sourceLocation: SourceLocation): awst.Expression;
    toString(): Expression;
}
export declare class ConcatExpressionBuilder extends FunctionBuilder {
    private expr;
    constructor(expr: awst.Expression);
    call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder;
}
