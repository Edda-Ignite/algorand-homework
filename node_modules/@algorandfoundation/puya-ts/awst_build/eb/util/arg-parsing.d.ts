import type { SourceLocation } from '../../../awst/source-location';
import type { DeliberateAny, Tuple } from '../../../typescript-helpers';
import type { PType, PTypeOrClass } from '../../ptypes';
import type { InstanceBuilder, NodeBuilder } from '../index';
declare const ArgSpecDiscriminator: unique symbol;
/**
 * Optional arg spec
 * Will be mapped to `InstanceBuilder | undefined`
 */
type OptionalArg = {
    t: PTypeOrClass[];
    [ArgSpecDiscriminator]: 'arg';
    type: 'optional';
};
/**
 * Required arg spec
 * Will be mapped to `InstanceBuilder`
 */
type RequiredArg = {
    t: PTypeOrClass[];
    type: 'required';
    [ArgSpecDiscriminator]: 'arg';
};
/**
 * Passthrough arg spec
 * Will be mapped to NodeBuilder | undefined
 */
type PassthroughArg = {
    type: 'passthrough';
    [ArgSpecDiscriminator]: 'arg';
};
type ArgSpec = OptionalArg | RequiredArg | PassthroughArg;
/**
 * Object arg spec
 * Will be mapped to an object with the same keys where each property
 * is mapped to a Required or Optional spec
 */
type ObjArgSpec = Record<string, ArgSpec> & {
    [ArgSpecDiscriminator]: 'obj';
};
/**
 * Maps an ObjArgSpec to its output type
 */
type ArgsForObjSpec<T extends ObjArgSpec> = {
    [key in keyof T]: ArgFor<T[key]>;
};
/**
 * Defines the expected shape of a single argument.
 * Either an ArgSpec indicting a single value, or an ObjArgSpec indicating an
 * object literal with several properties
 */
type ArgMap = ArgSpec | ObjArgSpec;
/**
 * Maps an arg spec to its output type
 */
type ArgFor<T extends ObjArgSpec | ArgSpec> = T extends ObjArgSpec ? ArgsForObjSpec<T> : T extends PassthroughArg ? NodeBuilder | undefined : T extends OptionalArg ? InstanceBuilder | undefined : T extends RequiredArg ? InstanceBuilder : never;
/**
 * Maps each arg to an expected output type
 */
type ParsedArgs<T extends [...DeliberateAny[]]> = T extends [infer T1 extends ArgMap, ...infer TRest] ? [ArgFor<T1>, ...ParsedArgs<TRest>] : T extends [] ? [] : T extends Array<infer TItem extends ArgMap> ? Array<ArgFor<TItem>> : never;
declare const argSpecFactory: {
    /**
     * A required arg with one of the specified types
     * @param ptypes
     */
    required(...ptypes: PTypeOrClass[]): RequiredArg;
    /**
     * An optional arg with one of the specified types
     * @param ptypes
     */
    optional(...ptypes: PTypeOrClass[]): OptionalArg;
    /**
     * An object map arg, if all properties are optional - the arg itself becomes optional
     * @param props A mapping of expected properties to expected ptypes
     */
    obj<T extends Omit<ObjArgSpec, typeof ArgSpecDiscriminator>>(props: T): T & {
        [ArgSpecDiscriminator]: "obj";
    };
    passthrough(): PassthroughArg;
};
export type ArgSpecFactory = typeof argSpecFactory;
export declare function parseFunctionArgs<const TGenericCount extends number, const TArgMap extends [...ArgMap[]]>({ args, typeArgs, funcName, callLocation, genericTypeArgs, argSpec, }: {
    /**
     * Raw args array passed to call function
     */
    args: ReadonlyArray<NodeBuilder>;
    /**
     * Raw typeArgs array passed to call function
     */
    typeArgs: ReadonlyArray<PType>;
    /**
     * The name of the function being called
     * (Used for error context)
     */
    funcName: string;
    /**
     * The location of the call expression in the application source code
     */
    callLocation: SourceLocation;
    /**
     * The expected number of generic type arguments
     */
    genericTypeArgs: TGenericCount;
    /**
     * A mapping of expected argument types
     */
    argSpec: (a: ArgSpecFactory) => TArgMap;
}): {
    /**
     * A tuple of generic type args with a length of `TGenericCount`
     */
    ptypes: Tuple<PType, TGenericCount>;
    args: ParsedArgs<TArgMap>;
};
export {};
