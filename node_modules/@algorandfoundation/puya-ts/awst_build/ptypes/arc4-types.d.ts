import type { SourceLocation } from '../../awst/source-location';
import { wtypes } from '../../awst/wtypes';
import { GenericPType, PType } from './base';
import { ContractClassPType, LibClassType, LibFunctionType, ObjectPType, TuplePType } from './index';
import ARC4StaticArray = wtypes.ARC4StaticArray;
import WTuple = wtypes.WTuple;
export declare const UintNClass: LibClassType;
export declare const ByteClass: LibClassType;
export declare const UintN8Class: LibClassType;
export declare const UintN16Class: LibClassType;
export declare const UintN32Class: LibClassType;
export declare const UintN64Class: LibClassType;
export declare const UintN128Class: LibClassType;
export declare const UintN256Class: LibClassType;
export declare abstract class ARC4EncodedType extends PType {
    abstract readonly wtype: wtypes.ARC4Type;
    abstract readonly nativeType: PType | undefined;
    abstract readonly fixedBitSize: bigint | null;
    get fixedByteSize(): bigint | null;
    /**
     * Calculate fixed the number of bits required to store a sequence of ARC4 types using ARC4's bit-packing technique for consecutive booleans.
     *
     * Returns `null` if the sequence contains a dynamically sized type
     * @param types The sequence of types being encoded
     */
    protected static calculateFixedBitSize(types: ARC4EncodedType[]): bigint | null;
    /**
     * Get the number of bytes required to represent n bits
     * @param n The number of bits which need representing
     */
    protected static bitsToBytes(n: bigint): bigint;
    protected static roundBitsUpToNearestByte(bits: bigint): bigint;
}
export declare abstract class ARC4ArrayType extends ARC4EncodedType {
    readonly elementType: ARC4EncodedType;
    constructor({ elementType }: {
        elementType: ARC4EncodedType;
    });
}
export declare class ARC4InstanceType extends ARC4EncodedType {
    readonly wtype: wtypes.ARC4Type;
    readonly name: string;
    readonly module: "@algorandfoundation/algorand-typescript/arc4/encoded-types.d.ts";
    readonly singleton = false;
    readonly nativeType: PType;
    readonly fixedBitSize: bigint | null;
    constructor({ wtype, nativeType, name, fixedBitSize, }: {
        wtype: wtypes.ARC4Type;
        name: string;
        nativeType: PType;
        fixedBitSize: bigint | null;
    });
}
export declare const ARC4BoolClass: LibClassType;
export declare const ARC4StrClass: LibClassType;
export declare const arc4BooleanType: ARC4InstanceType;
export declare const arc4StringType: ARC4InstanceType;
export declare class ARC4StructClass extends PType {
    readonly name: string;
    readonly module: string;
    readonly singleton = true;
    readonly instanceType: ARC4StructType;
    readonly sourceLocation: SourceLocation | undefined;
    readonly wtype: undefined;
    constructor({ name, module, instanceType, sourceLocation, }: {
        name: string;
        module: string;
        instanceType: ARC4StructType;
        sourceLocation?: SourceLocation;
    });
    static fromStructType(ptype: ARC4StructType): ARC4StructClass;
}
export declare class ARC4StructType extends ARC4EncodedType {
    readonly name: string;
    readonly module: string;
    readonly description: string | undefined;
    readonly singleton = false;
    readonly fields: Record<string, ARC4EncodedType>;
    readonly sourceLocation: SourceLocation | undefined;
    readonly frozen: boolean;
    readonly fixedBitSize: bigint | null;
    constructor({ name, frozen, module, fields, description, sourceLocation, }: {
        name: string;
        module: string;
        frozen: boolean;
        description: string | undefined;
        fields: Record<string, ARC4EncodedType>;
        sourceLocation?: SourceLocation;
    });
    get nativeType(): ObjectPType;
    get wtype(): wtypes.ARC4Struct;
    get signature(): string;
}
export declare const arc4StructBaseType: ARC4StructType;
export declare const Arc4TupleClass: LibClassType;
export declare const Arc4TupleGeneric: GenericPType<ARC4TupleType>;
export declare class ARC4TupleType extends ARC4EncodedType {
    readonly name = "Tuple";
    readonly module: "@algorandfoundation/algorand-typescript/arc4/encoded-types.d.ts";
    readonly singleton = false;
    readonly items: ARC4EncodedType[];
    readonly sourceLocation: SourceLocation | undefined;
    readonly fixedBitSize: bigint | null;
    readonly nativeType: TuplePType;
    constructor({ types, sourceLocation }: {
        types: ARC4EncodedType[];
        sourceLocation?: SourceLocation;
    });
    get wtype(): wtypes.ARC4Tuple;
}
export declare const UintNGeneric: GenericPType<UintNType>;
export declare class UintNType extends ARC4EncodedType {
    readonly module: "@algorandfoundation/algorand-typescript/arc4/encoded-types.d.ts";
    readonly n: bigint;
    readonly name: string;
    readonly singleton = false;
    readonly wtype: wtypes.ARC4UIntN;
    get fixedBitSize(): bigint;
    get nativeType(): import("./index").InstanceType;
    constructor({ n, wtype, name }: {
        n: bigint;
        wtype?: wtypes.ARC4UIntN;
        name?: string;
    });
}
export declare const UFixedNxMClass: LibClassType;
export declare const UFixedNxMGeneric: GenericPType<UFixedNxMType>;
export declare class UFixedNxMType extends ARC4EncodedType {
    readonly module: "@algorandfoundation/algorand-typescript/arc4/encoded-types.d.ts";
    readonly n: bigint;
    readonly m: bigint;
    readonly name: string;
    readonly singleton = false;
    readonly wtype: wtypes.ARC4UFixedNxM;
    get fixedBitSize(): bigint;
    get nativeType(): import("./index").InstanceType;
    constructor({ n, m }: {
        n: bigint;
        m: bigint;
    });
}
export declare const arc4ByteAlias: UintNType;
export declare const DynamicArrayConstructor: LibClassType;
export declare const DynamicArrayGeneric: GenericPType<DynamicArrayType>;
export declare class DynamicArrayType extends ARC4ArrayType {
    readonly module: "@algorandfoundation/algorand-typescript/arc4/encoded-types.d.ts";
    readonly immutable: boolean;
    readonly name: string;
    readonly singleton = false;
    readonly sourceLocation: SourceLocation | undefined;
    readonly nativeType: PType;
    readonly wtype: wtypes.ARC4DynamicArray;
    readonly fixedBitSize: null;
    constructor({ elementType, nativeType, sourceLocation, name, immutable, }: {
        elementType: ARC4EncodedType;
        sourceLocation?: SourceLocation;
        name?: string;
        immutable?: boolean;
        nativeType?: PType;
    });
}
export declare const StaticArrayConstructor: LibClassType;
export declare const StaticArrayGeneric: GenericPType<StaticArrayType>;
export declare class StaticArrayType extends ARC4ArrayType {
    readonly module: "@algorandfoundation/algorand-typescript/arc4/encoded-types.d.ts";
    readonly arraySize: bigint;
    readonly immutable: boolean;
    readonly name: string;
    readonly singleton = false;
    readonly sourceLocation: SourceLocation | undefined;
    readonly wtype: wtypes.ARC4StaticArray;
    readonly nativeType: PType;
    readonly fixedBitSize: bigint | null;
    constructor({ elementType, arraySize, sourceLocation, wtype, name, immutable, nativeType, }: {
        immutable?: boolean;
        elementType: ARC4EncodedType;
        arraySize: bigint;
        sourceLocation?: SourceLocation;
        wtype?: ARC4StaticArray;
        name?: string;
        nativeType?: PType;
    });
}
export declare const arc4AddressAlias: StaticArrayType;
export declare const AddressClass: LibClassType;
export declare const StaticBytesGeneric: GenericPType<StaticBytesType>;
export declare const StaticBytesConstructor: LibClassType;
export declare class StaticBytesType extends StaticArrayType {
    constructor({ length }: {
        length: bigint;
    });
}
export declare const DynamicBytesConstructor: LibClassType;
export declare const DynamicBytesType: DynamicArrayType;
export declare const interpretAsArc4Function: LibFunctionType;
export declare const encodeArc4Function: LibFunctionType;
export declare const arc4EncodedLengthFunction: LibFunctionType;
export declare const decodeArc4Function: LibFunctionType;
export declare const methodSelectorFunction: LibFunctionType;
export declare const abiCallFunction: LibFunctionType;
export declare const compileArc4Function: LibFunctionType;
export declare const ContractProxyGeneric: GenericPType<ContractProxyType>;
export declare class ContractProxyType extends PType {
    readonly name: string;
    readonly module: "@algorandfoundation/algorand-typescript/arc4/c2c.d.ts";
    readonly wtype: WTuple;
    readonly singleton = false;
    readonly contractType: ContractClassPType;
    constructor({ contractType }: {
        contractType: ContractClassPType;
    });
}
export declare const TypedApplicationCallResponseGeneric: GenericPType<TypedApplicationCallResponseType>;
export declare class TypedApplicationCallResponseType extends ObjectPType {
    readonly name: string;
    readonly module: "@algorandfoundation/algorand-typescript/arc4/c2c.d.ts";
    readonly singleton = false;
    readonly returnValue: PType;
    constructor({ returnValue }: {
        returnValue: PType;
    });
}
