import { TransactionKind } from '../../awst/models';
import { SourceLocation } from '../../awst/source-location';
import { wtypes } from '../../awst/wtypes';
import { SymbolName } from '../symbol-name';
import { GenericPType, PType } from './base';
export * from './base';
export * from './intrinsic-enum-type';
export * from './op-ptypes';
/**
 * Transient types can appear in expressions but should not be used as variable or return types
 */
export declare abstract class TransientType extends PType {
    readonly name: string;
    readonly module: string;
    readonly singleton: boolean;
    readonly typeMessage: string;
    readonly expressionMessage: string;
    constructor({ name, module, singleton, typeMessage, expressionMessage, }: {
        name: string;
        module: string;
        singleton: boolean;
        typeMessage: string;
        expressionMessage: string;
    });
    get wtype(): wtypes.WType | undefined;
    get wtypeOrThrow(): wtypes.WType;
}
export declare class UnsupportedType extends PType {
    #private;
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = false;
    constructor({ name, module, fullName }: {
        name: string;
        module: string;
        fullName?: string;
    });
    get fullName(): string;
    get wtypeOrThrow(): wtypes.WType;
}
export declare class LogicSigPType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = true;
    readonly sourceLocation: SourceLocation;
    readonly baseType: LogicSigPType | undefined;
    constructor(props: {
        module: string;
        name: string;
        baseType?: LogicSigPType;
        sourceLocation: SourceLocation;
    });
}
export declare const logicSigBaseType: LogicSigPType;
export declare class ContractClassPType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly properties: Record<string, PType>;
    readonly methods: Record<string, FunctionPType>;
    readonly singleton = true;
    readonly baseTypes: ContractClassPType[];
    readonly sourceLocation: SourceLocation;
    constructor(props: {
        module: string;
        name: string;
        properties: Record<string, AppStorageType>;
        methods: Record<string, FunctionPType>;
        baseTypes: ContractClassPType[];
        sourceLocation: SourceLocation;
    });
    get isARC4(): boolean;
    allBases(): IterableIterator<ContractClassPType>;
}
export declare class ClusteredContractClassType extends ContractClassPType {
    constructor(props: {
        methods: Record<string, FunctionPType>;
        baseTypes: ContractClassPType[];
        sourceLocation: SourceLocation;
    });
}
export declare class BaseContractClassType extends ContractClassPType {
    readonly _isArc4: boolean;
    get isARC4(): boolean;
    constructor({ isArc4, ...rest }: {
        isArc4: boolean;
        module: string;
        name: string;
        properties: Record<string, AppStorageType>;
        methods: Record<string, FunctionPType>;
        baseTypes: ContractClassPType[];
        sourceLocation: SourceLocation;
    });
}
export declare class IntersectionPType extends TransientType {
    get fullName(): string;
    readonly singleton = false;
    readonly types: PType[];
    private constructor();
    static fromTypes(types: PType[]): PType;
}
export declare class UnionPType extends TransientType {
    get fullName(): string;
    readonly singleton = false;
    readonly types: PType[];
    private constructor();
    static fromTypes(types: PType[]): PType;
}
export declare abstract class StorageProxyPType extends PType {
    readonly wtype: wtypes.WType;
    readonly contentType: PType;
    readonly singleton = false;
    protected constructor(props: {
        content: PType;
        keyWType: wtypes.WType;
    });
}
export declare const GlobalStateGeneric: GenericPType<GlobalStateType>;
export declare class GlobalStateType extends StorageProxyPType {
    static readonly baseName = "GlobalState";
    static readonly baseFullName: string;
    readonly module: string;
    get name(): string;
    get fullName(): string;
    constructor(props: {
        content: PType;
    });
}
export declare const LocalStateGeneric: GenericPType<LocalStateType>;
export declare class LocalStateType extends StorageProxyPType {
    static readonly baseName = "LocalState";
    static readonly baseFullName: string;
    readonly module: string;
    get name(): string;
    get fullName(): string;
    constructor(props: {
        content: PType;
    });
    static parameterise(typeArgs: PType[]): LocalStateType;
}
export declare const BoxGeneric: GenericPType<BoxPType>;
export declare class BoxPType extends StorageProxyPType {
    readonly module: string;
    get name(): string;
    get fullName(): string;
    constructor(props: {
        content: PType;
    });
}
export declare const BoxMapGeneric: GenericPType<BoxMapPType>;
export declare class BoxMapPType extends StorageProxyPType {
    readonly module: string;
    get name(): string;
    get fullName(): string;
    readonly keyType: PType;
    constructor(props: {
        content: PType;
        keyType: PType;
    });
}
export declare class BoxRefPType extends StorageProxyPType {
    readonly module: "@algorandfoundation/algorand-typescript/box.d.ts";
    get name(): string;
    constructor();
}
export type AppStorageType = GlobalStateType | LocalStateType;
/**
 * An open generic type parameter
 */
export declare class TypeParameterType extends PType {
    readonly name: string;
    readonly module: string;
    readonly singleton = false;
    readonly wtype: undefined;
    constructor({ name, module }: {
        name: string;
        module: string;
    });
}
/**
 * A type from the typescript libs which might pop up in type reflection
 * but is not relevant to the output of the compiler
 */
export declare class InternalType extends PType {
    readonly name: string;
    readonly module: string;
    readonly singleton = false;
    readonly wtype: undefined;
    constructor({ name, module }: {
        name: string;
        module: string;
    });
}
export declare const ClassMethodDecoratorContext: InternalType;
export declare class AnyPType extends PType {
    get wtype(): never;
    readonly name = "any";
    readonly module = "lib.d.ts";
    readonly singleton = false;
}
export declare class InstanceType extends PType {
    readonly wtype: wtypes.WType;
    readonly name: string;
    readonly module: string;
    readonly singleton = false;
    constructor({ name, module, wtype }: {
        name: string;
        module: string;
        wtype: wtypes.WType;
    });
}
export declare class LibFunctionType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = true;
    constructor({ name, module }: {
        name: string;
        module: string;
    });
}
export declare class LibClassType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = true;
    constructor({ name, module }: {
        name: string;
        module: string;
    });
}
export declare class IntrinsicFunctionGroupType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = true;
    constructor({ name }: {
        name: string;
    });
}
export declare class IntrinsicFunctionGroupTypeType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = false;
    constructor({ name }: {
        name: string;
    });
}
export declare class IntrinsicFunctionType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = true;
    constructor({ name }: {
        name: string;
    });
}
export declare class IntrinsicFunctionTypeType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly singleton = false;
    constructor({ name }: {
        name: string;
    });
}
export declare class NamespacePType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly factory: undefined;
    readonly module: string;
    readonly singleton = true;
    constructor({ name, module }: {
        name: string;
        module: string;
    });
    get fullName(): string;
    toString(): string;
}
export declare class FunctionPType extends PType {
    readonly wtype: undefined;
    readonly name: string;
    readonly module: string;
    readonly returnType: PType;
    readonly parameters: Array<readonly [string, PType]>;
    readonly singleton = true;
    readonly sourceLocation: SourceLocation | undefined;
    constructor(props: {
        name: string;
        module: string;
        returnType: PType;
        parameters: Array<readonly [string, PType]>;
        sourceLocation: SourceLocation | undefined;
    });
}
export declare class ArrayLiteralPType extends TransientType {
    get fullName(): string;
    get elementType(): PType;
    readonly items: PType[];
    readonly immutable = true;
    constructor(props: {
        items: PType[];
    });
    getArrayType(): ArrayPType;
    getTupleType(): TuplePType;
}
export declare class TuplePType extends PType {
    readonly module: string;
    get name(): string;
    get fullName(): string;
    readonly items: PType[];
    readonly singleton = false;
    readonly immutable: boolean;
    constructor(props: {
        items: PType[];
    });
    get wtype(): wtypes.WTuple;
}
export declare class ArrayPType extends PType {
    readonly elementType: PType;
    readonly immutable = true;
    readonly singleton = false;
    readonly name: string;
    readonly module: string;
    get fullName(): string;
    constructor(props: {
        elementType: PType;
    });
    get wtype(): wtypes.StackArray;
}
export declare class ObjectPType extends PType {
    readonly name: string;
    readonly module: string;
    readonly alias: SymbolName | null;
    readonly description: string | undefined;
    readonly properties: Record<string, PType>;
    readonly singleton = false;
    constructor(props: {
        alias?: SymbolName | null;
        properties: Record<string, PType>;
        description?: string;
    });
    static anonymous(props: Record<string, PType> | Array<[string, PType]>): ObjectPType;
    get wtype(): wtypes.WTuple;
    orderedProperties(): [string, PType][];
    getPropertyType(name: string): PType;
    hasProperty(name: string): boolean;
    hasPropertyOfType(name: string, type: PType): boolean;
    toString(): string;
}
export declare const voidPType: InstanceType;
export declare const neverPType: InstanceType;
export declare const unknownPType: UnsupportedType;
export declare const nullPType: UnsupportedType;
export declare const undefinedPType: UnsupportedType;
export declare const PromiseGeneric: GenericPType<PromiseType>;
export declare class PromiseType extends UnsupportedType {
    readonly resolveType: PType;
    constructor({ resolveType }: {
        resolveType: PType;
    });
}
export declare const anyPType: AnyPType;
export declare const boolPType: InstanceType;
export declare const BooleanFunction: LibFunctionType;
export declare class NativeNumericType extends TransientType {
}
export declare const bigIntPType: NativeNumericType;
export declare const stringPType: InstanceType;
export declare const StringFunction: LibFunctionType;
export declare const uint64PType: InstanceType;
export declare const biguintPType: InstanceType;
export declare class NumericLiteralPType extends NativeNumericType {
    readonly literalValue: bigint;
    constructor({ literalValue }: {
        literalValue: bigint;
    });
}
export declare class BigIntLiteralPType extends NativeNumericType {
    readonly literalValue: bigint;
    constructor({ literalValue }: {
        literalValue: bigint;
    });
}
export declare const numberPType: NativeNumericType;
export declare const Uint64Function: LibFunctionType;
export declare const BigUintFunction: LibFunctionType;
export declare const bytesPType: InstanceType;
export declare const BytesFunction: LibFunctionType;
export declare const logFunction: LibFunctionType;
export declare const assertFunction: LibFunctionType;
export declare const errFunction: LibFunctionType;
export declare const assetPType: InstanceType;
export declare const AssetFunction: LibFunctionType;
export declare const accountPType: InstanceType;
export declare const AccountFunction: LibFunctionType;
export declare const applicationPType: InstanceType;
export declare const ApplicationFunctionType: LibFunctionType;
export declare const GlobalStateFunction: LibFunctionType;
export declare const LocalStateFunction: LibFunctionType;
export declare const BoxFunction: LibFunctionType;
export declare const BoxMapFunction: LibFunctionType;
export declare const BoxRefFunction: LibFunctionType;
export declare const boxRefType: BoxRefPType;
export declare const ClearStateProgram: FunctionPType;
export declare const ApprovalProgram: FunctionPType;
export declare const baseContractType: BaseContractClassType;
export declare const arc4BaseContractType: BaseContractClassType;
export declare const arc4BareMethodDecorator: LibFunctionType;
export declare const arc4AbiMethodDecorator: LibFunctionType;
export declare const contractOptionsDecorator: LibFunctionType;
export declare const logicSigOptionsDecorator: LibFunctionType;
export declare class GroupTransactionPType extends PType {
    get wtype(): wtypes.WGroupTransaction;
    readonly name: string;
    readonly kind: TransactionKind | undefined;
    readonly module: "@algorandfoundation/algorand-typescript/gtxn.d.ts";
    readonly singleton = false;
    constructor({ kind, name }: {
        kind?: TransactionKind;
        name: string;
    });
}
export declare class TransactionFunctionType extends LibFunctionType {
    readonly kind: TransactionKind | undefined;
    constructor({ name, module, kind }: {
        name: string;
        module: string;
        kind: TransactionKind | undefined;
    });
}
export declare const paymentGtxnType: GroupTransactionPType;
export declare const PaymentTxnFunction: TransactionFunctionType;
export declare const keyRegistrationGtxnType: GroupTransactionPType;
export declare const KeyRegistrationTxnFunction: TransactionFunctionType;
export declare const assetConfigGtxnType: GroupTransactionPType;
export declare const AssetConfigTxnFunction: TransactionFunctionType;
export declare const assetTransferGtxnType: GroupTransactionPType;
export declare const AssetTransferTxnFunction: TransactionFunctionType;
export declare const assetFreezeGtxnType: GroupTransactionPType;
export declare const AssetFreezeTxnFunction: TransactionFunctionType;
export declare const applicationCallGtxnType: GroupTransactionPType;
export declare const ApplicationTxnFunction: TransactionFunctionType;
export declare const gtxnUnion: PType;
export declare const anyGtxnType: GroupTransactionPType;
export declare const TransactionFunction: TransactionFunctionType;
export declare const assertMatchFunction: LibFunctionType;
export declare const matchFunction: LibFunctionType;
export declare class Uint64EnumMemberType extends PType {
    readonly wtype: wtypes.WType;
    readonly name: string;
    readonly module: string;
    readonly singleton = false;
    readonly enumType: Uint64EnumType;
    constructor(enumType: Uint64EnumType);
}
export declare class Uint64EnumType extends PType {
    readonly memberType: Uint64EnumMemberType;
    readonly wtype: wtypes.WType;
    readonly name: string;
    readonly module: string;
    readonly singleton = true;
    readonly members: Record<string, bigint>;
    constructor(props: {
        name: string;
        module: string;
        members: Record<string, bigint>;
    });
}
export declare const transactionTypeType: Uint64EnumType;
export declare const onCompleteActionType: Uint64EnumType;
export declare const ensureBudgetFunction: LibFunctionType;
export declare const opUpFeeSourceType: Uint64EnumType;
export declare const urangeFunction: LibFunctionType;
export declare const IterableIteratorGeneric: GenericPType<IterableIteratorType>;
export declare class IterableIteratorType extends TransientType {
    readonly itemType: PType;
    constructor({ itemType }: {
        itemType: PType;
    });
    get wtype(): wtypes.WEnumeration;
}
export declare const GeneratorGeneric: GenericPType<GeneratorType>;
export declare class GeneratorType extends UnsupportedType {
    readonly itemType: PType;
    readonly returnType: PType;
    readonly nextType: PType;
    constructor({ itemType, returnType, nextType }: {
        itemType: PType;
        returnType: PType;
        nextType: PType;
    });
}
export declare const paymentItxnFn: TransactionFunctionType;
export declare const keyRegistrationItxnFn: TransactionFunctionType;
export declare const assetConfigItxnFn: TransactionFunctionType;
export declare const assetTransferItxnFn: TransactionFunctionType;
export declare const assetFreezeItxnFn: TransactionFunctionType;
export declare const applicationCallItxnFn: TransactionFunctionType;
export declare class InnerTransactionPType extends PType {
    get wtype(): wtypes.WInnerTransaction;
    readonly name: string;
    readonly kind: TransactionKind | undefined;
    readonly module: "@algorandfoundation/algorand-typescript/itxn.d.ts";
    readonly singleton = false;
    constructor({ kind, name }: {
        kind?: TransactionKind;
        name: string;
    });
}
export declare class ItxnParamsPType extends PType {
    get wtype(): wtypes.WInnerTransactionFields;
    readonly name: string;
    readonly kind: TransactionKind | undefined;
    readonly module: "@algorandfoundation/algorand-typescript/itxn.d.ts";
    readonly singleton = false;
    constructor({ kind, name }: {
        kind?: TransactionKind;
        name: string;
    });
}
export declare const paymentItxnParamsType: ItxnParamsPType;
export declare const paymentItxnType: InnerTransactionPType;
export declare const keyRegistrationItxnParamsType: ItxnParamsPType;
export declare const keyRegistrationItxnType: InnerTransactionPType;
export declare const assetConfigItxnParamsType: ItxnParamsPType;
export declare const assetConfigItxnType: InnerTransactionPType;
export declare const assetTransferItxnParamsType: ItxnParamsPType;
export declare const assetTransferItxnType: InnerTransactionPType;
export declare const assetFreezeItxnParamsType: ItxnParamsPType;
export declare const assetFreezeItxnType: InnerTransactionPType;
export declare const applicationCallItxnParamsType: ItxnParamsPType;
export declare const applicationItxnType: InnerTransactionPType;
export declare const anyItxnType: InnerTransactionPType;
export declare const submitGroupItxnFunction: LibFunctionType;
export declare const TemplateVarFunction: LibFunctionType;
export declare const compileFunctionType: LibFunctionType;
export declare const compiledContractType: ObjectPType;
export declare const compiledLogicSigType: ObjectPType;
export declare const arc28EmitFunction: LibFunctionType;
export declare const SuperPrototypeSelectorGeneric: GenericPType<SuperPrototypeSelector>;
export declare class SuperPrototypeSelector extends InternalType {
    constructor({ bases }: {
        bases: PType[];
    });
}
export declare const ClusteredPrototype: InternalType;
export declare const PolytypeClassMethodHelper: LibFunctionType;
export declare const MutableArrayConstructor: LibClassType;
export declare const MutableArrayGeneric: GenericPType<MutableArrayType>;
export declare class MutableArrayType extends PType {
    readonly module: "@algorandfoundation/algorand-typescript/mutable-array.d.ts";
    readonly immutable: false;
    readonly name: string;
    readonly singleton = false;
    readonly sourceLocation: SourceLocation | undefined;
    readonly elementType: PType;
    constructor({ elementType, sourceLocation, name, }: {
        elementType: PType;
        sourceLocation?: SourceLocation;
        name?: string;
        immutable?: boolean;
    });
    get wtype(): wtypes.ReferenceArray;
}
