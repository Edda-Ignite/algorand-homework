#!/usr/bin/env node
import { ArgumentParser } from 'argparse';
import { c as checkNodeVersion, a as appVersion } from '../check-node-version-DQviFT_1.js';
import { Observable, debounceTime, map, concatMap } from 'rxjs';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { TextDocuments, TextDocumentSyncKind, createConnection, ProposedFeatures, createClientSocketTransport } from 'vscode-languageserver/node.js';
import { URI } from 'vscode-uri';
import { a as LoggingContext, L as LogLevel, C as Constants } from '../resolve-puya-path-zgZNWMEr.js';
import upath from 'upath';
import { DiagnosticSeverity } from 'vscode-languageserver';
import { ct as processInputPaths, cs as compile, cu as CompileOptions } from '../options-D7OvUjFs.js';
import 'fs';
import 'node:url';
import 'chalk';
import 'tslib';
import 'node:async_hooks';
import 'typescript';
import 'node:buffer';
import 'node:fs';
import 'node:util';
import 'signal-exit';
import 'crypto';
import 'path';
import 'tar';
import 'glob';
import 'os';
import 'polytype';
import 'change-case';
import 'node:path';
import 'arcsecond';
import 'cross-spawn';
import 'zod';
import 'minimatch';

function prepareFiles(workspaceFolder, documents) {
    const files = processInputPaths({ paths: [workspaceFolder] });
    // To support unsaved files, we need to replace the file content with the content of the document
    return files.map((file) => {
        const fileUri = URI.file(file.sourceFile).toString();
        const document = documents.get(fileUri);
        if (document) {
            return {
                sourceFile: file.sourceFile,
                outDir: '',
                fileContents: document.getText(),
            };
        }
        return file;
    });
}
async function compileAndExtractLogs(files) {
    const logCtx = LoggingContext.create();
    await logCtx.run(async () => {
        await compile(new CompileOptions({
            filePaths: files,
            dryRun: false,
        }));
    });
    return logCtx.logEvents
        .filter((e) => e.level === LogLevel.Error || e.level === LogLevel.Warning)
        .filter((e) => Boolean(e.sourceLocation?.file));
}
function mapToDiagnostic(event) {
    return {
        source: Constants.languageServerSource,
        severity: event.level === LogLevel.Error ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning,
        range: {
            start: {
                line: event.sourceLocation.line - 1,
                character: event.sourceLocation.column,
            },
            end: {
                line: event.sourceLocation.endLine - 1,
                character: event.sourceLocation.endColumn,
            },
        },
        message: event.message,
    };
}
async function getWorkspaceDiagnostics(connection, workspaceFolder, documents) {
    try {
        connection.console.debug(`Parsing ${workspaceFolder}`);
        const files = prepareFiles(workspaceFolder, documents);
        const logEvents = await compileAndExtractLogs(files);
        return files.reduce((acc, file) => {
            const diagnostics = logEvents.filter((e) => e.sourceLocation.file === file.sourceFile).map(mapToDiagnostic);
            acc.set(URI.file(upath.isAbsolute(file.sourceFile) ? file.sourceFile : upath.join(workspaceFolder, file.sourceFile)).toString(), diagnostics);
            return acc;
        }, new Map());
    }
    catch (error) {
        connection.console.error(`Failed to compile: ${JSON.stringify(error)}`);
        return new Map();
    }
}

const getDebugLspPort = () => {
    const port = Number(process.env.PUYA_TS_DEBUG_LSP_PORT);
    return !isNaN(port) && port > 0 ? port : undefined;
};
const resolveConnection = async () => {
    const lspPort = getDebugLspPort();
    if (!lspPort) {
        return createConnection(ProposedFeatures.all);
    }
    // When the debug env variable PUYA_TS_DEBUG_LSP_PORT is set, we start the server with socket transport.
    // Note: this is actually the oposite to how vscode-languageserver is designed.
    // Normally, the extension is the web socker server and the language server is the client.
    // Here, we flip it. This allows an easier debugging experience.
    // If changes are made to the language server, you can just restart the debugger
    // and choose the option "Restart language server" in the VS Code extension host instance.
    const transport = await createClientSocketTransport(lspPort);
    const protocol = await transport.onConnected();
    return createConnection(ProposedFeatures.all, protocol[0], protocol[1]);
};
async function startLanguageServer() {
    const connection = await resolveConnection();
    // Create a simple text document manager.
    const documents = new TextDocuments(TextDocument);
    let workspaceFolder;
    const disposables = [];
    disposables.push(connection.onInitialize((params) => {
        // The extension sets the workspaceFolder property
        // therefore, workspaceFolders is an array with one element
        workspaceFolder = params.workspaceFolders?.[0]?.uri;
        const result = {
            capabilities: {
                textDocumentSync: TextDocumentSyncKind.Incremental,
                codeActionProvider: {
                    resolveProvider: false,
                },
            },
        };
        return result;
    }));
    disposables.push(connection.onInitialized(() => {
        connection.console.log(`${Constants.languageServerSource}-ls initialized`);
    }));
    const documentChangeObservable = new Observable((subscriber) => {
        const subscription = documents.onDidChangeContent((event) => {
            subscriber.next(event);
        });
        return subscription.dispose;
    });
    const documentChangeSubscription = documentChangeObservable
        .pipe(debounceTime(200), map((_) => buildWorkspaceDiagnosticsMap(connection, workspaceFolder, documents)), concatMap(async (v) => sendDiagnostics(connection, await v)))
        .subscribe(async () => {
        // All logic for handling the document change event is done inside the pipe
        // This is to make sure that the diagnostics are sent in the right order
        // The empty subscribe function here is to make the observable run
    });
    // Make the text document manager listen on the connection
    // for open, change and close text document events
    disposables.push(documents.listen(connection));
    disposables.push(connection.onCodeAction((params) => {
        const document = documents.get(params.textDocument.uri);
        if (!document) {
            return [];
        }
        const codeActions = [];
        return codeActions;
    }));
    const shutdownDisposable = connection.onShutdown(() => {
        documentChangeSubscription.unsubscribe();
        disposables.forEach((d) => d.dispose());
    });
    connection.onExit(() => {
        shutdownDisposable.dispose();
    });
    connection.listen();
}
async function buildWorkspaceDiagnosticsMap(connection, workspaceFolder, documents) {
    if (!workspaceFolder) {
        connection.console.error('Workspace folder not set');
        return new Map();
    }
    const workspacePath = URI.parse(workspaceFolder).fsPath;
    return await getWorkspaceDiagnostics(connection, workspacePath, documents);
}
async function sendDiagnostics(connection, diagnosticsMap) {
    await Promise.all(Array.from(diagnosticsMap, ([docUri, diagnostics]) => connection.sendDiagnostics({
        uri: docUri,
        diagnostics: diagnostics,
    })));
}

async function parseCliArguments() {
    checkNodeVersion();
    const prog = 'puyats-ls';
    const parser = new ArgumentParser({
        prog,
    });
    parser.add_argument('--version', {
        action: 'store_const',
        help: 'Show application version',
        const: 'version',
        dest: 'command',
    });
    const [result, _] = parser.parse_known_args();
    switch (result.command) {
        case 'version':
            /* eslint-disable-next-line no-console */
            console.log(appVersion(prog));
            break;
        default:
            await startLanguageServer();
            break;
    }
}

void parseCliArguments();
//# sourceMappingURL=puyats-ls.mjs.map
