import { BooleanOptionalAction, ArgumentParser } from 'argparse';
import { c as checkNodeVersion, a as appVersion } from './check-node-version-DQviFT_1.js';
import { cv as defaultPuyaOptions, ct as processInputPaths, cs as compile, cu as CompileOptions, cw as parseCliTemplateVar, cx as LocalsCoalescingStrategy } from './options-D7OvUjFs.js';
import { m as enumFromValue, a as LoggingContext, l as logger, L as LogLevel } from './resolve-puya-path-zgZNWMEr.js';
import { C as ConsoleLogSink } from './console-log-sink-BUoObqbL.js';
import 'fs';
import 'node:url';
import 'upath';
import 'chalk';
import 'polytype';
import 'change-case';
import 'node:path';
import 'tslib';
import 'node:buffer';
import 'node:fs';
import 'typescript';
import 'node:async_hooks';
import 'arcsecond';
import 'node:util';
import 'cross-spawn';
import 'zod';
import 'glob';
import 'minimatch';
import 'signal-exit';
import 'crypto';
import 'path';
import 'tar';
import 'os';

function addEnumArg(parser, { name, enumType, default: defaultValue, help }) {
    parser.add_argument(name, {
        type: (v) => enumFromValue(v, enumType),
        choices: Array.from(Object.values(enumType)),
        default: defaultValue,
        help,
    });
}
function convertInt(val) {
    const res = Number(val);
    if (isNaN(res) || Math.round(res) !== res) {
        throw new Error(`'${val}' could not be converted to a number`);
    }
    return res;
}

function addBuildCommand(parser) {
    addEnumArg(parser, {
        name: '--log-level',
        default: LogLevel.Info,
        enumType: LogLevel,
        help: 'The minimum log level to output',
    });
    parser.add_argument('--output-awst', {
        help: 'Output debugging awst file per parsed file',
        default: false,
        action: BooleanOptionalAction,
    });
    parser.add_argument('--output-awst-json', {
        action: BooleanOptionalAction,
        default: false,
        help: 'Output debugging awst json file per parsed file',
    });
    parser.add_argument('--dry-run', {
        action: BooleanOptionalAction,
        default: false,
        help: "Just parse typescript files, don't invoke puya compiler",
    });
    parser.add_argument('--skip-version-check', {
        action: BooleanOptionalAction,
        default: false,
        help: "Don't verify installed puya compiler version matches targeted version",
    });
    parser.add_argument('--output-teal', {
        action: BooleanOptionalAction,
        help: 'Output TEAL code',
        default: defaultPuyaOptions.outputTeal,
    });
    parser.add_argument('--output-source-map', {
        action: BooleanOptionalAction,
        help: 'Output debug source maps ',
        default: defaultPuyaOptions.outputSourceMap,
    });
    parser.add_argument('--output-arc32', {
        action: BooleanOptionalAction,
        help: 'Output {contract}.arc32.json ARC-32 app spec file. Only applicable to ARC4 contracts ',
        default: defaultPuyaOptions.outputArc32,
    });
    parser.add_argument('--output-arc56', {
        action: BooleanOptionalAction,
        help: 'Output {contract}.arc56.json ARC-56 app spec file. Only applicable to ARC4 contracts ',
        default: defaultPuyaOptions.outputArc56,
    });
    parser.add_argument('--output-ssa-ir', {
        action: BooleanOptionalAction,
        help: 'Output IR (in SSA form) before optimisations',
        default: defaultPuyaOptions.outputSsaIr,
    });
    parser.add_argument('--output-optimization-ir', {
        action: BooleanOptionalAction,
        help: 'Output IR after each optimization',
        default: defaultPuyaOptions.outputOptimizationIr,
    });
    parser.add_argument('--output-destructured-ir', {
        action: BooleanOptionalAction,
        help: 'Output IR after SSA destructuring and before MIR',
        default: defaultPuyaOptions.outputDestructuredIr,
    });
    parser.add_argument('--output-memory-ir', {
        action: BooleanOptionalAction,
        help: 'Output MIR before lowering to TealOps',
        default: defaultPuyaOptions.outputMemoryIr,
    });
    parser.add_argument('--output-bytecode', {
        action: BooleanOptionalAction,
        help: 'Output AVM bytecode',
        default: defaultPuyaOptions.outputBytecode,
    });
    parser.add_argument('--out-dir', {
        action: 'store',
        help: 'Where to output builder artifacts. Can use [name] placeholder to include contract name in path',
        default: 'out',
    });
    parser.add_argument('--debug-level', {
        default: defaultPuyaOptions.debugLevel.toString(),
        choices: ['0', '1', '2'],
        help: 'Output debug information level, 0 = none, 1 = debug, 2 = reserved for future use',
    });
    parser.add_argument('--optimization-level', {
        default: defaultPuyaOptions.optimizationLevel.toString(),
        choices: ['0', '1', '2'],
        help: 'Set optimization level of output TEAL / AVM bytecode, 0 = none, 1 = normal, 2 = intensive',
    });
    parser.add_argument('--target-avm-version', {
        default: defaultPuyaOptions.targetAvmVersion.toString(),
        choices: ['10', '11'],
        help: 'Select the targeted AVM version for compilation output',
    });
    parser.add_argument('--cli-template-definitions', {
        metavar: 'VAR=VALUE',
        nargs: '+',
        help: 'Define template vars for use when assembling via --output-bytecode, should be specified without the prefix (see --template-vars-prefix)',
    });
    parser.add_argument('--template-vars-prefix', {
        help: 'Define the prefix to use with --template-var',
        default: defaultPuyaOptions.templateVarsPrefix,
    });
    addEnumArg(parser, {
        name: '--locals-coalescing-strategy',
        enumType: LocalsCoalescingStrategy,
        help: 'Strategy choice for out-of-ssa local variable coalescing. The best choice for your app is best determined through experimentation',
        default: defaultPuyaOptions.localsCoalescingStrategy,
    });
    parser.add_argument('paths', {
        metavar: 'PATHS',
        nargs: '*',
        help: 'The path, or paths to search for compatible .algo.ts files',
        default: ['.'],
    });
    parser.add_argument('--puya-path', {
        help: 'The path to Puya. If not provided, puya-ts will automatically download the appropriate binary for your system',
    });
}
async function buildCommand(args) {
    const logCtx = LoggingContext.create();
    return logCtx.run(async () => {
        logger.configure([new ConsoleLogSink(args.log_level)]);
        try {
            const filePaths = processInputPaths({ paths: args.paths, outDir: args.out_dir });
            await compile(new CompileOptions({
                filePaths,
                outputAwst: args.output_awst,
                outputAwstJson: args.output_awst_json,
                skipVersionCheck: args.skip_version_check,
                dryRun: args.dry_run,
                logLevel: args.log_level,
                outputTeal: args.output_teal,
                outputArc32: args.output_arc32,
                outputArc56: args.output_arc56,
                outputSsaIr: args.output_ssa_ir,
                outputOptimizationIr: args.output_optimization_ir,
                outputDestructuredIr: args.output_destructured_ir,
                outputMemoryIr: args.output_memory_ir,
                outputBytecode: args.output_bytecode,
                outputSourceMap: args.output_source_map,
                debugLevel: convertInt(args.debug_level),
                optimizationLevel: convertInt(args.optimization_level),
                targetAvmVersion: convertInt(args.target_avm_version),
                cliTemplateDefinitions: Object.fromEntries(args.cli_template_definitions?.map(parseCliTemplateVar) ?? []),
                templateVarsPrefix: args.template_vars_prefix,
                localsCoalescingStrategy: args.locals_coalescing_strategy,
                customPuyaPath: args.puya_path,
            }));
            logCtx.exitIfErrors();
        }
        catch (e) {
            if (e instanceof Error) {
                logger.error(e);
            }
            else {
                throw e;
            }
        }
    });
}

async function parseCliArguments() {
    checkNodeVersion();
    const parser = new ArgumentParser({
        prog: 'puya-ts',
    });
    parser.add_argument('--version', {
        action: 'store_const',
        help: 'Show application version',
        const: 'version',
        dest: 'command',
    });
    parser.set_defaults({
        command: 'build',
    });
    addBuildCommand(parser);
    const result = parser.parse_args();
    switch (result.command) {
        case 'build':
            await buildCommand(result);
            break;
        case 'version':
            /* eslint-disable-next-line no-console */
            console.log(appVersion());
            break;
        default:
            parser.print_help();
            break;
    }
}

void parseCliArguments();
//# sourceMappingURL=cli.mjs.map
