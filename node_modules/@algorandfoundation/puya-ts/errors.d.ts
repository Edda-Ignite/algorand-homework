import type { SourceLocation } from './awst/source-location';
import type { PType, PTypeOrClass } from './awst_build/ptypes';
type PuyaErrorOptions = {
    cause?: Error;
    sourceLocation?: SourceLocation;
};
export declare class PuyaError extends Error {
    readonly sourceLocation: SourceLocation | undefined;
    constructor(message?: string, options?: PuyaErrorOptions);
}
/**
 * Any error that is 'caused' by a user of Puya
 */
export declare abstract class UserError extends PuyaError {
}
/**
 * Thrown when the user's code is invalid, or not supported
 */
export declare class CodeError extends UserError {
    static unexpectedUnhandledArgs({ sourceLocation }: {
        sourceLocation: SourceLocation;
    }): CodeError;
    static unexpectedTypeArgs({ sourceLocation }: {
        sourceLocation: SourceLocation;
    }): CodeError;
    static expectedCompileTimeConstant({ sourceLocation }: {
        sourceLocation: SourceLocation;
    }): CodeError;
    static invalidAssignmentTarget({ sourceLocation, name }: {
        sourceLocation: SourceLocation;
        name: string;
    }): CodeError;
    static cannotResolveToType({ sourceType, targetType, sourceLocation, }: {
        sourceLocation: SourceLocation;
        sourceType: PType;
        targetType: PTypeOrClass;
    }): CodeError;
}
/**
 * Thrown when the compiler ends up in an unrecoverable state
 */
export declare class InternalError extends PuyaError {
    static shouldBeUnreachable(): InternalError;
}
export declare class NotSupported extends CodeError {
    constructor(featureName: string, options?: PuyaErrorOptions);
}
/**
 * Thrown when the user's environment is not set up correctly
 */
export declare class EnvironmentError extends UserError {
}
export declare const throwError: (error: Error) => never;
export declare const wrapInCodeError: <T>(func: () => T, sourceLocation: SourceLocation) => T;
export {};
