import { SourceLocation } from '../awst/source-location';
import type { LogSink } from './sinks';
type NodeOrSourceLocation = SourceLocation | {
    sourceLocation: SourceLocation;
};
export declare enum LogLevel {
    Error = "error",
    Info = "info",
    Warning = "warning",
    Debug = "debug",
    Critical = "critical"
}
export declare const isMinLevel: (logLevel: LogLevel, minLevel: LogLevel) => boolean;
export declare const isErrorOrCritical: (l: LogLevel) => boolean;
export type LogEvent = {
    level: LogLevel;
    message: string;
    sourceLocation: SourceLocation | undefined;
};
declare class PuyaLogger {
    private logSinks;
    configure(sinks: LogSink[]): void;
    addLog(level: LogEvent['level'], source: NodeOrSourceLocation | undefined, message: string): void;
    error(error: Error): void;
    error(source: NodeOrSourceLocation | undefined, message: string): void;
    info(source: NodeOrSourceLocation | undefined, message: string): void;
    debug(source: NodeOrSourceLocation | undefined, message: string): void;
    warn(source: NodeOrSourceLocation | undefined, message: string): void;
    critical(source: NodeOrSourceLocation | undefined, message: string): void;
}
export declare const logger: PuyaLogger;
export declare const patchErrorLocation: <TArgs extends unknown[], TReturn>(action: (...args: TArgs) => TReturn, sourceLocation: SourceLocation) => (...args: TArgs) => TReturn;
export declare class LoggingContext {
    logEvents: LogEvent[];
    sourcesByPath: Record<string, string[]>;
    private constructor();
    hasErrors(): boolean;
    exitIfErrors(): void;
    enterContext(): this;
    run<R>(cb: () => R): R;
    private static fallbackContext;
    private static asyncStore;
    static create(): LoggingContext;
    static get current(): LoggingContext;
}
export {};
