import { n as invariant, o as CodeError, z as zipStrict, C as Constants, S as SourceLocation, q as codeInvariant, N as NotSupported, I as InternalError, s as distinctByEquality, t as sortBy, v as instanceOfAny, w as throwError, l as logger, j as bigIntToUint8Array, x as tryConvertEnum, k as utf8ToUint8Array, e as uint8ArrayToUtf8, f as base64ToUint8Array, g as base32ToUint8Array, h as hexToUint8Array, y as enumKeyFromValue, A as wrapInCodeError, B as hasFlags, D as isIn, E as intersectsFlags, F as normalisePath, G as toSubScript, m as enumFromValue, H as enumerate, c as uint8ArrayToBase32, J as mkDirIfNotExists, K as patchErrorLocation, M as sameSets, O as expandMaybeArray, a as LoggingContext, L as LogLevel, r as resolvePuyaPath, P as generateTempFile, Q as PuyaError } from './resolve-puya-path-zgZNWMEr.js';
import { classes } from 'polytype';
import { snakeCase } from 'change-case';
import path from 'node:path';
import { __addDisposableResource, __disposeResources } from 'tslib';
import { Buffer } from 'node:buffer';
import * as fs from 'node:fs';
import fs__default from 'node:fs';
import upath from 'upath';
import ts, { SymbolFlags, ObjectFlags } from 'typescript';
import { AsyncLocalStorage } from 'node:async_hooks';
import * as A from 'arcsecond';
import 'node:util';
import { spawn } from 'cross-spawn';
import { z } from 'zod';
import { globSync } from 'glob';
import { minimatch } from 'minimatch';

var OnCompletionAction;
(function (OnCompletionAction) {
    OnCompletionAction[OnCompletionAction["NoOp"] = 0] = "NoOp";
    OnCompletionAction[OnCompletionAction["OptIn"] = 1] = "OptIn";
    OnCompletionAction[OnCompletionAction["CloseOut"] = 2] = "CloseOut";
    OnCompletionAction[OnCompletionAction["ClearState"] = 3] = "ClearState";
    OnCompletionAction[OnCompletionAction["UpdateApplication"] = 4] = "UpdateApplication";
    OnCompletionAction[OnCompletionAction["DeleteApplication"] = 5] = "DeleteApplication";
})(OnCompletionAction || (OnCompletionAction = {}));
class ModelBase {
    /**
     * This field prevents us from accidentally passing an object literal with structural equality to
     * a model class instead of any instance of the class, which would stuff up the serialization
     * @private
     */
    #isModel = true;
}
class ContractReference extends ModelBase {
    constructor({ className, moduleName }) {
        super();
        this.className = className;
        this.moduleName = moduleName;
    }
    className;
    moduleName;
    get id() {
        return `${this.moduleName}::${this.className}`;
    }
    toString() {
        return this.id;
    }
    static fromPType(contractPType) {
        return new ContractReference({
            className: contractPType.name,
            moduleName: contractPType.module,
        });
    }
}
class LogicSigReference extends ModelBase {
    constructor({ name, moduleName }) {
        super();
        this.name = name;
        this.moduleName = moduleName;
    }
    name;
    moduleName;
    get id() {
        return `${this.moduleName}::${this.name}`;
    }
    toString() {
        return this.id;
    }
    static fromPType(logicSigPType) {
        return new LogicSigReference({
            name: logicSigPType.name,
            moduleName: logicSigPType.module,
        });
    }
}
var TransactionKind;
(function (TransactionKind) {
    TransactionKind[TransactionKind["pay"] = 1] = "pay";
    TransactionKind[TransactionKind["keyreg"] = 2] = "keyreg";
    TransactionKind[TransactionKind["acfg"] = 3] = "acfg";
    TransactionKind[TransactionKind["axfer"] = 4] = "axfer";
    TransactionKind[TransactionKind["afrz"] = 5] = "afrz";
    TransactionKind[TransactionKind["appl"] = 6] = "appl";
})(TransactionKind || (TransactionKind = {}));

var AVMType;
(function (AVMType) {
    AVMType[AVMType["bytes"] = 1] = "bytes";
    AVMType[AVMType["uint64"] = 2] = "uint64";
    AVMType[AVMType["any"] = 3] = "any";
})(AVMType || (AVMType = {}));
// eslint-disable-next-line @typescript-eslint/no-namespace
var wtypes;
(function (wtypes) {
    class WType {
        constructor(props) {
            this.name = props.name;
            this.immutable = props.immutable ?? true;
            this.scalarType = props.scalarType;
            this.ephemeral = props.ephemeral ?? false;
        }
        name;
        immutable;
        /**
         * ephemeral types are not suitable for naive storage / persistence,
         *      even if their underlying type is a simple stack value
         */
        ephemeral;
        /**
         * The AVM stack type of this type (if any)
         */
        scalarType;
        equals(other) {
            return other instanceof this.constructor && other.name === this.name;
        }
        toString() {
            return this.name;
        }
        get id() {
            return this.name;
        }
    }
    wtypes.WType = WType;
    wtypes.voidWType = new WType({
        name: 'void',
        scalarType: null,
    });
    wtypes.boolWType = new WType({
        name: 'bool',
        scalarType: AVMType.uint64,
    });
    wtypes.uint64WType = new WType({
        name: 'uint64',
        scalarType: AVMType.uint64,
    });
    wtypes.uint64RangeWType = new WType({
        name: 'uint64_range',
        scalarType: null,
        immutable: true,
    });
    wtypes.bytesWType = new WType({
        name: 'bytes',
        scalarType: AVMType.bytes,
    });
    wtypes.stateKeyWType = new WType({
        name: 'state_key',
        scalarType: AVMType.bytes,
    });
    wtypes.boxKeyWType = new WType({
        name: 'box_key',
        scalarType: AVMType.bytes,
    });
    wtypes.stringWType = new WType({
        name: 'string',
        scalarType: AVMType.bytes,
    });
    wtypes.biguintWType = new WType({
        name: 'biguint',
        scalarType: AVMType.bytes,
    });
    wtypes.assetWType = new WType({
        name: 'asset',
        scalarType: AVMType.uint64,
    });
    wtypes.accountWType = new WType({
        name: 'account',
        scalarType: AVMType.bytes,
    });
    wtypes.applicationWType = new WType({
        name: 'application',
        scalarType: AVMType.uint64,
    });
    class ARC4Type extends WType {
        nativeType;
        arc4Name;
        constructor({ nativeType, arc4Name, ...rest }) {
            super({ ...rest, scalarType: rest.scalarType ?? AVMType.bytes });
            this.arc4Name = arc4Name;
            this.nativeType = nativeType;
        }
    }
    wtypes.ARC4Type = ARC4Type;
    class WStructType extends WType {
        fields;
        frozen = true;
        constructor({ fields, name }) {
            super({
                name,
                scalarType: null,
                immutable: true,
            });
            this.fields = fields;
        }
    }
    wtypes.WStructType = WStructType;
    class WTuple extends WType {
        types;
        names;
        constructor(props) {
            super({
                name: props.name ?? 'tuple',
                scalarType: null,
                immutable: props.immutable ?? true,
            });
            invariant(props.types.length, 'Tuple length cannot be zero');
            this.types = props.types;
            if (props.names) {
                invariant(props.names.length === props.types.length, 'If names is provided, length must match types');
                this.names = props.names;
            }
        }
        equals(other) {
            if (other instanceof WTuple) {
                return (this.name === other.name &&
                    this.types.every((t, i) => t.equals(other.types[i])) &&
                    (this.names?.every((n, i) => n === other.names?.[i]) ?? this.names === other.names));
            }
            return false;
        }
        toString() {
            const displayName = this.name.split('::').at(-1) ?? this.name;
            if (this.names) {
                return `${displayName}{ ${this.names.map((n, i) => `${n}: ${this.types[i]}`).join(', ')} }`;
            }
            return `${this.immutable ? 'readonly' : ''}${displayName}[${this.types.join(', ')}]`;
        }
    }
    wtypes.WTuple = WTuple;
    class NativeArray extends WType {
        elementType;
        sourceLocation;
        constructor(props) {
            super({
                name: props.name,
                scalarType: props.scalarType ?? null,
            });
            this.elementType = props.itemType;
            this.sourceLocation = props.sourceLocation ?? null;
        }
    }
    wtypes.NativeArray = NativeArray;
    class StackArray extends NativeArray {
        immutable = true;
        constructor(props) {
            super({
                name: `stack_array<${props.itemType.name}>`,
                scalarType: AVMType.bytes,
                ...props,
            });
        }
    }
    wtypes.StackArray = StackArray;
    class ReferenceArray extends NativeArray {
        immutable = false;
        constructor(props) {
            super({
                name: `ref_array<${props.itemType.name}>`,
                ...props,
            });
        }
    }
    wtypes.ReferenceArray = ReferenceArray;
    class WEnumeration extends WType {
        sequenceType;
        constructor(props) {
            super({
                name: `enumeration<${props.sequenceType.name}>`,
                scalarType: null,
                immutable: true,
            });
            this.sequenceType = props.sequenceType;
        }
    }
    wtypes.WEnumeration = WEnumeration;
    class WGroupTransaction extends WType {
        transactionType;
        arc4Name;
        constructor({ transactionType }) {
            super({
                scalarType: AVMType.uint64,
                name: transactionType === undefined ? 'group_transaction' : `group_transaction_${TransactionKind[transactionType]}`,
            });
            this.transactionType = transactionType ?? null;
            this.arc4Name = transactionType ? TransactionKind[transactionType] : 'txn';
        }
    }
    wtypes.WGroupTransaction = WGroupTransaction;
    class WInnerTransaction extends WType {
        transactionType;
        constructor({ transactionType }) {
            super({
                scalarType: null,
                name: transactionType === undefined ? 'inner_transaction' : `inner_transaction_${TransactionKind[transactionType]}`,
            });
            this.transactionType = transactionType ?? null;
        }
    }
    wtypes.WInnerTransaction = WInnerTransaction;
    class WInnerTransactionFields extends WType {
        transactionType;
        constructor({ transactionType }) {
            super({
                scalarType: null,
                name: transactionType === undefined ? 'inner_transaction_fields' : `inner_transaction_fields_${TransactionKind[transactionType]}`,
            });
            this.transactionType = transactionType ?? null;
        }
    }
    wtypes.WInnerTransactionFields = WInnerTransactionFields;
    class ARC4UIntN extends ARC4Type {
        n;
        constructor({ n, arc4Name }) {
            super({
                name: arc4Name ? `arc4.${arc4Name}` : `arc4.uint${n}`,
                scalarType: AVMType.bytes,
                nativeType: n <= 64 ? wtypes.uint64WType : wtypes.biguintWType,
                arc4Name: arc4Name ?? `uint${n}`,
            });
            invariant(n >= 8n && n <= 512n, 'Invalid uint: n must be between 8 and 512');
            invariant(n % 8n === 0n, 'Invalid uint: n must be multiple of 8');
            this.n = n;
        }
    }
    wtypes.ARC4UIntN = ARC4UIntN;
    class ARC4UFixedNxM extends ARC4Type {
        n;
        m;
        constructor({ n, m }) {
            super({
                name: `arc4.ufixed${n}x${m}`,
                scalarType: AVMType.bytes,
                nativeType: n <= 64 ? wtypes.uint64WType : wtypes.biguintWType,
                arc4Name: `ufixed${n}x${m}`,
            });
            invariant(n >= 8n && n <= 512n, 'Invalid ufixed: n must be between 8 and 512');
            invariant(n % 8n === 0n, 'Invalid ufixed: n must be multiple of 8');
            invariant(m >= 0n && m <= 160n, 'Invalid ufixed: m must be between 0 and 160');
            this.n = n;
            this.m = m;
        }
    }
    wtypes.ARC4UFixedNxM = ARC4UFixedNxM;
    class ARC4Struct extends ARC4Type {
        fields;
        sourceLocation;
        frozen;
        desc;
        constructor({ fields, sourceLocation, name, desc, frozen, }) {
            super({
                arc4Name: `(${Object.values(fields)
                    .map((f) => f.arc4Name)
                    .join(',')})`,
                name,
                nativeType: null,
                immutable: frozen && Object.values(fields).every((t) => t.immutable),
            });
            this.sourceLocation = sourceLocation ?? null;
            this.fields = fields;
            this.frozen = frozen;
            this.desc = desc;
        }
        toString() {
            if (!this.name)
                return this.arc4Name;
            return super.toString();
        }
    }
    wtypes.ARC4Struct = ARC4Struct;
    class ARC4Tuple extends ARC4Type {
        types;
        sourceLocation;
        constructor({ types, sourceLocation }) {
            const typesStr = types.map((t) => t.arc4Name).join(',');
            super({
                name: `arc4.tuple<${typesStr}>`,
                arc4Name: `(${typesStr})`,
                nativeType: null,
            });
            this.sourceLocation = sourceLocation ?? null;
            this.types = types;
        }
    }
    wtypes.ARC4Tuple = ARC4Tuple;
    class ARC4Array extends ARC4Type {
        elementType;
        constructor(props) {
            super({ ...props, scalarType: AVMType.bytes, immutable: props.immutable ?? false, nativeType: props.nativeType ?? null });
            this.elementType = props.elementType;
        }
    }
    wtypes.ARC4Array = ARC4Array;
    class ARC4DynamicArray extends ARC4Array {
        sourceLocation;
        constructor({ elementType, sourceLocation, arc4Name, nativeType, immutable, }) {
            super({
                elementType,
                name: `arc4.dynamic_array<${elementType.name}>`,
                arc4Name: arc4Name ?? `${elementType.arc4Name}[]`,
                otherEncodeableTypes: [],
                nativeType,
                immutable,
            });
            this.sourceLocation = sourceLocation ?? null;
        }
    }
    wtypes.ARC4DynamicArray = ARC4DynamicArray;
    class ARC4StaticArray extends ARC4Array {
        sourceLocation;
        arraySize;
        constructor({ elementType, sourceLocation, arraySize, arc4Name, nativeType, immutable, }) {
            super({
                elementType,
                name: `arc4.static_array<${elementType.name}>`,
                arc4Name: arc4Name ?? `${elementType.arc4Name}[${arraySize}]`,
                nativeType: nativeType,
                otherEncodeableTypes: [],
                immutable,
            });
            this.sourceLocation = sourceLocation ?? null;
            this.arraySize = arraySize;
        }
    }
    wtypes.ARC4StaticArray = ARC4StaticArray;
    wtypes.arc4ByteAliasWType = new ARC4UIntN({
        n: 8n,
        arc4Name: 'byte',
    });
    wtypes.arc4AddressAliasWType = new ARC4StaticArray({
        arraySize: 32n,
        immutable: true,
        elementType: wtypes.arc4ByteAliasWType,
        nativeType: wtypes.accountWType,
        arc4Name: 'address',
    });
    wtypes.arc4BooleanWType = new ARC4Type({
        name: 'arc4.bool',
        arc4Name: 'bool',
        immutable: true,
        nativeType: wtypes.boolWType,
    });
    wtypes.arc4StringAliasWType = new ARC4DynamicArray({
        arc4Name: 'string',
        elementType: wtypes.arc4ByteAliasWType,
        nativeType: wtypes.stringWType,
        immutable: true,
    });
})(wtypes || (wtypes = {}));

class SymbolName {
    module;
    name;
    constructor(props) {
        this.module = props.module;
        this.name = props.name;
    }
    get fullName() {
        return `${this.module}::${this.name}`;
    }
    toString() {
        return this.fullName;
    }
}

/**
 * Represents a public type visible to a developer of AlgoTS
 */
class PType {
    get fullName() {
        return `${this.module}::${this.name}`;
    }
    get wtypeOrThrow() {
        if (!this.wtype) {
            throw new CodeError(`${this.fullName} does not have a wtype`);
        }
        return this.wtype;
    }
    equals(other) {
        return ptypesAreEqual(this, other);
    }
    equalsOneOf(...others) {
        return others.some((o) => ptypesAreEqual(this, o));
    }
    static equals(other) {
        return other instanceof this;
    }
    equalsOrInstanceOf(other) {
        if (other instanceof Function) {
            return this instanceof other;
        }
        return this.equals(other);
    }
    toString() {
        return this.name;
    }
}
class GenericPType extends PType {
    name;
    module;
    singleton = false;
    wtype = undefined;
    parameterise;
    constructor(props) {
        super();
        this.name = props.name;
        this.module = props.module;
        this.parameterise = props.parameterise;
    }
}
function ptypesAreEqual(left, right) {
    if (!(right instanceof left.constructor)) {
        return false;
    }
    return compareProperties(left, right);
}
const ignoredProperties = new Set(['sourceLocation', 'wtype']);
function notIgnored(key) {
    return !ignoredProperties.has(key);
}
function compareProperties(left, right) {
    const leftProps = Object.entries(left).filter(([key]) => notIgnored(key));
    const rightProps = Object.entries(right).filter(([key]) => notIgnored(key));
    if (leftProps.length !== rightProps.length)
        return false;
    return zipStrict(leftProps, rightProps).every(([[lKey, lValue], [rKey, rValue]]) => {
        if (lKey !== rKey)
            return false;
        return compareValues(lValue, rValue);
    });
}
function compareValues(left, right) {
    // Handle primitive comparison
    if (typeof left !== 'object' || left === right) {
        return left === right;
    }
    if (left === null) {
        return right === null;
    }
    // Recursively compare array items
    if (Array.isArray(left)) {
        return Array.isArray(right) && left.length === right.length && left.every((v, i) => compareValues(v, right[i]));
    }
    // Recursively compare ptypes
    if (left instanceof PType) {
        return right instanceof PType && ptypesAreEqual(left, right);
    }
    if (left instanceof wtypes.WType) {
        return right instanceof wtypes.WType && left.equals(right);
    }
    return typeof right === 'object' && right !== null && compareProperties(left, right);
}

const transientTypeErrors = {
    arrays: (typeName) => ({
        usedAsType: `\`${typeName}\` is not valid as a variable, parameter, return, or property type. Please define a static tuple type or use an \`as const\` expression`,
        usedInExpression: `Expression of type \`${typeName}\` cannot be used conditionally`,
    }),
    nativeNumeric: (typeName) => ({
        usedAsType: `\`${typeName}\` is not valid as a variable, parameter, return, or property type. Please use an algo-ts type such as \`biguint\` or \`uint64\``,
        usedInExpression: `Expression of type \`${typeName}\` must be explicitly converted to an algo-ts type, for example by wrapping the expression in \`Uint64(...)\` or \`BigUint(...)\``,
    }),
    unionTypes: (typeName) => ({
        usedAsType: `Union types are not valid as a variable, parameter, return, or property type. Expression type is ${typeName}`,
        usedInExpression: `Union types are only valid in boolean expressions. Expression type is ${typeName}`,
    }),
    intersectionTypes: (typeName) => ({
        usedAsType: `Intersection types are not valid as a variable, parameter, return, or property type. Expression type is ${typeName}`,
        usedInExpression: `Intersection types not valid here. Expression type is ${typeName}`,
    }),
};

class IntrinsicEnumType extends PType {
    wtype;
    name;
    factory;
    module;
    members;
    singleton = true;
    constructor({ name, module, members }) {
        super();
        this.members = members;
        this.name = name;
        this.module = module;
    }
}

/* THIS FILE IS GENERATED BY ~/scripts/generate-op-ptypes.ts - DO NOT MODIFY DIRECTLY */
const base64PType = new IntrinsicEnumType({
    name: 'Base64',
    module: `${Constants.algoTsPackage}/op.d.ts`,
    members: [
        ['URLEncoding', 'URLEncoding'],
        ['StdEncoding', 'StdEncoding'],
    ],
});
const ecPType = new IntrinsicEnumType({
    name: 'Ec',
    module: `${Constants.algoTsPackage}/op.d.ts`,
    members: [
        ['BN254g1', 'BN254g1'],
        ['BN254g2', 'BN254g2'],
        ['BLS12_381g1', 'BLS12_381g1'],
        ['BLS12_381g2', 'BLS12_381g2'],
    ],
});
const ecdsaPType = new IntrinsicEnumType({
    name: 'Ecdsa',
    module: `${Constants.algoTsPackage}/op.d.ts`,
    members: [
        ['Secp256k1', 'Secp256k1'],
        ['Secp256r1', 'Secp256r1'],
    ],
});
const mimcConfigurationsPType = new IntrinsicEnumType({
    name: 'MimcConfigurations',
    module: `${Constants.algoTsPackage}/op.d.ts`,
    members: [
        ['BN254Mp110', 'BN254Mp110'],
        ['BLS12_381Mp111', 'BLS12_381Mp111'],
    ],
});
const vrfVerifyPType = new IntrinsicEnumType({
    name: 'VrfVerify',
    module: `${Constants.algoTsPackage}/op.d.ts`,
    members: [['VrfAlgorand', 'VrfAlgorand']],
});
const ALL_OP_ENUMS = [base64PType, ecPType, ecdsaPType, mimcConfigurationsPType, vrfVerifyPType];

/**
 * Transient types can appear in expressions but should not be used as variable or return types
 */
class TransientType extends PType {
    name;
    module;
    singleton;
    typeMessage;
    expressionMessage;
    constructor({ name, module, singleton, typeMessage, expressionMessage, }) {
        super();
        this.name = name;
        this.module = module;
        this.singleton = singleton;
        this.typeMessage = typeMessage;
        this.expressionMessage = expressionMessage;
    }
    get wtype() {
        return undefined;
    }
    get wtypeOrThrow() {
        throw new CodeError(this.typeMessage);
    }
}
class UnsupportedType extends PType {
    wtype = undefined;
    name;
    module;
    singleton = false;
    #fullName;
    constructor({ name, module, fullName }) {
        super();
        this.name = name;
        this.module = module;
        this.#fullName = fullName;
    }
    get fullName() {
        return this.#fullName ?? super.fullName;
    }
    get wtypeOrThrow() {
        throw new NotSupported(`The type ${this.fullName} is not supported`);
    }
}
class LogicSigPType extends PType {
    wtype = undefined;
    name;
    module;
    singleton = true;
    sourceLocation;
    baseType;
    constructor(props) {
        super();
        this.name = props.name;
        this.module = props.module;
        this.baseType = props.baseType;
        this.sourceLocation = props.sourceLocation;
    }
}
const logicSigBaseType = new LogicSigPType({
    name: 'LogicSig',
    module: Constants.moduleNames.algoTs.logicSig,
    sourceLocation: SourceLocation.None,
});
class ContractClassPType extends PType {
    wtype = undefined;
    name;
    module;
    properties;
    methods;
    singleton = true;
    baseTypes;
    sourceLocation;
    constructor(props) {
        super();
        this.name = props.name;
        this.module = props.module;
        this.properties = props.properties;
        this.methods = props.methods;
        this.baseTypes = props.baseTypes;
        this.sourceLocation = props.sourceLocation;
    }
    get isARC4() {
        return this.baseTypes.some((b) => b.isARC4);
    }
    *allBases() {
        for (const b of this.baseTypes) {
            yield b;
            yield* b.allBases();
        }
    }
}
class ClusteredContractClassType extends ContractClassPType {
    constructor(props) {
        super({
            ...props,
            name: `ClusteredContract<${props.baseTypes.map((t) => t.fullName).join(',')}>`,
            module: Constants.moduleNames.polytype,
            methods: Object.assign({}, ...props.baseTypes.toReversed().map((t) => t.methods)),
            properties: Object.assign({}, ...props.baseTypes.toReversed().map((t) => t.properties)),
        });
    }
}
class BaseContractClassType extends ContractClassPType {
    _isArc4;
    get isARC4() {
        return this._isArc4;
    }
    constructor({ isArc4, ...rest }) {
        super(rest);
        this._isArc4 = isArc4;
    }
}
class IntersectionPType extends TransientType {
    get fullName() {
        return this.types.map((t) => t).join(' & ');
    }
    singleton = false;
    types;
    constructor({ types }) {
        const name = types.map((t) => t).join(' & ');
        super({
            name,
            module: 'lib.d.ts',
            singleton: false,
            typeMessage: transientTypeErrors.intersectionTypes(name).usedAsType,
            expressionMessage: transientTypeErrors.unionTypes(name).usedInExpression,
        });
        this.types = types;
    }
    static fromTypes(types) {
        if (types.length === 0) {
            throw new InternalError('Cannot create intersection of zero types');
        }
        const distinctTypes = types.filter(distinctByEquality((a, b) => a.equals(b))).toSorted(sortBy((t) => t.fullName));
        if (distinctTypes.length === 1) {
            return distinctTypes[0];
        }
        return new IntersectionPType({
            types: distinctTypes,
        });
    }
}
class UnionPType extends TransientType {
    get fullName() {
        return this.types.map((t) => t).join(' | ');
    }
    singleton = false;
    types;
    constructor({ types }) {
        let typeMessage;
        let expressionMessage;
        const name = types.map((t) => t).join(' | ');
        const transientType = types.find((t) => t instanceof TransientType);
        if (transientType) {
            if (transientType instanceof NativeNumericType) {
                typeMessage = transientTypeErrors.nativeNumeric(name).usedAsType;
                expressionMessage = transientTypeErrors.nativeNumeric(name).usedInExpression;
            }
            else {
                typeMessage = transientType.typeMessage;
                expressionMessage = transientType.expressionMessage;
            }
        }
        else {
            typeMessage = transientTypeErrors.unionTypes(name).usedAsType;
            expressionMessage = transientTypeErrors.unionTypes(name).usedInExpression;
        }
        super({
            name,
            module: 'lib.d.ts',
            singleton: false,
            typeMessage,
            expressionMessage,
        });
        this.types = types;
    }
    static fromTypes(types) {
        if (types.length === 0) {
            throw new InternalError('Cannot create union of zero types');
        }
        const distinctTypes = types.filter(distinctByEquality((a, b) => a.equals(b))).toSorted(sortBy((t) => t.fullName));
        if (distinctTypes.length === 1) {
            return distinctTypes[0];
        }
        return new UnionPType({
            types: distinctTypes,
        });
    }
}
class StorageProxyPType extends PType {
    wtype;
    contentType;
    singleton = false;
    constructor(props) {
        super();
        this.wtype = props.keyWType;
        this.contentType = props.content;
    }
}
const GlobalStateGeneric = new GenericPType({
    name: 'GlobalState',
    module: Constants.moduleNames.algoTs.state,
    parameterise(typeArgs) {
        codeInvariant(typeArgs.length === 1, 'GlobalState type expects exactly one type parameter');
        return new GlobalStateType({
            content: typeArgs[0],
        });
    },
});
class GlobalStateType extends StorageProxyPType {
    static baseName = 'GlobalState';
    static baseFullName = `${Constants.moduleNames.algoTs.state}::${GlobalStateType.baseName}`;
    module = Constants.moduleNames.algoTs.state;
    get name() {
        return `${GlobalStateType.baseName}<${this.contentType.name}>`;
    }
    get fullName() {
        return `${GlobalStateType.baseFullName}<${this.contentType.fullName}>`;
    }
    constructor(props) {
        super({ ...props, keyWType: wtypes.stateKeyWType });
    }
}
const LocalStateGeneric = new GenericPType({
    name: 'LocalState',
    module: Constants.moduleNames.algoTs.state,
    parameterise(typeArgs) {
        codeInvariant(typeArgs.length === 1, 'LocalState type expects exactly one type parameter');
        return new LocalStateType({
            content: typeArgs[0],
        });
    },
});
class LocalStateType extends StorageProxyPType {
    static baseName = 'LocalState';
    static baseFullName = `${Constants.moduleNames.algoTs.state}::${LocalStateType.baseName}`;
    module = Constants.moduleNames.algoTs.state;
    get name() {
        return `${LocalStateType.baseName}<${this.contentType.name}>`;
    }
    get fullName() {
        return `${LocalStateType.baseFullName}<${this.contentType.fullName}>`;
    }
    constructor(props) {
        super({ ...props, keyWType: wtypes.stateKeyWType });
    }
    static parameterise(typeArgs) {
        codeInvariant(typeArgs.length === 1, 'LocalState type expects exactly one type parameter');
        return new LocalStateType({
            content: typeArgs[0],
        });
    }
}
const BoxGeneric = new GenericPType({
    name: 'Box',
    module: Constants.moduleNames.algoTs.box,
    parameterise(typeArgs) {
        codeInvariant(typeArgs.length === 1, `${this.name} type expects exactly one type parameter`);
        return new BoxPType({
            content: typeArgs[0],
        });
    },
});
class BoxPType extends StorageProxyPType {
    module = Constants.moduleNames.algoTs.box;
    get name() {
        return `Box<${this.contentType.name}>`;
    }
    get fullName() {
        return `${this.module}::${this.name}<${this.contentType.fullName}>`;
    }
    constructor(props) {
        super({ ...props, keyWType: wtypes.boxKeyWType });
    }
}
const BoxMapGeneric = new GenericPType({
    name: 'BoxMap',
    module: Constants.moduleNames.algoTs.box,
    parameterise(typeArgs) {
        codeInvariant(typeArgs.length === 2, `${this.name} type expects exactly two type parameters`);
        return new BoxMapPType({
            keyType: typeArgs[0],
            content: typeArgs[1],
        });
    },
});
class BoxMapPType extends StorageProxyPType {
    module = Constants.moduleNames.algoTs.box;
    get name() {
        return `BoxMap<${this.keyType.name}, ${this.contentType.name}>`;
    }
    get fullName() {
        return `${this.module}::${this.name}<${this.keyType.name}, ${this.contentType.fullName}>`;
    }
    keyType;
    constructor(props) {
        super({ ...props, keyWType: wtypes.boxKeyWType });
        this.keyType = props.keyType;
    }
}
class BoxRefPType extends StorageProxyPType {
    module = Constants.moduleNames.algoTs.box;
    get name() {
        return 'BoxRef';
    }
    constructor() {
        super({ keyWType: wtypes.boxKeyWType, content: bytesPType });
    }
}
/**
 * An open generic type parameter
 */
class TypeParameterType extends PType {
    name;
    module;
    singleton = false;
    wtype = undefined;
    constructor({ name, module }) {
        super();
        this.name = name;
        this.module = module;
    }
}
/**
 * A type from the typescript libs which might pop up in type reflection
 * but is not relevant to the output of the compiler
 */
class InternalType extends PType {
    name;
    module;
    singleton = false;
    wtype = undefined;
    constructor({ name, module }) {
        super();
        this.name = name;
        this.module = module;
    }
}
const ClassMethodDecoratorContext = new InternalType({
    module: 'typescript/lib/lib.decorators.d.ts',
    name: 'ClassMethodDecoratorContext',
});
class AnyPType extends PType {
    get wtype() {
        throw new CodeError('`any` is not valid as a variable, parameter, return, or property type.');
    }
    name = 'any';
    module = 'lib.d.ts';
    singleton = false;
}
class InstanceType extends PType {
    wtype;
    name;
    module;
    singleton = false;
    constructor({ name, module, wtype }) {
        super();
        this.name = name;
        this.wtype = wtype;
        this.module = module;
    }
}
class LibFunctionType extends PType {
    wtype;
    name;
    module;
    singleton = true;
    constructor({ name, module }) {
        super();
        this.name = name;
        this.module = module;
    }
}
class LibClassType extends PType {
    wtype;
    name;
    module;
    singleton = true;
    constructor({ name, module }) {
        super();
        this.name = name;
        this.module = module;
    }
}
class IntrinsicFunctionGroupType extends PType {
    wtype;
    name;
    module = Constants.moduleNames.algoTs.op;
    singleton = true;
    constructor({ name }) {
        super();
        this.name = name;
    }
}
class IntrinsicFunctionGroupTypeType extends PType {
    wtype;
    name;
    module = Constants.moduleNames.algoTs.op;
    singleton = false;
    constructor({ name }) {
        super();
        this.name = name;
    }
}
class IntrinsicFunctionType extends PType {
    wtype;
    name;
    module = Constants.moduleNames.algoTs.op;
    singleton = true;
    constructor({ name }) {
        super();
        this.name = name;
    }
}
class IntrinsicFunctionTypeType extends PType {
    wtype;
    name;
    module = Constants.moduleNames.algoTs.op;
    singleton = false;
    constructor({ name }) {
        super();
        this.name = name;
    }
}
class NamespacePType extends PType {
    wtype;
    name;
    factory;
    module;
    singleton = true;
    constructor({ name, module }) {
        super();
        this.name = name;
        this.module = module;
    }
    get fullName() {
        return `${this.module}::*`;
    }
    toString() {
        return this.module;
    }
}
class FunctionPType extends PType {
    wtype;
    name;
    module;
    returnType;
    parameters;
    singleton = true;
    sourceLocation;
    constructor(props) {
        super();
        this.name = props.name;
        this.module = props.module;
        this.sourceLocation = props.sourceLocation;
        if (props.returnType instanceof ObjectPType && !props.returnType.alias) {
            this.returnType = new ObjectPType({
                alias: new SymbolName({ name: `${props.name}Result`, module: this.module }),
                properties: props.returnType.properties,
                description: props.returnType.description,
            });
        }
        else {
            this.returnType = props.returnType;
        }
        this.parameters = props.parameters;
    }
}
class ArrayLiteralPType extends TransientType {
    get fullName() {
        return `${this.module}::[${this.items.map((i) => i).join(', ')}]`;
    }
    get elementType() {
        return this.items.length ? UnionPType.fromTypes(this.items) : neverPType;
    }
    items;
    immutable = true;
    constructor(props) {
        const name = `[${props.items.map((i) => i.name).join(', ')}]`;
        super({
            module: 'lib.d.ts',
            name,
            typeMessage: transientTypeErrors.arrays(name).usedAsType,
            expressionMessage: transientTypeErrors.arrays(name).usedInExpression,
            singleton: false,
        });
        this.items = props.items;
    }
    getArrayType() {
        return new ArrayPType({
            elementType: this.elementType,
        });
    }
    getTupleType() {
        return new TuplePType({
            items: this.items,
        });
    }
}
class TuplePType extends PType {
    module = 'lib.d.ts';
    get name() {
        return `Tuple<${this.items.map((i) => i.name).join(', ')}>`;
    }
    get fullName() {
        return `${this.module}::Tuple<${this.items.map((i) => i.fullName).join(', ')}>`;
    }
    items;
    singleton = false;
    immutable;
    constructor(props) {
        super();
        this.items = props.items;
        this.immutable = true;
    }
    get wtype() {
        return new wtypes.WTuple({
            types: this.items.map((i) => i.wtypeOrThrow),
            immutable: this.immutable,
        });
    }
}
class ArrayPType extends PType {
    elementType;
    immutable = true;
    singleton = false;
    name;
    module = 'lib.d.ts';
    get fullName() {
        return `${this.module}::Array<${this.elementType.fullName}>`;
    }
    constructor(props) {
        super();
        this.name = `Array<${props.elementType.name}>`;
        this.elementType = props.elementType;
    }
    get wtype() {
        return new wtypes.StackArray({
            itemType: this.elementType.wtypeOrThrow,
            immutable: this.immutable,
        });
    }
}
class ObjectPType extends PType {
    name = 'object';
    module = 'lib.d.ts';
    alias;
    description;
    properties;
    singleton = false;
    constructor(props) {
        super();
        this.properties = props.properties;
        this.description = props.description;
        this.alias = props.alias ?? null;
    }
    static anonymous(props) {
        const properties = Array.isArray(props) ? Object.fromEntries(props) : props;
        return new ObjectPType({
            properties,
        });
    }
    get wtype() {
        const tupleTypes = [];
        const tupleNames = [];
        for (const [propName, propType] of this.orderedProperties()) {
            if (propType instanceof TransientType) {
                throw new CodeError(`Property '${propName}' of ${this.name} has an unsupported type: ${propType.typeMessage}`);
            }
            tupleTypes.push(propType.wtypeOrThrow);
            tupleNames.push(propName);
        }
        return new wtypes.WTuple({
            name: this.alias?.fullName ?? this.fullName,
            names: tupleNames,
            types: tupleTypes,
            immutable: true,
        });
    }
    orderedProperties() {
        return Object.entries(this.properties);
    }
    getPropertyType(name) {
        if (Object.hasOwn(this.properties, name)) {
            return this.properties[name];
        }
        throw new CodeError(`${this} does not have property ${name}`);
    }
    hasProperty(name) {
        return Object.hasOwn(this.properties, name);
    }
    hasPropertyOfType(name, type) {
        return this.hasProperty(name) && this.properties[name].equals(type);
    }
    toString() {
        return `{${this.orderedProperties()
            .map((p) => `${p[0]}:${p[1].name}`)
            .join(',')}}`;
    }
}
const voidPType = new InstanceType({
    name: 'void',
    module: 'lib.d.ts',
    wtype: wtypes.voidWType,
});
const neverPType = new InstanceType({
    name: 'never',
    module: 'lib.d.ts',
    wtype: wtypes.voidWType,
});
const unknownPType = new UnsupportedType({
    name: 'unknown',
    module: 'lib.d.ts',
    fullName: 'unknown',
});
const nullPType = new UnsupportedType({
    name: 'null',
    module: 'lib.d.ts',
    fullName: 'null',
});
const undefinedPType = new UnsupportedType({
    name: 'undefined',
    module: 'lib.d.ts',
    fullName: 'undefined',
});
const PromiseGeneric = new GenericPType({
    name: 'Promise',
    module: 'typescript/lib/lib.es5.d.ts',
    parameterise(ptypes) {
        codeInvariant(ptypes.length === 1, 'Promise expects exactly 1 generic parameter');
        return new PromiseType({ resolveType: ptypes[0] });
    },
});
class PromiseType extends UnsupportedType {
    resolveType;
    constructor({ resolveType }) {
        super({
            name: 'Promise',
            module: 'typescript/lib/lib.es5.d.ts',
        });
        this.resolveType = resolveType;
    }
}
const anyPType = new AnyPType();
const boolPType = new InstanceType({
    name: 'boolean',
    module: 'lib.d.ts',
    wtype: wtypes.boolWType,
});
const BooleanFunction = new LibFunctionType({
    name: 'Boolean',
    module: 'typescript/lib/lib.es5.d.ts',
});
class NativeNumericType extends TransientType {
}
const bigIntPType = new NativeNumericType({
    name: 'bigint',
    module: 'lib.d.ts',
    singleton: false,
    typeMessage: transientTypeErrors.nativeNumeric('bigint').usedAsType,
    expressionMessage: transientTypeErrors.nativeNumeric('bigint').usedInExpression,
});
const stringPType = new InstanceType({
    name: 'string',
    module: 'lib.d.ts',
    wtype: wtypes.stringWType,
});
const StringFunction = new LibFunctionType({
    name: 'String',
    module: 'typescript/lib/lib.es5.d.ts',
});
const uint64PType = new InstanceType({
    name: 'uint64',
    module: Constants.moduleNames.algoTs.primitives,
    wtype: wtypes.uint64WType,
});
const biguintPType = new InstanceType({
    name: 'biguint',
    module: Constants.moduleNames.algoTs.primitives,
    wtype: wtypes.biguintWType,
});
class NumericLiteralPType extends NativeNumericType {
    literalValue;
    constructor({ literalValue }) {
        super({
            name: `${literalValue}`,
            module: 'lib.d.ts',
            singleton: false,
            typeMessage: transientTypeErrors.nativeNumeric(literalValue.toString()).usedAsType,
            expressionMessage: transientTypeErrors.nativeNumeric(literalValue.toString()).usedInExpression,
        });
        this.literalValue = literalValue;
    }
}
class BigIntLiteralPType extends NativeNumericType {
    literalValue;
    constructor({ literalValue }) {
        super({
            name: `${literalValue}n`,
            module: 'lib.d.ts',
            singleton: false,
            typeMessage: transientTypeErrors.nativeNumeric(`${literalValue}n`).usedAsType,
            expressionMessage: transientTypeErrors.nativeNumeric(`${literalValue}n`).usedInExpression,
        });
        this.literalValue = literalValue;
    }
}
const numberPType = new NativeNumericType({
    name: 'number',
    module: 'lib.d.ts',
    singleton: false,
    typeMessage: transientTypeErrors.nativeNumeric('number').usedAsType,
    expressionMessage: transientTypeErrors.nativeNumeric('number').usedInExpression,
});
const Uint64Function = new LibFunctionType({
    name: 'Uint64',
    module: Constants.moduleNames.algoTs.primitives,
});
const BigUintFunction = new LibFunctionType({
    name: 'BigUint',
    module: Constants.moduleNames.algoTs.primitives,
});
const bytesPType = new InstanceType({
    name: 'bytes',
    module: Constants.moduleNames.algoTs.primitives,
    wtype: wtypes.bytesWType,
});
const BytesFunction = new LibFunctionType({
    name: 'Bytes',
    module: Constants.moduleNames.algoTs.primitives,
});
const logFunction = new LibFunctionType({
    name: 'log',
    module: Constants.moduleNames.algoTs.util,
});
const assertFunction = new LibFunctionType({
    name: 'assert',
    module: Constants.moduleNames.algoTs.util,
});
const errFunction = new LibFunctionType({
    name: 'err',
    module: Constants.moduleNames.algoTs.util,
});
const assetPType = new InstanceType({
    name: 'Asset',
    wtype: wtypes.assetWType,
    module: Constants.moduleNames.algoTs.reference,
});
const AssetFunction = new LibFunctionType({
    name: 'Asset',
    module: Constants.moduleNames.algoTs.reference,
});
const accountPType = new InstanceType({
    name: 'Account',
    wtype: wtypes.accountWType,
    module: Constants.moduleNames.algoTs.reference,
});
const AccountFunction = new LibFunctionType({
    name: 'Account',
    module: Constants.moduleNames.algoTs.reference,
});
const applicationPType = new InstanceType({
    name: 'Application',
    wtype: wtypes.applicationWType,
    module: Constants.moduleNames.algoTs.reference,
});
const ApplicationFunctionType = new LibFunctionType({
    name: 'Application',
    module: Constants.moduleNames.algoTs.reference,
});
const GlobalStateFunction = new LibFunctionType({
    name: 'GlobalState',
    module: Constants.moduleNames.algoTs.state,
});
const LocalStateFunction = new LibFunctionType({
    name: 'LocalState',
    module: Constants.moduleNames.algoTs.state,
});
const BoxFunction = new LibFunctionType({
    name: BoxGeneric.name,
    module: Constants.moduleNames.algoTs.box,
});
const BoxMapFunction = new LibFunctionType({
    name: BoxMapGeneric.name,
    module: Constants.moduleNames.algoTs.box,
});
const BoxRefFunction = new LibFunctionType({
    name: 'BoxRef',
    module: Constants.moduleNames.algoTs.box,
});
const boxRefType = new BoxRefPType();
const ClearStateProgram = new FunctionPType({
    name: Constants.symbolNames.clearStateProgramMethodName,
    module: Constants.moduleNames.algoTs.baseContract,
    returnType: uint64PType,
    parameters: [],
    sourceLocation: undefined,
});
const ApprovalProgram = new FunctionPType({
    name: Constants.symbolNames.approvalProgramMethodName,
    module: Constants.moduleNames.algoTs.arc4.index,
    returnType: boolPType,
    parameters: [],
    sourceLocation: undefined,
});
const baseContractType = new BaseContractClassType({
    module: Constants.moduleNames.algoTs.baseContract,
    name: 'BaseContract',
    methods: {
        clearStateProgram: ClearStateProgram,
    },
    properties: {},
    baseTypes: [],
    isArc4: false,
    sourceLocation: SourceLocation.None,
});
const arc4BaseContractType = new BaseContractClassType({
    module: Constants.moduleNames.algoTs.arc4.index,
    name: 'Contract',
    methods: {
        approvalProgram: ApprovalProgram,
        clearStateProgram: ClearStateProgram,
    },
    properties: {},
    baseTypes: [baseContractType],
    isArc4: true,
    sourceLocation: SourceLocation.None,
});
const arc4BareMethodDecorator = new LibFunctionType({
    module: Constants.moduleNames.algoTs.arc4.index,
    name: 'baremethod',
});
const arc4AbiMethodDecorator = new LibFunctionType({
    module: Constants.moduleNames.algoTs.arc4.index,
    name: 'abimethod',
});
const contractOptionsDecorator = new LibFunctionType({
    module: Constants.moduleNames.algoTs.baseContract,
    name: 'contract',
});
const logicSigOptionsDecorator = new LibFunctionType({
    module: Constants.moduleNames.algoTs.logicSig,
    name: 'logicsig',
});
class GroupTransactionPType extends PType {
    get wtype() {
        return new wtypes.WGroupTransaction({
            transactionType: this.kind,
        });
    }
    name;
    kind;
    module = Constants.moduleNames.algoTs.gtxn;
    singleton = false;
    constructor({ kind, name }) {
        super();
        this.name = name;
        this.kind = kind;
    }
}
class TransactionFunctionType extends LibFunctionType {
    kind;
    constructor({ name, module, kind }) {
        super({ name, module });
        this.kind = kind;
    }
}
const paymentGtxnType = new GroupTransactionPType({
    name: 'PaymentTxn',
    kind: TransactionKind.pay,
});
const PaymentTxnFunction = new TransactionFunctionType({
    name: 'PaymentTxn',
    module: Constants.moduleNames.algoTs.gtxn,
    kind: TransactionKind.pay,
});
const keyRegistrationGtxnType = new GroupTransactionPType({
    name: 'KeyRegistrationTxn',
    kind: TransactionKind.keyreg,
});
const KeyRegistrationTxnFunction = new TransactionFunctionType({
    name: 'KeyRegistrationTxn',
    module: Constants.moduleNames.algoTs.gtxn,
    kind: TransactionKind.keyreg,
});
const assetConfigGtxnType = new GroupTransactionPType({
    name: 'AssetConfigTxn',
    kind: TransactionKind.acfg,
});
const AssetConfigTxnFunction = new TransactionFunctionType({
    name: 'AssetConfigTxn',
    module: Constants.moduleNames.algoTs.gtxn,
    kind: TransactionKind.acfg,
});
const assetTransferGtxnType = new GroupTransactionPType({
    name: 'AssetTransferTxn',
    kind: TransactionKind.axfer,
});
const AssetTransferTxnFunction = new TransactionFunctionType({
    name: 'AssetTransferTxn',
    module: Constants.moduleNames.algoTs.gtxn,
    kind: TransactionKind.axfer,
});
const assetFreezeGtxnType = new GroupTransactionPType({
    name: 'AssetFreezeTxn',
    kind: TransactionKind.afrz,
});
const AssetFreezeTxnFunction = new TransactionFunctionType({
    name: 'AssetFreezeTxn',
    module: Constants.moduleNames.algoTs.gtxn,
    kind: TransactionKind.afrz,
});
const applicationCallGtxnType = new GroupTransactionPType({
    name: 'ApplicationCallTxn',
    kind: TransactionKind.appl,
});
const ApplicationTxnFunction = new TransactionFunctionType({
    name: 'ApplicationCallTxn',
    module: Constants.moduleNames.algoTs.gtxn,
    kind: TransactionKind.appl,
});
const gtxnUnion = UnionPType.fromTypes([
    paymentGtxnType,
    keyRegistrationGtxnType,
    assetConfigGtxnType,
    assetTransferGtxnType,
    assetFreezeGtxnType,
    applicationCallGtxnType,
]);
const anyGtxnType = new GroupTransactionPType({
    name: 'Transaction',
    kind: undefined,
});
const TransactionFunction = new TransactionFunctionType({
    name: 'Transaction',
    module: Constants.moduleNames.algoTs.gtxn,
    kind: undefined,
});
const assertMatchFunction = new LibFunctionType({
    name: 'assertMatch',
    module: Constants.moduleNames.algoTs.util,
});
const matchFunction = new LibFunctionType({
    name: 'match',
    module: Constants.moduleNames.algoTs.util,
});
class Uint64EnumMemberType extends PType {
    wtype = wtypes.uint64WType;
    name;
    module;
    singleton = false;
    enumType;
    constructor(enumType) {
        super();
        this.name = enumType.name;
        this.module = enumType.module;
        this.enumType = enumType;
    }
}
class Uint64EnumType extends PType {
    memberType;
    wtype = wtypes.uint64WType;
    name;
    module;
    singleton = true;
    members;
    constructor(props) {
        super();
        this.name = props.name;
        this.module = props.module;
        this.members = props.members;
        this.memberType = new Uint64EnumMemberType(this);
    }
}
const transactionTypeType = new Uint64EnumType({
    module: Constants.moduleNames.algoTs.transactions,
    name: 'TransactionType',
    members: {
        Payment: 1n,
        KeyRegistration: 2n,
        AssetConfig: 3n,
        AssetTransfer: 4n,
        AssetFreeze: 5n,
        ApplicationCall: 6n,
    },
});
const onCompleteActionType = new Uint64EnumType({
    module: Constants.moduleNames.algoTs.onCompleteAction,
    name: 'OnCompleteAction',
    members: {
        NoOp: 0n,
        OptIn: 1n,
        CloseOut: 2n,
        ClearState: 3n,
        UpdateApplication: 4n,
        DeleteApplication: 5n,
    },
});
const ensureBudgetFunction = new LibFunctionType({
    name: 'ensureBudget',
    module: Constants.moduleNames.algoTs.util,
});
const opUpFeeSourceType = new Uint64EnumType({
    module: Constants.moduleNames.algoTs.util,
    name: 'OpUpFeeSource',
    members: {
        GroupCredit: 0n,
        AppAccount: 1n,
        Any: 2n,
    },
});
const urangeFunction = new LibFunctionType({
    name: 'urange',
    module: Constants.moduleNames.algoTs.util,
});
const IterableIteratorGeneric = new GenericPType({
    name: 'IterableIterator',
    module: 'typescript/lib/lib.es2015.iterable.d.ts',
    parameterise(typeArgs) {
        codeInvariant(typeArgs.length >= 1 && typeArgs.length <= 3, 'IterableIterator type expects 1-3 type parameters');
        // Currently ignoring return and next types
        const [yieldType, _returnType, _nextType] = typeArgs;
        return new IterableIteratorType({
            itemType: yieldType,
        });
    },
});
class IterableIteratorType extends TransientType {
    itemType;
    constructor({ itemType }) {
        super({
            name: `IterableIterator<${itemType.name}>`,
            module: 'typescript/lib/lib.es2015.iterable.d.ts',
            typeMessage: '`IterableIterator` is not valid as a variable, parameter, return, or property type. ',
            expressionMessage: 'IterableIterator expressions can only be used in for loops',
            singleton: false,
        });
        this.itemType = itemType;
    }
    get wtype() {
        return new wtypes.WEnumeration({ sequenceType: this.itemType.wtypeOrThrow });
    }
}
const GeneratorGeneric = new GenericPType({
    name: 'Generator',
    module: 'typescript/lib/lib.es2015.generator.d.ts',
    parameterise(ptypes) {
        codeInvariant(ptypes.length === 3, 'Generator type expects exactly 3 type params');
        const [itemType, returnType, nextType] = ptypes;
        return new GeneratorType({
            itemType,
            nextType,
            returnType,
        });
    },
});
class GeneratorType extends UnsupportedType {
    itemType;
    returnType;
    nextType;
    constructor({ itemType, returnType, nextType }) {
        super({
            name: 'Generator',
            module: 'typescript/lib/lib.es2015.generator.d.ts',
        });
        this.itemType = itemType;
        this.returnType = returnType;
        this.nextType = nextType;
    }
}
const paymentItxnFn = new TransactionFunctionType({
    name: 'payment',
    module: Constants.moduleNames.algoTs.itxn,
    kind: TransactionKind.pay,
});
const keyRegistrationItxnFn = new TransactionFunctionType({
    name: 'keyRegistration',
    module: Constants.moduleNames.algoTs.itxn,
    kind: TransactionKind.keyreg,
});
const assetConfigItxnFn = new TransactionFunctionType({
    name: 'assetConfig',
    module: Constants.moduleNames.algoTs.itxn,
    kind: TransactionKind.acfg,
});
const assetTransferItxnFn = new TransactionFunctionType({
    name: 'assetTransfer',
    module: Constants.moduleNames.algoTs.itxn,
    kind: TransactionKind.axfer,
});
const assetFreezeItxnFn = new TransactionFunctionType({
    name: 'assetFreeze',
    module: Constants.moduleNames.algoTs.itxn,
    kind: TransactionKind.afrz,
});
const applicationCallItxnFn = new TransactionFunctionType({
    name: 'applicationCall',
    module: Constants.moduleNames.algoTs.itxn,
    kind: TransactionKind.appl,
});
class InnerTransactionPType extends PType {
    get wtype() {
        return new wtypes.WInnerTransaction({
            transactionType: this.kind,
        });
    }
    name;
    kind;
    module = Constants.moduleNames.algoTs.itxn;
    singleton = false;
    constructor({ kind, name }) {
        super();
        this.name = name;
        this.kind = kind;
    }
}
class ItxnParamsPType extends PType {
    get wtype() {
        return new wtypes.WInnerTransactionFields({
            transactionType: this.kind,
        });
    }
    name;
    kind;
    module = Constants.moduleNames.algoTs.itxn;
    singleton = false;
    constructor({ kind, name }) {
        super();
        this.name = name;
        this.kind = kind;
    }
}
const paymentItxnParamsType = new ItxnParamsPType({
    name: 'PaymentItxnParams',
    kind: TransactionKind.pay,
});
const paymentItxnType = new InnerTransactionPType({
    name: 'PaymentInnerTxn',
    kind: TransactionKind.pay,
});
const keyRegistrationItxnParamsType = new ItxnParamsPType({
    name: 'KeyRegistrationItxnParams',
    kind: TransactionKind.keyreg,
});
const keyRegistrationItxnType = new InnerTransactionPType({
    name: 'KeyRegistrationInnerTxn',
    kind: TransactionKind.keyreg,
});
const assetConfigItxnParamsType = new ItxnParamsPType({
    name: 'AssetConfigItxnParams',
    kind: TransactionKind.acfg,
});
const assetConfigItxnType = new InnerTransactionPType({
    name: 'AssetConfigInnerTxn',
    kind: TransactionKind.acfg,
});
const assetTransferItxnParamsType = new ItxnParamsPType({
    name: 'AssetTransferItxnParams',
    kind: TransactionKind.axfer,
});
const assetTransferItxnType = new InnerTransactionPType({
    name: 'AssetTransferInnerTxn',
    kind: TransactionKind.axfer,
});
const assetFreezeItxnParamsType = new ItxnParamsPType({
    name: 'AssetFreezeItxnParams',
    kind: TransactionKind.afrz,
});
const assetFreezeItxnType = new InnerTransactionPType({
    name: 'AssetFreezeInnerTxn',
    kind: TransactionKind.afrz,
});
const applicationCallItxnParamsType = new ItxnParamsPType({
    name: 'ApplicationCallItxnParams',
    kind: TransactionKind.appl,
});
const applicationItxnType = new InnerTransactionPType({
    name: 'ApplicationCallInnerTxn',
    kind: TransactionKind.appl,
});
const anyItxnType = new InnerTransactionPType({
    name: 'InnerTxn',
});
const submitGroupItxnFunction = new LibFunctionType({
    name: 'submitGroup',
    module: Constants.moduleNames.algoTs.itxn,
});
const TemplateVarFunction = new LibFunctionType({
    name: 'TemplateVar',
    module: Constants.moduleNames.algoTs.templateVar,
});
const compileFunctionType = new LibFunctionType({
    name: 'compile',
    module: Constants.moduleNames.algoTs.compiled,
});
const compiledContractType = new ObjectPType({
    alias: new SymbolName({
        name: 'CompiledContract',
        module: Constants.moduleNames.algoTs.compiled,
    }),
    description: 'Provides compiled programs and state allocation values for a Contract. Created by calling `compile(ExampleContractType)`',
    properties: {
        approvalProgram: new TuplePType({ items: [bytesPType, bytesPType] }),
        clearStateProgram: new TuplePType({ items: [bytesPType, bytesPType] }),
        extraProgramPages: uint64PType,
        globalUints: uint64PType,
        globalBytes: uint64PType,
        localUints: uint64PType,
        localBytes: uint64PType,
    },
});
const compiledLogicSigType = new ObjectPType({
    alias: new SymbolName({
        name: 'CompiledLogicSig',
        module: Constants.moduleNames.algoTs.compiled,
    }),
    description: 'Provides account for a Logic Signature. Created by calling `compile(LogicSigType)``',
    properties: {
        account: accountPType,
    },
});
const arc28EmitFunction = new LibFunctionType({
    name: 'emit',
    module: Constants.moduleNames.algoTs.arc28,
});
const SuperPrototypeSelectorGeneric = new GenericPType({
    name: 'SuperPrototypeSelector',
    module: Constants.moduleNames.polytype,
    parameterise(ptypes) {
        return new SuperPrototypeSelector({ bases: ptypes });
    },
});
class SuperPrototypeSelector extends InternalType {
    constructor({ bases }) {
        super({
            name: 'SuperPrototypeSelector',
            module: Constants.moduleNames.polytype,
        });
    }
}
const ClusteredPrototype = new InternalType({
    name: 'ClusteredPrototype',
    module: Constants.moduleNames.polytype,
});
const PolytypeClassMethodHelper = new LibFunctionType({
    name: 'class',
    module: Constants.moduleNames.polytype,
});
const MutableArrayConstructor = new LibClassType({
    name: 'MutableArray',
    module: Constants.moduleNames.algoTs.mutableArray,
});
const MutableArrayGeneric = new GenericPType({
    name: 'MutableArray',
    module: Constants.moduleNames.algoTs.mutableArray,
    parameterise: (typeArgs) => {
        codeInvariant(typeArgs.length === 1, 'MutableArray type expects exactly one type parameter');
        const [elementType] = typeArgs;
        return new MutableArrayType({ elementType: elementType });
    },
});
class MutableArrayType extends PType {
    module = Constants.moduleNames.algoTs.mutableArray;
    immutable = false;
    name;
    singleton = false;
    sourceLocation;
    elementType;
    constructor({ elementType, sourceLocation, name, }) {
        super();
        this.name = name ?? `MutableArray<${elementType}>`;
        this.sourceLocation = sourceLocation;
        this.elementType = elementType;
    }
    get wtype() {
        return new wtypes.ReferenceArray({
            itemType: this.elementType.wtypeOrThrow,
            sourceLocation: this.sourceLocation,
            immutable: false,
        });
    }
}

function getInnerTransactionType(kind) {
    switch (kind) {
        case TransactionKind.pay:
            return paymentItxnType;
        case TransactionKind.keyreg:
            return keyRegistrationItxnType;
        case TransactionKind.acfg:
            return assetConfigItxnType;
        case TransactionKind.axfer:
            return assetTransferItxnType;
        case TransactionKind.afrz:
            return assetFreezeItxnType;
        case TransactionKind.appl:
            return applicationItxnType;
    }
}
function getItxnParamsType(kind) {
    switch (kind) {
        case TransactionKind.pay:
            return paymentItxnParamsType;
        case TransactionKind.keyreg:
            return keyRegistrationItxnParamsType;
        case TransactionKind.acfg:
            return assetConfigItxnParamsType;
        case TransactionKind.axfer:
            return assetTransferItxnParamsType;
        case TransactionKind.afrz:
            return assetFreezeItxnParamsType;
        case TransactionKind.appl:
            return applicationCallItxnParamsType;
    }
}
function getGroupTransactionType(kind) {
    switch (kind) {
        case TransactionKind.pay:
            return paymentGtxnType;
        case TransactionKind.keyreg:
            return keyRegistrationGtxnType;
        case TransactionKind.acfg:
            return assetConfigGtxnType;
        case TransactionKind.axfer:
            return assetTransferGtxnType;
        case TransactionKind.afrz:
            return assetFreezeGtxnType;
        case TransactionKind.appl:
            return applicationCallGtxnType;
        default:
            return anyGtxnType;
    }
}

/* AUTOGENERATED FILE - DO NOT EDIT (see puya/scripts/generate_ts_nodes.py) */
class Node {
    constructor(props) {
        this.sourceLocation = props.sourceLocation;
    }
    sourceLocation;
}
class Statement extends Node {
    constructor(props) {
        super(props);
    }
}
class Expression extends Node {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
    }
    wtype;
}
class ExpressionStatement extends Statement {
    constructor(props) {
        super(props);
        this.expr = props.expr;
        this.sourceLocation = props.sourceLocation;
    }
    expr;
    sourceLocation;
    accept(visitor) {
        return visitor.visitExpressionStatement(this);
    }
}
class Block extends Statement {
    constructor(props) {
        super(props);
        this.body = props.body;
        this.label = props.label;
        this.comment = props.comment;
    }
    body;
    label;
    comment;
    accept(visitor) {
        return visitor.visitBlock(this);
    }
}
class Goto extends Statement {
    constructor(props) {
        super(props);
        this.target = props.target;
    }
    target;
    accept(visitor) {
        return visitor.visitGoto(this);
    }
}
class IfElse extends Statement {
    constructor(props) {
        super(props);
        this.condition = props.condition;
        this.ifBranch = props.ifBranch;
        this.elseBranch = props.elseBranch;
    }
    condition;
    ifBranch;
    elseBranch;
    accept(visitor) {
        return visitor.visitIfElse(this);
    }
}
class Switch extends Statement {
    constructor(props) {
        super(props);
        this.value = props.value;
        this.cases = props.cases;
        this.defaultCase = props.defaultCase;
    }
    value;
    cases;
    defaultCase;
    accept(visitor) {
        return visitor.visitSwitch(this);
    }
}
class WhileLoop extends Statement {
    constructor(props) {
        super(props);
        this.condition = props.condition;
        this.loopBody = props.loopBody;
    }
    condition;
    loopBody;
    accept(visitor) {
        return visitor.visitWhileLoop(this);
    }
}
class LoopExit extends Statement {
    constructor(props) {
        super(props);
    }
    accept(visitor) {
        return visitor.visitLoopExit(this);
    }
}
class LoopContinue extends Statement {
    constructor(props) {
        super(props);
    }
    accept(visitor) {
        return visitor.visitLoopContinue(this);
    }
}
class ReturnStatement extends Statement {
    constructor(props) {
        super(props);
        this.value = props.value;
    }
    value;
    accept(visitor) {
        return visitor.visitReturnStatement(this);
    }
}
class AssertExpression extends Expression {
    constructor(props) {
        super(props);
        this.condition = props.condition;
        this.errorMessage = props.errorMessage;
        this.wtype = props.wtype;
    }
    condition;
    errorMessage;
    wtype;
    accept(visitor) {
        return visitor.visitAssertExpression(this);
    }
}
class IntegerConstant extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.value = props.value;
        this.tealAlias = props.tealAlias;
    }
    wtype;
    value;
    tealAlias;
    accept(visitor) {
        return visitor.visitIntegerConstant(this);
    }
}
class DecimalConstant extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.value = props.value;
    }
    wtype;
    value;
    accept(visitor) {
        return visitor.visitDecimalConstant(this);
    }
}
class BoolConstant extends Expression {
    constructor(props) {
        super(props);
        this.value = props.value;
        this.wtype = props.wtype;
    }
    value;
    wtype;
    accept(visitor) {
        return visitor.visitBoolConstant(this);
    }
}
var BytesEncoding;
(function (BytesEncoding) {
    BytesEncoding["unknown"] = "unknown";
    BytesEncoding["base16"] = "base16";
    BytesEncoding["base32"] = "base32";
    BytesEncoding["base64"] = "base64";
    BytesEncoding["utf8"] = "utf8";
})(BytesEncoding || (BytesEncoding = {}));
class BytesConstant extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.value = props.value;
        this.encoding = props.encoding;
    }
    wtype;
    value;
    encoding;
    accept(visitor) {
        return visitor.visitBytesConstant(this);
    }
}
class StringConstant extends Expression {
    constructor(props) {
        super(props);
        this.value = props.value;
        this.wtype = props.wtype;
    }
    value;
    wtype;
    accept(visitor) {
        return visitor.visitStringConstant(this);
    }
}
class VoidConstant extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
    }
    wtype;
    accept(visitor) {
        return visitor.visitVoidConstant(this);
    }
}
class TemplateVar extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.name = props.name;
    }
    wtype;
    name;
    accept(visitor) {
        return visitor.visitTemplateVar(this);
    }
}
class MethodConstant extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.value = props.value;
    }
    wtype;
    value;
    accept(visitor) {
        return visitor.visitMethodConstant(this);
    }
}
class AddressConstant extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.value = props.value;
    }
    wtype;
    value;
    accept(visitor) {
        return visitor.visitAddressConstant(this);
    }
}
class ARC4Encode extends Expression {
    constructor(props) {
        super(props);
        this.value = props.value;
        this.wtype = props.wtype;
    }
    value;
    wtype;
    accept(visitor) {
        return visitor.visitARC4Encode(this);
    }
}
class Copy extends Expression {
    constructor(props) {
        super(props);
        this.value = props.value;
        this.wtype = props.wtype;
    }
    value;
    wtype;
    accept(visitor) {
        return visitor.visitCopy(this);
    }
}
class ArrayConcat extends Expression {
    constructor(props) {
        super(props);
        this.left = props.left;
        this.right = props.right;
        this.wtype = props.wtype;
    }
    left;
    right;
    wtype;
    accept(visitor) {
        return visitor.visitArrayConcat(this);
    }
}
class ArrayExtend extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.other = props.other;
        this.wtype = props.wtype;
    }
    base;
    other;
    wtype;
    accept(visitor) {
        return visitor.visitArrayExtend(this);
    }
}
class ArrayPop extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.wtype = props.wtype;
    }
    base;
    wtype;
    accept(visitor) {
        return visitor.visitArrayPop(this);
    }
}
class ArrayReplace extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.index = props.index;
        this.value = props.value;
        this.wtype = props.wtype;
    }
    base;
    index;
    value;
    wtype;
    accept(visitor) {
        return visitor.visitArrayReplace(this);
    }
}
class ARC4Decode extends Expression {
    constructor(props) {
        super(props);
        this.value = props.value;
    }
    value;
    accept(visitor) {
        return visitor.visitARC4Decode(this);
    }
}
class IntrinsicCall extends Expression {
    constructor(props) {
        super(props);
        this.opCode = props.opCode;
        this.immediates = props.immediates;
        this.stackArgs = props.stackArgs;
    }
    opCode;
    immediates;
    stackArgs;
    accept(visitor) {
        return visitor.visitIntrinsicCall(this);
    }
}
class CreateInnerTransaction extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.fields = props.fields;
    }
    wtype;
    fields;
    accept(visitor) {
        return visitor.visitCreateInnerTransaction(this);
    }
}
class UpdateInnerTransaction extends Expression {
    constructor(props) {
        super(props);
        this.itxn = props.itxn;
        this.fields = props.fields;
        this.wtype = props.wtype;
    }
    itxn;
    fields;
    wtype;
    accept(visitor) {
        return visitor.visitUpdateInnerTransaction(this);
    }
}
class GroupTransactionReference extends Expression {
    constructor(props) {
        super(props);
        this.index = props.index;
        this.wtype = props.wtype;
    }
    index;
    wtype;
    accept(visitor) {
        return visitor.visitGroupTransactionReference(this);
    }
}
class CheckedMaybe extends Expression {
    constructor(props) {
        super(props);
        this.expr = props.expr;
        this.comment = props.comment;
        this.wtype = props.wtype;
        this.sourceLocation = props.sourceLocation;
    }
    expr;
    comment;
    wtype;
    sourceLocation;
    accept(visitor) {
        return visitor.visitCheckedMaybe(this);
    }
}
class TupleExpression extends Expression {
    constructor(props) {
        super(props);
        this.items = props.items;
        this.wtype = props.wtype;
    }
    items;
    wtype;
    accept(visitor) {
        return visitor.visitTupleExpression(this);
    }
}
class TupleItemExpression extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.index = props.index;
        this.wtype = props.wtype;
    }
    base;
    index;
    wtype;
    accept(visitor) {
        return visitor.visitTupleItemExpression(this);
    }
}
class VarExpression extends Expression {
    constructor(props) {
        super(props);
        this.name = props.name;
    }
    name;
    accept(visitor) {
        return visitor.visitVarExpression(this);
    }
}
class InnerTransactionField extends Expression {
    constructor(props) {
        super(props);
        this.itxn = props.itxn;
        this.field = props.field;
        this.arrayIndex = props.arrayIndex;
    }
    itxn;
    field;
    arrayIndex;
    accept(visitor) {
        return visitor.visitInnerTransactionField(this);
    }
}
class SubmitInnerTransaction extends Expression {
    constructor(props) {
        super(props);
        this.itxns = props.itxns;
        this.wtype = props.wtype;
    }
    itxns;
    wtype;
    accept(visitor) {
        return visitor.visitSubmitInnerTransaction(this);
    }
}
class FieldExpression extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.name = props.name;
        this.wtype = props.wtype;
    }
    base;
    name;
    wtype;
    accept(visitor) {
        return visitor.visitFieldExpression(this);
    }
}
class IndexExpression extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.index = props.index;
    }
    base;
    index;
    accept(visitor) {
        return visitor.visitIndexExpression(this);
    }
}
class SliceExpression extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.beginIndex = props.beginIndex;
        this.endIndex = props.endIndex;
    }
    base;
    beginIndex;
    endIndex;
    accept(visitor) {
        return visitor.visitSliceExpression(this);
    }
}
class IntersectionSliceExpression extends Expression {
    constructor(props) {
        super(props);
        this.base = props.base;
        this.beginIndex = props.beginIndex;
        this.endIndex = props.endIndex;
    }
    base;
    beginIndex;
    endIndex;
    accept(visitor) {
        return visitor.visitIntersectionSliceExpression(this);
    }
}
class AppStateExpression extends Expression {
    constructor(props) {
        super(props);
        this.key = props.key;
        this.existsAssertionMessage = props.existsAssertionMessage;
    }
    key;
    existsAssertionMessage;
    accept(visitor) {
        return visitor.visitAppStateExpression(this);
    }
}
class AppAccountStateExpression extends Expression {
    constructor(props) {
        super(props);
        this.key = props.key;
        this.existsAssertionMessage = props.existsAssertionMessage;
        this.account = props.account;
    }
    key;
    existsAssertionMessage;
    account;
    accept(visitor) {
        return visitor.visitAppAccountStateExpression(this);
    }
}
class BoxValueExpression extends Expression {
    constructor(props) {
        super(props);
        this.key = props.key;
        this.existsAssertionMessage = props.existsAssertionMessage;
    }
    key;
    existsAssertionMessage;
    accept(visitor) {
        return visitor.visitBoxValueExpression(this);
    }
}
class SingleEvaluation extends Expression {
    constructor(props) {
        super(props);
        this.source = props.source;
        this.id = props.id;
        this.wtype = props.wtype;
        this.sourceLocation = props.sourceLocation;
    }
    source;
    id;
    wtype;
    sourceLocation;
    accept(visitor) {
        return visitor.visitSingleEvaluation(this);
    }
}
class ReinterpretCast extends Expression {
    constructor(props) {
        super(props);
        this.expr = props.expr;
    }
    expr;
    accept(visitor) {
        return visitor.visitReinterpretCast(this);
    }
}
class NewArray extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.values = props.values;
    }
    wtype;
    values;
    accept(visitor) {
        return visitor.visitNewArray(this);
    }
}
class ArrayLength extends Expression {
    constructor(props) {
        super(props);
        this.array = props.array;
        this.wtype = props.wtype;
    }
    array;
    wtype;
    accept(visitor) {
        return visitor.visitArrayLength(this);
    }
}
class ConditionalExpression extends Expression {
    constructor(props) {
        super(props);
        this.condition = props.condition;
        this.trueExpr = props.trueExpr;
        this.falseExpr = props.falseExpr;
        this.wtype = props.wtype;
    }
    condition;
    trueExpr;
    falseExpr;
    wtype;
    accept(visitor) {
        return visitor.visitConditionalExpression(this);
    }
}
class AssignmentStatement extends Statement {
    constructor(props) {
        super(props);
        this.target = props.target;
        this.value = props.value;
    }
    target;
    value;
    accept(visitor) {
        return visitor.visitAssignmentStatement(this);
    }
}
class AssignmentExpression extends Expression {
    constructor(props) {
        super(props);
        this.target = props.target;
        this.value = props.value;
        this.wtype = props.wtype;
    }
    target;
    value;
    wtype;
    accept(visitor) {
        return visitor.visitAssignmentExpression(this);
    }
}
var EqualityComparison;
(function (EqualityComparison) {
    EqualityComparison["eq"] = "==";
    EqualityComparison["ne"] = "!=";
})(EqualityComparison || (EqualityComparison = {}));
var NumericComparison;
(function (NumericComparison) {
    NumericComparison["eq"] = "==";
    NumericComparison["ne"] = "!=";
    NumericComparison["lt"] = "<";
    NumericComparison["lte"] = "<=";
    NumericComparison["gt"] = ">";
    NumericComparison["gte"] = ">=";
})(NumericComparison || (NumericComparison = {}));
class NumericComparisonExpression extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.lhs = props.lhs;
        this.operator = props.operator;
        this.rhs = props.rhs;
    }
    wtype;
    lhs;
    operator;
    rhs;
    accept(visitor) {
        return visitor.visitNumericComparisonExpression(this);
    }
}
class BytesComparisonExpression extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.lhs = props.lhs;
        this.operator = props.operator;
        this.rhs = props.rhs;
    }
    wtype;
    lhs;
    operator;
    rhs;
    accept(visitor) {
        return visitor.visitBytesComparisonExpression(this);
    }
}
class SubroutineID {
    constructor(props) {
        this.target = props.target;
    }
    target;
}
class InstanceMethodTarget {
    constructor(props) {
        this.memberName = props.memberName;
    }
    memberName;
}
class InstanceSuperMethodTarget {
    constructor(props) {
        this.memberName = props.memberName;
    }
    memberName;
}
class ContractMethodTarget {
    constructor(props) {
        this.cref = props.cref;
        this.memberName = props.memberName;
    }
    cref;
    memberName;
}
class CallArg {
    constructor(props) {
        this.name = props.name;
        this.value = props.value;
    }
    name;
    value;
}
class SubroutineCallExpression extends Expression {
    constructor(props) {
        super(props);
        this.target = props.target;
        this.args = props.args;
    }
    target;
    args;
    accept(visitor) {
        return visitor.visitSubroutineCallExpression(this);
    }
}
class PuyaLibData {
    constructor(props) {
        this.id = props.id;
        this.params = props.params;
        this.wtype = props.wtype;
    }
    id;
    params;
    wtype;
}
var PuyaLibFunction;
(function (PuyaLibFunction) {
    PuyaLibFunction["ensureBudget"] = "ensure_budget";
    PuyaLibFunction["isSubstring"] = "is_substring";
})(PuyaLibFunction || (PuyaLibFunction = {}));
class PuyaLibCall extends Expression {
    constructor(props) {
        super(props);
        this.func = props.func;
        this.args = props.args;
        this.wtype = props.wtype;
    }
    func;
    args;
    wtype;
    accept(visitor) {
        return visitor.visitPuyaLibCall(this);
    }
}
var UInt64BinaryOperator;
(function (UInt64BinaryOperator) {
    UInt64BinaryOperator["add"] = "+";
    UInt64BinaryOperator["sub"] = "-";
    UInt64BinaryOperator["mult"] = "*";
    UInt64BinaryOperator["floorDiv"] = "//";
    UInt64BinaryOperator["mod"] = "%";
    UInt64BinaryOperator["pow"] = "**";
    UInt64BinaryOperator["lshift"] = "<<";
    UInt64BinaryOperator["rshift"] = ">>";
    UInt64BinaryOperator["bitOr"] = "|";
    UInt64BinaryOperator["bitXor"] = "^";
    UInt64BinaryOperator["bitAnd"] = "&";
})(UInt64BinaryOperator || (UInt64BinaryOperator = {}));
var BigUIntBinaryOperator;
(function (BigUIntBinaryOperator) {
    BigUIntBinaryOperator["add"] = "+";
    BigUIntBinaryOperator["sub"] = "-";
    BigUIntBinaryOperator["mult"] = "*";
    BigUIntBinaryOperator["floorDiv"] = "//";
    BigUIntBinaryOperator["mod"] = "%";
    BigUIntBinaryOperator["bitOr"] = "|";
    BigUIntBinaryOperator["bitXor"] = "^";
    BigUIntBinaryOperator["bitAnd"] = "&";
})(BigUIntBinaryOperator || (BigUIntBinaryOperator = {}));
var BytesBinaryOperator;
(function (BytesBinaryOperator) {
    BytesBinaryOperator["add"] = "+";
    BytesBinaryOperator["bitOr"] = "|";
    BytesBinaryOperator["bitXor"] = "^";
    BytesBinaryOperator["bitAnd"] = "&";
})(BytesBinaryOperator || (BytesBinaryOperator = {}));
var BytesUnaryOperator;
(function (BytesUnaryOperator) {
    BytesUnaryOperator["bitInvert"] = "~";
})(BytesUnaryOperator || (BytesUnaryOperator = {}));
var UInt64UnaryOperator;
(function (UInt64UnaryOperator) {
    UInt64UnaryOperator["bitInvert"] = "~";
})(UInt64UnaryOperator || (UInt64UnaryOperator = {}));
var UInt64PostfixUnaryOperator;
(function (UInt64PostfixUnaryOperator) {
    UInt64PostfixUnaryOperator["increment"] = "++";
    UInt64PostfixUnaryOperator["decrement"] = "--";
})(UInt64PostfixUnaryOperator || (UInt64PostfixUnaryOperator = {}));
class UInt64UnaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.op = props.op;
        this.expr = props.expr;
        this.wtype = props.wtype;
    }
    op;
    expr;
    wtype;
    accept(visitor) {
        return visitor.visitUInt64UnaryOperation(this);
    }
}
class UInt64PostfixUnaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.op = props.op;
        this.target = props.target;
        this.wtype = props.wtype;
    }
    op;
    target;
    wtype;
    accept(visitor) {
        return visitor.visitUInt64PostfixUnaryOperation(this);
    }
}
var BigUIntPostfixUnaryOperator;
(function (BigUIntPostfixUnaryOperator) {
    BigUIntPostfixUnaryOperator["increment"] = "++";
    BigUIntPostfixUnaryOperator["decrement"] = "--";
})(BigUIntPostfixUnaryOperator || (BigUIntPostfixUnaryOperator = {}));
class BigUIntPostfixUnaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.op = props.op;
        this.target = props.target;
        this.wtype = props.wtype;
    }
    op;
    target;
    wtype;
    accept(visitor) {
        return visitor.visitBigUIntPostfixUnaryOperation(this);
    }
}
class BytesUnaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.op = props.op;
        this.expr = props.expr;
        this.wtype = props.wtype;
    }
    op;
    expr;
    wtype;
    accept(visitor) {
        return visitor.visitBytesUnaryOperation(this);
    }
}
class UInt64BinaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.left = props.left;
        this.op = props.op;
        this.right = props.right;
        this.wtype = props.wtype;
    }
    left;
    op;
    right;
    wtype;
    accept(visitor) {
        return visitor.visitUInt64BinaryOperation(this);
    }
}
class BigUIntBinaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.left = props.left;
        this.op = props.op;
        this.right = props.right;
        this.wtype = props.wtype;
    }
    left;
    op;
    right;
    wtype;
    accept(visitor) {
        return visitor.visitBigUIntBinaryOperation(this);
    }
}
class BytesBinaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.left = props.left;
        this.op = props.op;
        this.right = props.right;
        this.wtype = props.wtype;
    }
    left;
    op;
    right;
    wtype;
    accept(visitor) {
        return visitor.visitBytesBinaryOperation(this);
    }
}
var BinaryBooleanOperator;
(function (BinaryBooleanOperator) {
    BinaryBooleanOperator["and"] = "and";
    BinaryBooleanOperator["or"] = "or";
})(BinaryBooleanOperator || (BinaryBooleanOperator = {}));
class BooleanBinaryOperation extends Expression {
    constructor(props) {
        super(props);
        this.left = props.left;
        this.op = props.op;
        this.right = props.right;
        this.wtype = props.wtype;
    }
    left;
    op;
    right;
    wtype;
    accept(visitor) {
        return visitor.visitBooleanBinaryOperation(this);
    }
}
class Not extends Expression {
    constructor(props) {
        super(props);
        this.expr = props.expr;
        this.wtype = props.wtype;
    }
    expr;
    wtype;
    accept(visitor) {
        return visitor.visitNot(this);
    }
}
class UInt64AugmentedAssignment extends Statement {
    constructor(props) {
        super(props);
        this.target = props.target;
        this.op = props.op;
        this.value = props.value;
    }
    target;
    op;
    value;
    accept(visitor) {
        return visitor.visitUInt64AugmentedAssignment(this);
    }
}
class BigUIntAugmentedAssignment extends Statement {
    constructor(props) {
        super(props);
        this.target = props.target;
        this.op = props.op;
        this.value = props.value;
    }
    target;
    op;
    value;
    accept(visitor) {
        return visitor.visitBigUIntAugmentedAssignment(this);
    }
}
class BytesAugmentedAssignment extends Statement {
    constructor(props) {
        super(props);
        this.target = props.target;
        this.op = props.op;
        this.value = props.value;
    }
    target;
    op;
    value;
    accept(visitor) {
        return visitor.visitBytesAugmentedAssignment(this);
    }
}
class Emit extends Expression {
    constructor(props) {
        super(props);
        this.signature = props.signature;
        this.value = props.value;
        this.wtype = props.wtype;
    }
    signature;
    value;
    wtype;
    accept(visitor) {
        return visitor.visitEmit(this);
    }
}
class Range extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.start = props.start;
        this.stop = props.stop;
        this.step = props.step;
    }
    wtype;
    start;
    stop;
    step;
    accept(visitor) {
        return visitor.visitRange(this);
    }
}
class Enumeration extends Expression {
    constructor(props) {
        super(props);
        this.expr = props.expr;
        this.wtype = props.wtype;
    }
    expr;
    wtype;
    accept(visitor) {
        return visitor.visitEnumeration(this);
    }
}
class Reversed extends Expression {
    constructor(props) {
        super(props);
        this.expr = props.expr;
        this.wtype = props.wtype;
    }
    expr;
    wtype;
    accept(visitor) {
        return visitor.visitReversed(this);
    }
}
class ForInLoop extends Statement {
    constructor(props) {
        super(props);
        this.sequence = props.sequence;
        this.items = props.items;
        this.loopBody = props.loopBody;
    }
    sequence;
    items;
    loopBody;
    accept(visitor) {
        return visitor.visitForInLoop(this);
    }
}
class StateGet extends Expression {
    constructor(props) {
        super(props);
        this.field = props.field;
        this.default = props.default;
        this.wtype = props.wtype;
    }
    field;
    default;
    wtype;
    accept(visitor) {
        return visitor.visitStateGet(this);
    }
}
class StateGetEx extends Expression {
    constructor(props) {
        super(props);
        this.field = props.field;
        this.wtype = props.wtype;
    }
    field;
    wtype;
    accept(visitor) {
        return visitor.visitStateGetEx(this);
    }
}
class StateExists extends Expression {
    constructor(props) {
        super(props);
        this.field = props.field;
        this.wtype = props.wtype;
    }
    field;
    wtype;
    accept(visitor) {
        return visitor.visitStateExists(this);
    }
}
class StateDelete extends Expression {
    constructor(props) {
        super(props);
        this.field = props.field;
        this.wtype = props.wtype;
    }
    field;
    wtype;
    accept(visitor) {
        return visitor.visitStateDelete(this);
    }
}
class NewStruct extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
        this.values = props.values;
    }
    wtype;
    values;
    accept(visitor) {
        return visitor.visitNewStruct(this);
    }
}
class RootNode extends Node {
    constructor(props) {
        super(props);
    }
}
class SubroutineArgument {
    constructor(props) {
        this.name = props.name;
        this.sourceLocation = props.sourceLocation;
        this.wtype = props.wtype;
    }
    name;
    sourceLocation;
    wtype;
}
class MethodDocumentation {
    constructor(props) {
        this.description = props.description;
        this.args = props.args;
        this.returns = props.returns;
    }
    description;
    args;
    returns;
}
class _Function extends Node {
    constructor(props) {
        super(props);
        this.args = props.args;
        this.returnType = props.returnType;
        this.body = props.body;
        this.documentation = props.documentation;
        this.inline = props.inline;
    }
    args;
    returnType;
    body;
    documentation;
    inline;
}
class Subroutine extends classes(_Function, RootNode) {
    constructor(props) {
        super([props], [props]);
        this.id = props.id;
        this.name = props.name;
    }
    id;
    name;
    accept(visitor) {
        return visitor.visitSubroutine(this);
    }
}
class ContractMemberNode extends Node {
    constructor(props) {
        super(props);
    }
}
class ContractMethod extends classes(_Function, ContractMemberNode) {
    constructor(props) {
        super([props], [props]);
        this.cref = props.cref;
        this.memberName = props.memberName;
        this.arc4MethodConfig = props.arc4MethodConfig;
    }
    cref;
    memberName;
    arc4MethodConfig;
    accept(visitor) {
        return visitor.visitContractMethod(this);
    }
}
var AppStorageKind;
(function (AppStorageKind) {
    AppStorageKind[AppStorageKind["appGlobal"] = 1] = "appGlobal";
    AppStorageKind[AppStorageKind["accountLocal"] = 2] = "accountLocal";
    AppStorageKind[AppStorageKind["box"] = 3] = "box";
})(AppStorageKind || (AppStorageKind = {}));
class AppStorageDefinition extends ContractMemberNode {
    constructor(props) {
        super(props);
        this.memberName = props.memberName;
        this.kind = props.kind;
        this.storageWtype = props.storageWtype;
        this.keyWtype = props.keyWtype;
        this.key = props.key;
        this.description = props.description;
    }
    memberName;
    kind;
    storageWtype;
    keyWtype;
    key;
    description;
    accept(visitor) {
        return visitor.visitAppStorageDefinition(this);
    }
}
class LogicSignature extends RootNode {
    constructor(props) {
        super(props);
        this.id = props.id;
        this.shortName = props.shortName;
        this.program = props.program;
        this.docstring = props.docstring;
        this.reservedScratchSpace = props.reservedScratchSpace;
        this.avmVersion = props.avmVersion;
    }
    id;
    shortName;
    program;
    docstring;
    reservedScratchSpace;
    avmVersion;
    accept(visitor) {
        return visitor.visitLogicSignature(this);
    }
}
class CompiledContract extends Expression {
    constructor(props) {
        super(props);
        this.contract = props.contract;
        this.allocationOverrides = props.allocationOverrides;
        this.prefix = props.prefix;
        this.templateVariables = props.templateVariables;
    }
    contract;
    allocationOverrides;
    prefix;
    templateVariables;
    accept(visitor) {
        return visitor.visitCompiledContract(this);
    }
}
class CompiledLogicSig extends Expression {
    constructor(props) {
        super(props);
        this.logicSig = props.logicSig;
        this.prefix = props.prefix;
        this.templateVariables = props.templateVariables;
    }
    logicSig;
    prefix;
    templateVariables;
    accept(visitor) {
        return visitor.visitCompiledLogicSig(this);
    }
}
class StateTotals {
    constructor(props) {
        this.globalUints = props.globalUints;
        this.localUints = props.localUints;
        this.globalBytes = props.globalBytes;
        this.localBytes = props.localBytes;
    }
    globalUints;
    localUints;
    globalBytes;
    localBytes;
}
class ARC4Router extends Expression {
    constructor(props) {
        super(props);
        this.wtype = props.wtype;
    }
    wtype;
    accept(visitor) {
        return visitor.visitARC4Router(this);
    }
}
class Contract extends RootNode {
    constructor(props) {
        super(props);
        this.id = props.id;
        this.name = props.name;
        this.description = props.description;
        this.methodResolutionOrder = props.methodResolutionOrder;
        this.approvalProgram = props.approvalProgram;
        this.clearProgram = props.clearProgram;
        this.methods = props.methods;
        this.appState = props.appState;
        this.stateTotals = props.stateTotals;
        this.reservedScratchSpace = props.reservedScratchSpace;
        this.avmVersion = props.avmVersion;
    }
    id;
    name;
    description;
    methodResolutionOrder;
    approvalProgram;
    clearProgram;
    methods;
    appState;
    stateTotals;
    reservedScratchSpace;
    avmVersion;
    accept(visitor) {
        return visitor.visitContract(this);
    }
}
var ARC4CreateOption;
(function (ARC4CreateOption) {
    ARC4CreateOption[ARC4CreateOption["allow"] = 1] = "allow";
    ARC4CreateOption[ARC4CreateOption["require"] = 2] = "require";
    ARC4CreateOption[ARC4CreateOption["disallow"] = 3] = "disallow";
})(ARC4CreateOption || (ARC4CreateOption = {}));
class ARC4BareMethodConfig {
    constructor(props) {
        this.sourceLocation = props.sourceLocation;
        this.allowedCompletionTypes = props.allowedCompletionTypes;
        this.create = props.create;
    }
    sourceLocation;
    allowedCompletionTypes;
    create;
}
class ABIMethodArgConstantDefault {
    constructor(props) {
        this.value = props.value;
    }
    value;
}
class ABIMethodArgMemberDefault {
    constructor(props) {
        this.name = props.name;
    }
    name;
}
class ARC4ABIMethodConfig {
    constructor(props) {
        this.sourceLocation = props.sourceLocation;
        this.allowedCompletionTypes = props.allowedCompletionTypes;
        this.create = props.create;
        this.name = props.name;
        this.readonly = props.readonly;
        this.defaultArgs = props.defaultArgs;
    }
    sourceLocation;
    allowedCompletionTypes;
    create;
    name;
    readonly;
    defaultArgs;
}
const concreteNodes = {
    expressionStatement: ExpressionStatement,
    block: Block,
    goto: Goto,
    ifElse: IfElse,
    switch: Switch,
    whileLoop: WhileLoop,
    loopExit: LoopExit,
    loopContinue: LoopContinue,
    returnStatement: ReturnStatement,
    assertExpression: AssertExpression,
    integerConstant: IntegerConstant,
    decimalConstant: DecimalConstant,
    boolConstant: BoolConstant,
    bytesConstant: BytesConstant,
    stringConstant: StringConstant,
    voidConstant: VoidConstant,
    templateVar: TemplateVar,
    methodConstant: MethodConstant,
    addressConstant: AddressConstant,
    aRC4Encode: ARC4Encode,
    copy: Copy,
    arrayConcat: ArrayConcat,
    arrayExtend: ArrayExtend,
    arrayPop: ArrayPop,
    arrayReplace: ArrayReplace,
    aRC4Decode: ARC4Decode,
    intrinsicCall: IntrinsicCall,
    createInnerTransaction: CreateInnerTransaction,
    updateInnerTransaction: UpdateInnerTransaction,
    groupTransactionReference: GroupTransactionReference,
    checkedMaybe: CheckedMaybe,
    tupleExpression: TupleExpression,
    tupleItemExpression: TupleItemExpression,
    varExpression: VarExpression,
    innerTransactionField: InnerTransactionField,
    submitInnerTransaction: SubmitInnerTransaction,
    fieldExpression: FieldExpression,
    indexExpression: IndexExpression,
    sliceExpression: SliceExpression,
    intersectionSliceExpression: IntersectionSliceExpression,
    appStateExpression: AppStateExpression,
    appAccountStateExpression: AppAccountStateExpression,
    boxValueExpression: BoxValueExpression,
    singleEvaluation: SingleEvaluation,
    reinterpretCast: ReinterpretCast,
    newArray: NewArray,
    arrayLength: ArrayLength,
    conditionalExpression: ConditionalExpression,
    assignmentStatement: AssignmentStatement,
    assignmentExpression: AssignmentExpression,
    numericComparisonExpression: NumericComparisonExpression,
    bytesComparisonExpression: BytesComparisonExpression,
    subroutineID: SubroutineID,
    instanceMethodTarget: InstanceMethodTarget,
    instanceSuperMethodTarget: InstanceSuperMethodTarget,
    contractMethodTarget: ContractMethodTarget,
    callArg: CallArg,
    subroutineCallExpression: SubroutineCallExpression,
    puyaLibData: PuyaLibData,
    puyaLibCall: PuyaLibCall,
    uInt64UnaryOperation: UInt64UnaryOperation,
    uInt64PostfixUnaryOperation: UInt64PostfixUnaryOperation,
    bigUIntPostfixUnaryOperation: BigUIntPostfixUnaryOperation,
    bytesUnaryOperation: BytesUnaryOperation,
    uInt64BinaryOperation: UInt64BinaryOperation,
    bigUIntBinaryOperation: BigUIntBinaryOperation,
    bytesBinaryOperation: BytesBinaryOperation,
    booleanBinaryOperation: BooleanBinaryOperation,
    not: Not,
    uInt64AugmentedAssignment: UInt64AugmentedAssignment,
    bigUIntAugmentedAssignment: BigUIntAugmentedAssignment,
    bytesAugmentedAssignment: BytesAugmentedAssignment,
    emit: Emit,
    range: Range,
    enumeration: Enumeration,
    reversed: Reversed,
    forInLoop: ForInLoop,
    stateGet: StateGet,
    stateGetEx: StateGetEx,
    stateExists: StateExists,
    stateDelete: StateDelete,
    newStruct: NewStruct,
    subroutineArgument: SubroutineArgument,
    methodDocumentation: MethodDocumentation,
    subroutine: Subroutine,
    contractMethod: ContractMethod,
    appStorageDefinition: AppStorageDefinition,
    logicSignature: LogicSignature,
    compiledContract: CompiledContract,
    compiledLogicSig: CompiledLogicSig,
    stateTotals: StateTotals,
    aRC4Router: ARC4Router,
    contract: Contract,
    aRC4BareMethodConfig: ARC4BareMethodConfig,
    aBIMethodArgConstantDefault: ABIMethodArgConstantDefault,
    aBIMethodArgMemberDefault: ABIMethodArgMemberDefault,
    aRC4ABIMethodConfig: ARC4ABIMethodConfig,
    uInt64Constant: IntegerConstant,
    bigUIntConstant: IntegerConstant,
};

const constantEvaluation = {
    booleanBinary(op, left, right) {
        switch (op) {
            case BinaryBooleanOperator.and:
                return left && right;
            case BinaryBooleanOperator.or:
                return left || right;
        }
    },
    uint64Binary(op, left, right) {
        switch (op) {
            case UInt64BinaryOperator.add:
                return left + right;
            case UInt64BinaryOperator.sub:
                return left - right;
            case UInt64BinaryOperator.mult:
                return left * right;
            case UInt64BinaryOperator.floorDiv:
                return left / right;
            case UInt64BinaryOperator.mod:
                return left % right;
            case UInt64BinaryOperator.pow:
                return left ** right;
            case UInt64BinaryOperator.lshift:
                return left << right;
            case UInt64BinaryOperator.rshift:
                return left >> right;
            case UInt64BinaryOperator.bitOr:
                return left | right;
            case UInt64BinaryOperator.bitXor:
                return left ^ right;
            case UInt64BinaryOperator.bitAnd:
                return left & right;
        }
    },
    biguintBinary(op, left, right) {
        switch (op) {
            case BigUIntBinaryOperator.add:
                return left + right;
            case BigUIntBinaryOperator.sub:
                return left - right;
            case BigUIntBinaryOperator.mult:
                return left * right;
            case BigUIntBinaryOperator.floorDiv:
                return left / right;
            case BigUIntBinaryOperator.mod:
                return left % right;
            case BigUIntBinaryOperator.bitOr:
                return left | right;
            case BigUIntBinaryOperator.bitXor:
                return left ^ right;
            case BigUIntBinaryOperator.bitAnd:
                return left & right;
        }
    },
};

var WInnerTransactionFields = wtypes.WInnerTransactionFields;
var WTuple = wtypes.WTuple;
const explicitNodeFactory = {
    voidConstant(props) {
        return new VoidConstant({
            ...props,
            wtype: wtypes.voidWType,
        });
    },
    bytesConstant(props) {
        return new BytesConstant({
            encoding: BytesEncoding.unknown,
            wtype: wtypes.bytesWType,
            ...props,
        });
    },
    stringConstant(props) {
        return new StringConstant({
            ...props,
            wtype: props.wtype ?? wtypes.stringWType,
        });
    },
    uInt64Constant({ value, tealAlias, sourceLocation, }) {
        if (value < 0n || value >= 2n ** 64n) {
            throw new CodeError(`uint64 overflow or underflow: ${value}`, { sourceLocation });
        }
        return new IntegerConstant({
            value,
            sourceLocation,
            wtype: wtypes.uint64WType,
            tealAlias: tealAlias ?? null,
        });
    },
    bigUIntConstant({ value, sourceLocation }) {
        if (value < 0n || value >= 2n ** 512n) {
            throw new CodeError(`biguint overflow or underflow: ${value}`, { sourceLocation });
        }
        return new IntegerConstant({
            value,
            sourceLocation,
            wtype: wtypes.biguintWType,
            tealAlias: null,
        });
    },
    not(props) {
        return new Not({
            ...props,
            wtype: wtypes.boolWType,
        });
    },
    uInt64BinaryOperation(props) {
        if (props.left instanceof IntegerConstant && props.right instanceof IntegerConstant) {
            invariant(props.left.wtype.equals(wtypes.uint64WType) && props.right.wtype.equals(wtypes.uint64WType), 'left & right must be uint64');
            return new IntegerConstant({
                value: constantEvaluation.uint64Binary(props.op, props.left.value, props.right.value),
                tealAlias: null,
                sourceLocation: props.sourceLocation,
                wtype: wtypes.uint64WType,
            });
        }
        return new UInt64BinaryOperation({
            ...props,
            wtype: wtypes.uint64WType,
        });
    },
    bigUIntBinaryOperation(props) {
        if (props.left instanceof IntegerConstant && props.right instanceof IntegerConstant) {
            invariant(props.left.wtype.equals(wtypes.biguintWType) && props.right.wtype.equals(wtypes.biguintWType), 'left & right must be biguint');
            return new IntegerConstant({
                value: constantEvaluation.biguintBinary(props.op, props.left.value, props.right.value),
                tealAlias: null,
                sourceLocation: props.sourceLocation,
                wtype: wtypes.biguintWType,
            });
        }
        return new BigUIntBinaryOperation({
            ...props,
            wtype: wtypes.biguintWType,
        });
    },
    numericComparisonExpression(props) {
        return new NumericComparisonExpression({
            ...props,
            wtype: wtypes.boolWType,
        });
    },
    bytesComparisonExpression(props) {
        codeInvariant(props.lhs.wtype.equals(props.rhs.wtype), `Operands type mismatch. lhs is ${props.lhs.wtype}, rhs is ${props.rhs.wtype}`, props.sourceLocation);
        return new BytesComparisonExpression({
            ...props,
            wtype: wtypes.boolWType,
        });
    },
    boolConstant(props) {
        return new BoolConstant({
            ...props,
            wtype: props.wtype ?? wtypes.boolWType,
        });
    },
    singleEvaluation({ source }) {
        return new SingleEvaluation({
            id: Symbol(),
            sourceLocation: source.sourceLocation,
            wtype: source.wtype,
            source,
        });
    },
    expressionStatement({ expr }) {
        if (expr instanceof AssignmentExpression) {
            return new AssignmentStatement({
                ...expr,
            });
        }
        return new ExpressionStatement({
            expr,
            sourceLocation: expr.sourceLocation,
        });
    },
    block({ sourceLocation, comment, label }, ...statements) {
        return new Block({
            body: statements.flat(),
            sourceLocation,
            comment: comment ?? null,
            label: label ?? null,
        });
    },
    booleanBinaryOperation(props) {
        if (props.left instanceof BoolConstant && props.right instanceof BoolConstant) {
            return new BoolConstant({
                value: constantEvaluation.booleanBinary(props.op, props.left.value, props.right.value),
                sourceLocation: props.sourceLocation,
                wtype: wtypes.boolWType,
            });
        }
        return new BooleanBinaryOperation({
            ...props,
            wtype: wtypes.boolWType,
        });
    },
    assignmentExpression({ target, value, sourceLocation, }) {
        codeInvariant(target.wtype.equals(value.wtype), `Assignment target type ${target.wtype} must match assigned value type ${value.wtype}`);
        return new AssignmentExpression({
            target,
            value,
            wtype: value.wtype,
            sourceLocation,
        });
    },
    assignmentStatement({ target, value, sourceLocation, }) {
        codeInvariant(target.wtype.equals(value.wtype), `Assignment target type ${target.wtype} must match assigned value type ${value.wtype}`);
        return new AssignmentStatement({
            target,
            value,
            sourceLocation,
        });
    },
    tupleExpression(props) {
        return new TupleExpression({
            ...props,
            wtype: props.wtype ?? new wtypes.WTuple({ types: props.items.map((i) => i.wtype), immutable: true }),
        });
    },
    methodDocumentation(props) {
        return new MethodDocumentation({
            args: props?.args ?? new Map(),
            description: props?.description ?? null,
            returns: props?.returns ?? null,
        });
    },
    copy({ value, sourceLocation }) {
        return new Copy({
            value,
            sourceLocation,
            wtype: value.wtype,
        });
    },
    checkedMaybe({ expr, comment }) {
        invariant(expr.wtype instanceof wtypes.WTuple && expr.wtype.types.length === 2, 'expr WType must be WTuple of 2');
        invariant(expr.wtype.types[1].equals(wtypes.boolWType), '2nd tuple item type must be bool');
        return new CheckedMaybe({
            expr,
            comment,
            sourceLocation: expr.sourceLocation,
            wtype: expr.wtype.types[0],
        });
    },
    tupleItemExpression(props) {
        invariant(instanceOfAny(props.base.wtype, wtypes.WTuple, wtypes.ARC4Tuple) && props.base.wtype.types.length > Number(props.index), 'expr.base must be tuple type with length greater than index');
        return new TupleItemExpression({
            ...props,
            wtype: props.base.wtype.types[Number(props.index)],
        });
    },
    reinterpretCast({ expr, wtype, sourceLocation }) {
        if (expr instanceof BytesConstant) {
            return new BytesConstant({
                ...expr,
                wtype,
                sourceLocation,
            });
        }
        return new ReinterpretCast({
            expr,
            wtype,
            sourceLocation,
        });
    },
    arrayLength({ array, sourceLocation }) {
        return new ArrayLength({
            array,
            sourceLocation,
            wtype: wtypes.uint64WType,
        });
    },
    arrayReplace({ base, index, value, sourceLocation, }) {
        invariant(base.wtype instanceof wtypes.StackArray, 'base must have wtype of StackArray', base.sourceLocation);
        return new ArrayReplace({
            base,
            index,
            value,
            sourceLocation,
            wtype: base.wtype,
        });
    },
    submitInnerTransaction({ itxns, sourceLocation }) {
        const itxnWTypes = itxns.map(({ wtype }, index) => {
            invariant(wtype instanceof WInnerTransactionFields, `WType at index ${index} must be WInnerTransactionFields with type`, sourceLocation);
            return wtype.transactionType === null ? anyItxnType.wtype : getInnerTransactionType(wtype.transactionType).wtype;
        });
        return new SubmitInnerTransaction({
            itxns,
            sourceLocation,
            wtype: itxnWTypes.length === 1 ? itxnWTypes[0] : new WTuple({ types: itxnWTypes, immutable: true }),
        });
    },
};
function isNodeName(value) {
    return typeof value === 'string' && Object.hasOwn(concreteNodes, value);
}
function hasExplicitFactory(value) {
    return Object.hasOwn(explicitNodeFactory, value);
}
const nodeFactory = new Proxy({}, {
    get(_, property) {
        invariant(isNodeName(property), 'Property must be the name of a concrete node');
        if (hasExplicitFactory(property)) {
            return explicitNodeFactory[property];
        }
        return (props) => new concreteNodes[property](props);
    },
});

const UintNClass = new LibClassType({
    name: 'UintN',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const ByteClass = new LibClassType({
    name: 'Byte',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const UintN8Class = new LibClassType({
    name: 'UintN8',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const UintN16Class = new LibClassType({
    name: 'UintN16',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const UintN32Class = new LibClassType({
    name: 'UintN32',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const UintN64Class = new LibClassType({
    name: 'UintN64',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const UintN128Class = new LibClassType({
    name: 'UintN128',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const UintN256Class = new LibClassType({
    name: 'UintN256',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
class ARC4EncodedType extends PType {
    get fixedByteSize() {
        return this.fixedBitSize === null ? null : ARC4EncodedType.bitsToBytes(this.fixedBitSize);
    }
    /**
     * Calculate fixed the number of bits required to store a sequence of ARC4 types using ARC4's bit-packing technique for consecutive booleans.
     *
     * Returns `null` if the sequence contains a dynamically sized type
     * @param types The sequence of types being encoded
     */
    static calculateFixedBitSize(types) {
        return types.reduce((acc, cur) => {
            if (acc === null || cur.fixedBitSize === null)
                return null;
            if (cur.fixedBitSize === 1n) {
                return acc + cur.fixedBitSize;
            }
            else {
                return this.roundBitsUpToNearestByte(acc) + this.roundBitsUpToNearestByte(cur.fixedBitSize);
            }
        }, 0n);
    }
    /**
     * Get the number of bytes required to represent n bits
     * @param n The number of bits which need representing
     */
    static bitsToBytes(n) {
        return (n + 7n) / 8n;
    }
    static roundBitsUpToNearestByte(bits) {
        return this.bitsToBytes(bits) * 8n;
    }
}
class ARC4ArrayType extends ARC4EncodedType {
    elementType;
    constructor({ elementType }) {
        super();
        this.elementType = elementType;
    }
}
class ARC4InstanceType extends ARC4EncodedType {
    wtype;
    name;
    module = Constants.moduleNames.algoTs.arc4.encodedTypes;
    singleton = false;
    nativeType;
    fixedBitSize;
    constructor({ wtype, nativeType, name, fixedBitSize, }) {
        super();
        this.wtype = wtype;
        this.name = name;
        this.nativeType = nativeType;
        this.fixedBitSize = fixedBitSize;
    }
}
const ARC4BoolClass = new LibClassType({
    name: 'Bool',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const ARC4StrClass = new LibClassType({
    name: 'Str',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const arc4BooleanType = new ARC4InstanceType({
    name: 'Bool',
    wtype: wtypes.arc4BooleanWType,
    nativeType: boolPType,
    fixedBitSize: 1n,
});
const arc4StringType = new ARC4InstanceType({
    name: 'Str',
    wtype: wtypes.arc4StringAliasWType,
    nativeType: stringPType,
    fixedBitSize: null,
});
class ARC4StructClass extends PType {
    name;
    module;
    singleton = true;
    instanceType;
    sourceLocation;
    wtype = undefined;
    constructor({ name, module, instanceType, sourceLocation, }) {
        super();
        this.name = name;
        this.module = module;
        this.sourceLocation = sourceLocation;
        this.instanceType = instanceType;
    }
    static fromStructType(ptype) {
        return new ARC4StructClass({
            ...ptype,
            instanceType: ptype,
        });
    }
}
class ARC4StructType extends ARC4EncodedType {
    name;
    module;
    description;
    singleton = false;
    fields;
    sourceLocation;
    frozen;
    fixedBitSize;
    constructor({ name, frozen, module, fields, description, sourceLocation, }) {
        super();
        this.name = name;
        this.module = module;
        this.frozen = frozen;
        this.fields = fields;
        this.description = description;
        this.sourceLocation = sourceLocation;
        this.fixedBitSize = ARC4EncodedType.calculateFixedBitSize(Object.values(fields));
    }
    get nativeType() {
        return ObjectPType.anonymous(this.fields);
    }
    get wtype() {
        return new wtypes.ARC4Struct({
            name: this.name,
            fields: Object.fromEntries(Object.entries(this.fields).map(([f, t]) => [f, t.wtype])),
            sourceLocation: this.sourceLocation,
            desc: this.description ?? null,
            frozen: this.frozen,
        });
    }
    get signature() {
        return `${this.name}${this.wtype.arc4Name}`;
    }
}
const arc4StructBaseType = new ARC4StructType({
    name: 'StructBase',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
    fields: {},
    description: undefined,
    frozen: false,
});
const Arc4TupleClass = new LibClassType({
    name: 'Tuple',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const Arc4TupleGeneric = new GenericPType({
    name: 'Tuple',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
    parameterise(ptypes) {
        codeInvariant(ptypes.length, `${this.name} expects 1 generic parameter`);
        codeInvariant(ptypes[0] instanceof TuplePType, `${this.name} generic parameter must be a native tuple type`);
        const encodedTypes = ptypes[0].items.map((itemType, index) => {
            codeInvariant(itemType instanceof ARC4EncodedType, `Item ${index} of ARC4 Tuple must be an ARC4 encoded type`);
            return itemType;
        });
        return new ARC4TupleType({
            types: encodedTypes,
        });
    },
});
class ARC4TupleType extends ARC4EncodedType {
    name = 'Tuple';
    module = Constants.moduleNames.algoTs.arc4.encodedTypes;
    singleton = false;
    items;
    sourceLocation;
    fixedBitSize;
    nativeType;
    constructor({ types, sourceLocation }) {
        super();
        this.items = types;
        this.sourceLocation = sourceLocation;
        this.nativeType = new TuplePType({ items: this.items });
        this.fixedBitSize = ARC4EncodedType.calculateFixedBitSize(types);
    }
    get wtype() {
        return new wtypes.ARC4Tuple({
            types: this.items.map((t) => t.wtype),
            sourceLocation: this.sourceLocation,
        });
    }
}
const UintNGeneric = new GenericPType({
    name: 'UintN',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
    parameterise(typeArgs) {
        codeInvariant(typeArgs.length === 1, 'UintNType type expects exactly one type parameter');
        const [size] = typeArgs;
        codeInvariant(size instanceof NumericLiteralPType && size.literalValue, `Generic type param for UintNType must be a literal number. Inferred type is ${size.name}`);
        return new UintNType({ n: size.literalValue });
    },
});
class UintNType extends ARC4EncodedType {
    module = Constants.moduleNames.algoTs.arc4.encodedTypes;
    n;
    name;
    singleton = false;
    wtype;
    get fixedBitSize() {
        return this.n;
    }
    get nativeType() {
        return this.n <= 64n ? uint64PType : biguintPType;
    }
    constructor({ n, wtype, name }) {
        super();
        codeInvariant(n >= 8n && n <= 512n && n % 8n === 0n, 'n must be between 8 and 512, and a multiple of 8');
        this.n = n;
        this.name = name ?? `UintN<${n}>`;
        this.wtype = wtype ?? new wtypes.ARC4UIntN({ n: this.n });
    }
}
const UFixedNxMClass = new LibClassType({
    name: 'UFixedNxM',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const UFixedNxMGeneric = new GenericPType({
    name: UFixedNxMClass.name,
    module: UFixedNxMClass.module,
    parameterise(typeArgs) {
        codeInvariant(typeArgs.length === 2, `${this.name} expects exactly 2 generic type parameters`);
        const [n, m] = typeArgs;
        codeInvariant(n instanceof NumericLiteralPType && n.literalValue, `Generic type param 'N' for ${this.name}  must be a literal number. Inferred type is ${n.name}`);
        codeInvariant(m instanceof NumericLiteralPType && m.literalValue, `Generic type param 'M' for UintNType must be a literal number. Inferred type is ${m.name}`);
        return new UFixedNxMType({
            n: n.literalValue,
            m: m.literalValue,
        });
    },
});
class UFixedNxMType extends ARC4EncodedType {
    module = Constants.moduleNames.algoTs.arc4.encodedTypes;
    n;
    m;
    name;
    singleton = false;
    wtype;
    get fixedBitSize() {
        return this.n;
    }
    get nativeType() {
        return this.n <= 64n ? uint64PType : biguintPType;
    }
    constructor({ n, m }) {
        super();
        codeInvariant(n >= 8n && n <= 512n && n % 8n === 0n, 'n must be between 8 and 512, and a multiple of 8');
        codeInvariant(m >= 1n && m <= 160n, 'm must be between 1 and 160');
        this.n = n;
        this.m = m;
        this.name = `${UFixedNxMClass.name}<${n}, ${m}>`;
        this.wtype = new wtypes.ARC4UFixedNxM({ n: this.n, m: this.m });
    }
}
const arc4ByteAlias = new UintNType({ n: 8n, wtype: wtypes.arc4ByteAliasWType, name: 'Byte' });
const DynamicArrayConstructor = new LibClassType({
    name: 'DynamicArray',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const DynamicArrayGeneric = new GenericPType({
    name: 'DynamicArray',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
    parameterise: (typeArgs) => {
        codeInvariant(typeArgs.length === 1, 'DynamicArray type expects exactly one type parameter');
        const [elementType] = typeArgs;
        codeInvariant(elementType instanceof ARC4EncodedType, `Generic type param for DynamicArray must be an ARC4 encoded type. Inferred type is ${elementType.name}`);
        return new DynamicArrayType({ elementType: elementType });
    },
});
class DynamicArrayType extends ARC4ArrayType {
    module = Constants.moduleNames.algoTs.arc4.encodedTypes;
    immutable;
    name;
    singleton = false;
    sourceLocation;
    nativeType;
    wtype;
    fixedBitSize = null;
    constructor({ elementType, nativeType, sourceLocation, name, immutable, }) {
        super({
            elementType,
        });
        this.immutable = immutable ?? false;
        this.nativeType = nativeType ?? new ArrayPType({ elementType });
        this.name = name ?? `DynamicArray<${elementType}>`;
        this.sourceLocation = sourceLocation;
        this.wtype = new wtypes.ARC4DynamicArray({
            elementType: this.elementType.wtype,
            sourceLocation: this.sourceLocation,
            immutable: this.immutable,
            nativeType: this.nativeType.wtype,
        });
    }
}
const StaticArrayConstructor = new LibClassType({
    name: 'StaticArray',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const StaticArrayGeneric = new GenericPType({
    name: 'StaticArray',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
    parameterise: (typeArgs) => {
        codeInvariant(typeArgs.length === 2, 'StaticArray type expects exactly one type parameters');
        const [elementType, arraySize] = typeArgs;
        codeInvariant(elementType instanceof ARC4EncodedType, `Element type generic type param for StaticArray must be an ARC4 encoded type. Inferred type is ${elementType.name}`);
        codeInvariant(arraySize instanceof NumericLiteralPType, `Array size generic type param for StaticArray must be a literal number. Inferred type is ${arraySize.name}`);
        return new StaticArrayType({ arraySize: arraySize.literalValue, elementType });
    },
});
class StaticArrayType extends ARC4ArrayType {
    module = Constants.moduleNames.algoTs.arc4.encodedTypes;
    arraySize;
    immutable;
    name;
    singleton = false;
    sourceLocation;
    wtype;
    nativeType;
    fixedBitSize;
    constructor({ elementType, arraySize, sourceLocation, wtype, name, immutable, nativeType, }) {
        codeInvariant(arraySize >= 0, 'StaticArray length must be greater than or equal to 0');
        super({ elementType });
        this.immutable = immutable ?? false;
        this.arraySize = arraySize;
        this.name = name ?? `StaticArray<${elementType}, ${arraySize}>`;
        this.sourceLocation = sourceLocation;
        this.nativeType = nativeType ?? new TuplePType({ items: new Array(Number(arraySize)).fill(elementType) });
        this.wtype =
            wtype ??
                new wtypes.ARC4StaticArray({
                    elementType: this.elementType.wtype,
                    arraySize: this.arraySize,
                    immutable: this.immutable,
                    nativeType: nativeType?.wtype,
                });
        this.fixedBitSize = ARC4EncodedType.calculateFixedBitSize(new Array(Number(arraySize)).fill(elementType));
    }
}
const arc4AddressAlias = new StaticArrayType({
    arraySize: BigInt(Constants.algo.addressLength),
    elementType: arc4ByteAlias,
    wtype: wtypes.arc4AddressAliasWType,
    nativeType: accountPType,
    immutable: true,
    name: 'Address',
});
const AddressClass = new LibClassType({
    name: 'Address',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const StaticBytesGeneric = new GenericPType({
    name: 'StaticBytes',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
    parameterise: (typeArgs) => {
        codeInvariant(typeArgs.length === 1, 'StaticBytes type expects exactly one type parameter');
        const [length] = typeArgs;
        codeInvariant(length instanceof NumericLiteralPType, `Length generic type param for StaticBytes must be a literal number. Inferred type is ${length.name}`);
        return new StaticBytesType({
            length: length.literalValue,
        });
    },
});
const StaticBytesConstructor = new LibClassType({
    name: 'StaticBytes',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
class StaticBytesType extends StaticArrayType {
    constructor({ length }) {
        codeInvariant(length >= 0, 'StaticBytes length must be greater than or equal to 0');
        super({
            name: `StaticBytes<${length}>`,
            immutable: true,
            elementType: arc4ByteAlias,
            arraySize: length,
            nativeType: bytesPType,
        });
    }
}
const DynamicBytesConstructor = new LibClassType({
    name: 'DynamicBytes',
    module: Constants.moduleNames.algoTs.arc4.encodedTypes,
});
const DynamicBytesType = new DynamicArrayType({
    name: `DynamicBytes`,
    immutable: true,
    elementType: arc4ByteAlias,
    nativeType: bytesPType,
});
const interpretAsArc4Function = new LibFunctionType({
    name: 'interpretAsArc4',
    module: Constants.moduleNames.algoTs.arc4.index,
});
const encodeArc4Function = new LibFunctionType({
    name: 'encodeArc4',
    module: Constants.moduleNames.algoTs.arc4.index,
});
const arc4EncodedLengthFunction = new LibFunctionType({
    name: 'arc4EncodedLength',
    module: Constants.moduleNames.algoTs.arc4.index,
});
const decodeArc4Function = new LibFunctionType({
    name: 'decodeArc4',
    module: Constants.moduleNames.algoTs.arc4.index,
});
const methodSelectorFunction = new LibFunctionType({
    name: 'methodSelector',
    module: Constants.moduleNames.algoTs.arc4.index,
});
const abiCallFunction = new LibFunctionType({
    name: 'abiCall',
    module: Constants.moduleNames.algoTs.arc4.c2c,
});
const compileArc4Function = new LibFunctionType({
    name: 'compileArc4',
    module: Constants.moduleNames.algoTs.arc4.c2c,
});
const ContractProxyGeneric = new GenericPType({
    name: 'ContractProxy',
    module: Constants.moduleNames.algoTs.arc4.c2c,
    parameterise(args) {
        invariant(args.length === 1, 'ContractProxy expects exactly 1 type arg');
        const [typeArg] = args;
        invariant(typeArg instanceof ContractClassPType && typeArg.isARC4, 'Contract Proxy generic type arg must extend arc4 Contract type');
        return new ContractProxyType({ contractType: typeArg });
    },
});
class ContractProxyType extends PType {
    name;
    module = Constants.moduleNames.algoTs.arc4.c2c;
    wtype;
    singleton = false;
    contractType;
    constructor({ contractType }) {
        super();
        this.name = `ContractProxy<${contractType.name}>`;
        this.wtype = compiledContractType.wtype;
        this.contractType = contractType;
    }
}
const TypedApplicationCallResponseGeneric = new GenericPType({
    name: 'TypedApplicationCallResponse',
    module: Constants.moduleNames.algoTs.arc4.c2c,
    parameterise(args) {
        invariant(args.length === 1, 'TypedApplicationCallResponse expects exactly 1 type arg');
        const [typeArg] = args;
        return new TypedApplicationCallResponseType({ returnValue: typeArg });
    },
});
class TypedApplicationCallResponseType extends ObjectPType {
    name;
    module = Constants.moduleNames.algoTs.arc4.c2c;
    singleton = false;
    returnValue;
    constructor({ returnValue }) {
        super({
            properties: returnValue.equals(voidPType)
                ? { itxn: applicationItxnType }
                : {
                    itxn: applicationItxnType,
                    returnValue,
                },
        });
        this.name = `TypedApplicationCallResponseType<${returnValue.name}>`;
        this.returnValue = returnValue;
    }
}

/**
 * For a given ptype, return the equivalent ABI compatible type - or error if there is no compatible type
 * @param ptype The type of the parameter
 * @param direction The direction of the parameter (in for method args, out for method returns)
 * @param sourceLocation The location of the method or parameter, for use in error metadata
 */
function ptypeToAbiPType(ptype, direction, sourceLocation) {
    if (ptype instanceof ARC4EncodedType)
        return ptype;
    if (ptype instanceof GroupTransactionPType) {
        codeInvariant(direction === 'in', `${ptype.name} cannot be used as an ABI return type`, sourceLocation);
        return ptype;
    }
    if (ptype.equals(applicationPType) || ptype.equals(accountPType) || ptype.equals(assetPType)) {
        codeInvariant(direction === 'in', `${ptype.name} cannot be used as an ABI return type`, sourceLocation);
        return ptype;
    }
    if (ptype.equals(voidPType))
        return voidPType;
    if (isArc4EncodableType(ptype)) {
        return ptypeToArc4EncodedType(ptype, sourceLocation);
    }
    throw new CodeError(`${ptype} cannot be used as an ABI ${direction === 'in' ? 'param' : 'return'} type`, { sourceLocation });
}
/**
 * Generate a methodConstant node for the given function, making use of the ARC4ABIMethodConfig
 * @param functionType The function ptype
 * @param arc4Config ARC4 method config
 * @param sourceLocation The source location of the code generating the constant,
 */
function buildArc4MethodConstant(functionType, arc4Config, sourceLocation) {
    const params = functionType.parameters.map(([_, ptype]) => getABITypeName(ptype, 'in', sourceLocation)).join(',');
    const returnType = getABITypeName(functionType.returnType, 'out', sourceLocation);
    return nodeFactory.methodConstant({
        value: `${arc4Config.name}(${params})${returnType}`,
        wtype: wtypes.bytesWType,
        sourceLocation,
    });
}
/**
 * Get the ARC4 type name for a ptype, or throw if the ptype is not usable in an ABI method.
 * @param ptype The ptype of the parameter
 * @param direction The direction of the parameter (in for method args, out for method returns)
 * @param sourceLocation The location of the method or parameter, for use in error metadata
 */
function getABITypeName(ptype, direction, sourceLocation) {
    const arc4Type = ptypeToAbiPType(ptype, direction, sourceLocation);
    if (arc4Type.wtype instanceof wtypes.ARC4Type || arc4Type.wtype instanceof wtypes.WGroupTransaction) {
        return arc4Type.wtype.arc4Name;
    }
    return arc4Type.wtypeOrThrow.name;
}
/**
 * Is the given type an ARC4 encoded type, or can it be encoded to one
 * @param ptype The type to check
 */
function isArc4EncodableType(ptype) {
    if (ptype instanceof ARC4EncodedType)
        return true;
    if (ptype.equals(boolPType))
        return true;
    if (ptype.equals(uint64PType))
        return true;
    if (ptype.equals(biguintPType))
        return true;
    if (ptype.equals(bytesPType))
        return true;
    if (ptype.equals(stringPType))
        return true;
    if (ptype instanceof TuplePType)
        return ptype.items.every((i) => isArc4EncodableType(i));
    if (ptype instanceof ObjectPType)
        return ptype.orderedProperties().every(([, pt]) => isArc4EncodableType(pt));
    if (ptype instanceof ArrayPType)
        return isArc4EncodableType(ptype.elementType);
    return false;
}
function ptypeToArc4EncodedType(ptype, sourceLocation) {
    if (ptype instanceof ARC4EncodedType)
        return ptype;
    if (ptype.equals(boolPType))
        return arc4BooleanType;
    if (ptype.equals(uint64PType))
        return new UintNType({ n: 64n });
    if (ptype.equals(biguintPType))
        return new UintNType({ n: 512n });
    if (ptype.equals(bytesPType))
        return DynamicBytesType;
    if (ptype.equals(stringPType))
        return arc4StringType;
    if (ptype instanceof NativeNumericType) {
        throw new CodeError(numberPType.expressionMessage, { sourceLocation });
    }
    if (ptype instanceof ArrayPType)
        return new DynamicArrayType({
            elementType: ptypeToArc4EncodedType(ptype.elementType, sourceLocation),
            immutable: true,
        });
    if (ptype instanceof TuplePType)
        return new ARC4TupleType({ types: ptype.items.map((i) => ptypeToArc4EncodedType(i, sourceLocation)) });
    if (ptype instanceof ObjectPType)
        return new ARC4StructType({
            name: ptype.alias?.name ?? ptype.name,
            module: ptype.module,
            description: ptype.description,
            fields: Object.fromEntries(ptype.orderedProperties().map(([p, pt]) => [p, ptypeToArc4EncodedType(pt, sourceLocation)])),
            frozen: true,
        });
    throw new CodeError(`${ptype} cannot be encoded to an ARC4 type`, { sourceLocation });
}

const peek = A.lookAhead(A.regex(/^./));
const integer$1 = A.regex(/^\d+/).map((x) => BigInt(x));
const uint = A.sequenceOf([A.str('uint'), integer$1]).map(([_, n]) => new UintNType({ n: n }));
const ufixed = A.sequenceOf([A.str('ufixed'), integer$1, A.char('x'), integer$1]).map(([_, n, __, m]) => new UFixedNxMType({ n, m }));
const simpleType = (name, ptype) => A.str(name).map(() => ptype);
const scalarType = A.choice([
    uint,
    ufixed,
    simpleType('byte', arc4ByteAlias),
    simpleType('string', arc4StringType),
    simpleType('bool', arc4BooleanType),
    simpleType('address', arc4AddressAlias),
    simpleType('account', new UintNType({ n: 8n })),
    simpleType('asset', new UintNType({ n: 8n })),
    simpleType('application', new UintNType({ n: 8n })),
]);
class TypeBuilder {
    #stack = [[]];
    get workingSet() {
        return this.#stack[this.#stack.length - 1];
    }
    get hasOpenTuple() {
        return this.#stack.length > 1;
    }
    enterTuple() {
        this.#stack.push([]);
    }
    exitTuple() {
        if (this.#stack.length === 1) {
            throw new Error('Invalid operation, no tuple has been entered');
        }
        const tupleType = new ARC4TupleType({ types: this.workingSet });
        this.#stack.pop();
        this.workingSet.push(tupleType);
    }
    get result() {
        if (this.#stack.length > 1) {
            throw new Error(`Tuple has not been closed`);
        }
        return this.workingSet;
    }
    push(ptype) {
        this.workingSet.push(ptype);
    }
    replaceLast(replacer) {
        if (this.workingSet.length === 0) {
            throw new Error('Invalid operation, no type to replace');
        }
        const latest = this.workingSet.pop();
        this.workingSet.push(replacer(latest));
    }
}
const arc4Type = A.coroutine((parse) => {
    try {
        let States;
        (function (States) {
            States[States["BeginTuple"] = 0] = "BeginTuple";
            States[States["EndTuple"] = 1] = "EndTuple";
            States[States["ArrayBrackets"] = 2] = "ArrayBrackets";
            States[States["TypeOrBeginTuple"] = 3] = "TypeOrBeginTuple";
            States[States["AfterType"] = 4] = "AfterType";
        })(States || (States = {}));
        let state = States.TypeOrBeginTuple;
        const typeBuilder = new TypeBuilder();
        while (true) {
            const next = parse(A.possibly(peek));
            if (next === null) {
                return typeBuilder.result;
            }
            switch (state) {
                case States.TypeOrBeginTuple: {
                    if (next === '(') {
                        state = States.BeginTuple;
                    }
                    else {
                        const type = parse(scalarType);
                        typeBuilder.push(type);
                        state = States.AfterType;
                    }
                    break;
                }
                case States.BeginTuple: {
                    parse(A.char('('));
                    typeBuilder.enterTuple();
                    state = States.TypeOrBeginTuple;
                    break;
                }
                case States.EndTuple: {
                    parse(A.char(')'));
                    if (!typeBuilder.hasOpenTuple) {
                        return parse(A.fail("Char ')' has no matching opening '('"));
                    }
                    typeBuilder.exitTuple();
                    state = States.AfterType;
                    break;
                }
                case States.ArrayBrackets: {
                    parse(A.char('['));
                    const size = parse(A.possibly(integer$1));
                    parse(A.char(']'));
                    typeBuilder.replaceLast((previous) => size === null
                        ? new DynamicArrayType({ elementType: previous })
                        : new StaticArrayType({ elementType: previous, arraySize: size }));
                    state = States.AfterType;
                    break;
                }
                case States.AfterType: {
                    switch (next) {
                        case ',':
                            parse(A.char(','));
                            state = States.TypeOrBeginTuple;
                            continue;
                        case '[':
                            state = States.ArrayBrackets;
                            continue;
                        case ')':
                            state = States.EndTuple;
                            continue;
                        default:
                            // Parse the next char rather than just peeking at it so the fail below happens at the right position
                            parse(A.anyChar);
                            parse(A.fail(`Expecting ',', '[', or ')', but got ${next}`));
                    }
                }
            }
        }
    }
    catch (e) {
        if (e instanceof Error) {
            return parse(A.fail(e.message));
        }
        else {
            throw e;
        }
    }
});
class Arc4ParseError extends Error {
    index;
    constructor(message, index) {
        super(message);
        this.index = index;
    }
}
const parseArc4Type = (signature) => {
    const parseResult = arc4Type.run(signature);
    if (parseResult.isError) {
        const maybeErrorMessage = /^ParseError \(position \d+\): (.*)/.exec(parseResult.error);
        const message = maybeErrorMessage ? maybeErrorMessage[1] : parseResult.error;
        throw new Arc4ParseError(message, parseResult.index);
    }
    else {
        if (parseResult.result.length === 0) {
            throw new Arc4ParseError('Signature contained no types', 0);
        }
        else if (parseResult.result.length > 1) {
            throw new Arc4ParseError('Signature contained more than one type. Wrap multiple types in parentheses to declare a tuple type', 0);
        }
        return parseResult.result[0];
    }
};

class TypeRegistry {
    get hasRegistrations() {
        return this.types.size > 0 || this.genericTypes.size > 0;
    }
    singletonEbs = new Map();
    instanceEbs = new Map();
    types = new Set();
    genericTypes = new Set();
    register({ ptype, singletonEb, instanceEb, }) {
        if (this.types.has(ptype) || this.genericTypes.has(ptype))
            throw new InternalError(`${ptype} has already been registered`);
        this.types.add(ptype);
        if (singletonEb) {
            this.singletonEbs.set(ptype, singletonEb);
        }
        if (instanceEb) {
            this.instanceEbs.set(ptype, instanceEb);
        }
    }
    registerGeneric({ generic, ptype, instanceEb, }) {
        if (this.genericTypes.has(generic) || this.types.has(ptype))
            throw new InternalError(`${ptype} has already been registered`);
        this.genericTypes.add(generic);
        this.instanceEbs.set(ptype, instanceEb);
    }
    /**
     * Try to resolve a symbol name to a singleton ptype
     * @param symbolName The name of the symbol
     */
    tryResolveSingletonName(symbolName) {
        for (const v of this.singletonEbs.keys())
            if (v instanceof PType && v.fullName === symbolName.fullName)
                return v;
        return undefined;
    }
    /**
     * Try to resolve a symbol name to an instance ptype
     * @param symbolName The name of the symbol
     */
    tryResolveInstancePType(symbolName) {
        for (const v of this.instanceEbs.keys()) {
            if (v instanceof PType && v.fullName === symbolName.fullName)
                return v;
        }
        return undefined;
    }
    resolveInstancePType(symbolName, sourceLocation) {
        const ptype = this.tryResolveInstancePType(symbolName);
        if (!ptype) {
            if (symbolName.module.startsWith('typescript/lib')) {
                throw new CodeError(`${symbolName} type is not supported`, { sourceLocation });
            }
            throw new InternalError(`Cannot resolve ptype for symbol ${symbolName}`, {
                sourceLocation,
            });
        }
        return ptype;
    }
    tryGetSingletonEb(ptype, sourceLocation) {
        const eb = this.singletonEbs.get(ptype);
        if (eb) {
            return new eb(sourceLocation, ptype);
        }
        for (const [pt, eb] of this.singletonEbs.entries()) {
            if (typeof pt === 'function' && ptype instanceof pt) {
                return new eb(sourceLocation, ptype);
            }
        }
        return undefined;
    }
    getSingletonEb(ptype, sourceLocation) {
        return (this.tryGetSingletonEb(ptype, sourceLocation) ??
            throwError(new InternalError(`No singleton eb registered for ${ptype}`, {
                sourceLocation,
            })));
    }
    getInstanceEb(expression, ptype) {
        return (this.tryGetInstanceEb(expression, ptype) ??
            throwError(new InternalError(`No InstanceBuilder registered for ${ptype}`, {
                sourceLocation: expression.sourceLocation,
            })));
    }
    tryGetInstanceEb(expression, ptype) {
        const eb = this.instanceEbs.get(ptype);
        if (eb) {
            return new eb(expression, ptype);
        }
        for (const [pt, eb] of this.instanceEbs.entries()) {
            if (typeof pt === 'function' && ptype instanceof pt) {
                return new eb(expression, ptype);
            }
        }
        return undefined;
    }
    resolveGenericPType(symbolName, typeArgs, sourceLocation) {
        const genericType = this.tryResolveGenericPType(symbolName, typeArgs);
        if (genericType)
            return genericType;
        throw new CodeError(`${symbolName} could not be resolved to a generic type`, { sourceLocation });
    }
    tryResolveGenericPType(symbolName, typeArgs) {
        for (const pt of this.genericTypes.values()) {
            if (pt.fullName === symbolName.fullName) {
                return pt.parameterise(typeArgs);
            }
        }
        return undefined;
    }
}
const typeRegistry = new TypeRegistry();
function instanceEb(expr, ptype) {
    return typeRegistry.getInstanceEb(expr, ptype);
}

function isConstant(expr) {
    return (expr instanceof StringConstant ||
        expr instanceof BytesConstant ||
        expr instanceof IntegerConstant ||
        expr instanceof BoolConstant ||
        expr instanceof AddressConstant ||
        expr instanceof MethodConstant ||
        expr instanceof DecimalConstant);
}
class SymbolToNumber {
    #symbols = new Map();
    forSymbol(sym) {
        let val = this.#symbols.get(sym);
        if (val !== undefined) {
            return [val, false];
        }
        val = this.#symbols.size;
        this.#symbols.set(sym, val);
        return [val, true];
    }
}

var BuilderComparisonOp;
(function (BuilderComparisonOp) {
    BuilderComparisonOp["eq"] = "===";
    BuilderComparisonOp["ne"] = "!==";
    BuilderComparisonOp["lt"] = "<";
    BuilderComparisonOp["lte"] = "<=";
    BuilderComparisonOp["gt"] = ">";
    BuilderComparisonOp["gte"] = ">=";
})(BuilderComparisonOp || (BuilderComparisonOp = {}));
var BuilderUnaryOp;
(function (BuilderUnaryOp) {
    BuilderUnaryOp["inc"] = "++";
    BuilderUnaryOp["dec"] = "--";
    BuilderUnaryOp["bit_inv"] = "~";
    BuilderUnaryOp["neg"] = "-";
    BuilderUnaryOp["pos"] = "+";
})(BuilderUnaryOp || (BuilderUnaryOp = {}));
var BuilderBinaryOp;
(function (BuilderBinaryOp) {
    BuilderBinaryOp["add"] = "+";
    BuilderBinaryOp["sub"] = "-";
    BuilderBinaryOp["mult"] = "*";
    BuilderBinaryOp["div"] = "/";
    BuilderBinaryOp["mod"] = "%";
    BuilderBinaryOp["pow"] = "**";
    BuilderBinaryOp["matMult"] = "@";
    BuilderBinaryOp["lshift"] = "<<";
    BuilderBinaryOp["rshift"] = ">>";
    BuilderBinaryOp["bitOr"] = "|";
    BuilderBinaryOp["bitXor"] = "^";
    BuilderBinaryOp["bitAnd"] = "&";
    /**
     * Eval left, return right
     * let y = 2
     * // x == 4
     * const x = (y * 3, y - 2)
     */
    BuilderBinaryOp["comma"] = ",";
})(BuilderBinaryOp || (BuilderBinaryOp = {}));
class NodeBuilder {
    sourceLocation;
    constructor(sourceLocation) {
        this.sourceLocation = sourceLocation;
    }
    get typeDescription() {
        if (this.ptype) {
            return this.ptype.name;
        }
        return this.constructor.name;
    }
    call(args, typeArgs, sourceLocation) {
        throw new NotSupported(`Calling ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    newCall(args, typeArgs, sourceLocation) {
        throw new NotSupported(`Calling ${this.typeDescription} with the new keyword`, { sourceLocation });
    }
    taggedTemplate(head, spans, sourceLocation) {
        throw new NotSupported(`Tagged templates on ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    hasProperty(_name) {
        return false;
    }
    memberAccess(name, sourceLocation) {
        throw new NotSupported(`Accessing member ${name} on ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    indexAccess(index, sourceLocation) {
        throw new NotSupported(`Indexing ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    boolEval(sourceLocation, negate = false) {
        throw new NotSupported(`Boolean evaluation of ${this.typeDescription}`, {
            sourceLocation,
        });
    }
}
class InstanceBuilder extends NodeBuilder {
    constructor(sourceLocation) {
        super(sourceLocation);
    }
    /**
     * Returns a boolean indicating if the current builder can be resolved to the target type.
     * Resolvable meaning it may have a different type, but would be assignable to the target type in TypeScript
     * without a cast.
     * @param ptype
     */
    resolvableToPType(ptype) {
        return this.ptype.equalsOrInstanceOf(ptype);
    }
    /**
     * Attempts to resolve the value held by this builder to the target type.
     * @param ptype
     */
    resolveToPType(ptype) {
        if (this.ptype.equalsOrInstanceOf(ptype)) {
            return this;
        }
        throw CodeError.cannotResolveToType({ sourceType: this.ptype, targetType: ptype, sourceLocation: this.sourceLocation });
    }
    singleEvaluation() {
        const expr = this.resolve();
        if (expr instanceof VarExpression) {
            return this;
        }
        return instanceEb(nodeFactory.singleEvaluation({
            source: this.resolve(),
        }), this.ptype);
    }
    toBytes(sourceLocation) {
        throw new NotSupported(`Serializing ${this.typeDescription} to bytes`, {
            sourceLocation,
        });
    }
    toString(sourceLocation) {
        throw new NotSupported(`Converting ${this.typeDescription} to string`, {
            sourceLocation,
        });
    }
    prefixUnaryOp(op, sourceLocation) {
        throw new NotSupported(`Prefix Unary ${op} op on ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    postfixUnaryOp(op, sourceLocation) {
        throw new NotSupported(`Postfix Unary ${op} op on ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    compare(other, op, sourceLocation) {
        throw new NotSupported(`${op} on ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    binaryOp(other, op, sourceLocation) {
        throw new NotSupported(`${op} on ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    iterate(sourceLocation) {
        throw new NotSupported(`Iteration on ${this.typeDescription}`, {
            sourceLocation,
        });
    }
    augmentedAssignment(other, op, sourceLocation) {
        throw new NotSupported(`Augmented assignment to ${this.typeDescription} with ${op}`, {
            sourceLocation,
        });
    }
    reinterpretCast(target, sourceLocation) {
        return instanceEb(nodeFactory.reinterpretCast({
            expr: this.resolve(),
            sourceLocation: sourceLocation ?? this.sourceLocation,
            wtype: target.wtypeOrThrow,
        }), target);
    }
}
class ClassBuilder extends NodeBuilder {
    call(args, typeArgs, sourceLocation) {
        throw new CodeError(`${this.typeDescription} should be called with the \`new\` keyword`, { sourceLocation });
    }
}
class FunctionBuilder extends NodeBuilder {
    ptype = undefined;
    constructor(location) {
        super(location);
    }
}
class ParameterlessFunctionBuilder extends FunctionBuilder {
    expression;
    definition;
    constructor(expression, definition) {
        super(expression.sourceLocation);
        this.expression = expression;
        this.definition = definition;
    }
    call(args, typeArgs, sourceLocation) {
        if (args.length)
            logger.error(sourceLocation, 'Function expects no arguments');
        if (typeArgs.length)
            logger.error(sourceLocation, 'Function expects type arguments');
        return this.definition(this.expression, sourceLocation);
    }
}
class InstanceExpressionBuilder extends InstanceBuilder {
    _expr;
    #ptype;
    get ptype() {
        return this.#ptype;
    }
    constructor(_expr, ptype) {
        super(_expr.sourceLocation);
        this._expr = _expr;
        this.#ptype = ptype;
    }
    resolve() {
        return this._expr;
    }
    resolveLValue() {
        return requireLValue(this.resolve());
    }
}
function requireLValue(expr) {
    const lValueNodes = [
        VarExpression,
        FieldExpression,
        IndexExpression,
        TupleExpression,
        AppStateExpression,
        AppAccountStateExpression,
        BoxValueExpression,
    ];
    if (expr instanceof TupleItemExpression) {
        throw new CodeError('Expression is not a valid assignment target - object is immutable', { sourceLocation: expr.sourceLocation });
    }
    if (!lValueNodes.some((l) => expr instanceof l)) {
        throw new CodeError(`Expression is not a valid assignment target`, {
            sourceLocation: expr.sourceLocation,
        });
    }
    if (expr instanceof IndexExpression || expr instanceof FieldExpression) {
        if (expr.base.wtype.immutable) {
            throw new CodeError(`Expression is not a valid assignment target - object is immutable`, {
                sourceLocation: expr.sourceLocation,
            });
        }
    }
    if (expr instanceof ReinterpretCast) {
        requireLValue(expr.expr);
    }
    if (expr instanceof TupleExpression) {
        for (const item of expr.items) {
            requireLValue(item);
        }
    }
    return expr;
}
class DecoratorDataBuilder extends NodeBuilder {
    data;
    get ptype() {
        return undefined;
    }
    constructor(sourceLocation, data) {
        super(sourceLocation);
        this.data = data;
    }
    resolveDecoratorData() {
        return this.data;
    }
}

class LiteralExpressionBuilder extends InstanceBuilder {
    resolve() {
        this.throwInvalidExpression();
    }
    resolveLValue() {
        throw new CodeError('A literal value is not a valid assignment target', { sourceLocation: this.sourceLocation });
    }
    throwInvalidExpression() {
        if (this.ptype instanceof TransientType)
            throw new CodeError(this.ptype.expressionMessage, { sourceLocation: this.sourceLocation });
        throw new CodeError(`Invalid expression type ${this.ptype}`, { sourceLocation: this.sourceLocation });
    }
    compare(other, op, sourceLocation) {
        this.throwInvalidExpression();
    }
    binaryOp(other, op, sourceLocation) {
        this.throwInvalidExpression();
    }
    memberAccess(name, sourceLocation) {
        this.throwInvalidExpression();
    }
    call(args, typeArgs, sourceLocation) {
        this.throwInvalidExpression();
    }
    taggedTemplate(head, spans, sourceLocation) {
        this.throwInvalidExpression();
    }
    indexAccess(index, sourceLocation) {
        this.throwInvalidExpression();
    }
    singleEvaluation() {
        this.throwInvalidExpression();
    }
    toBytes(sourceLocation) {
        this.throwInvalidExpression();
    }
    prefixUnaryOp(op, sourceLocation) {
        this.throwInvalidExpression();
    }
    postfixUnaryOp(op, sourceLocation) {
        this.throwInvalidExpression();
    }
    iterate(sourceLocation) {
        this.throwInvalidExpression();
    }
    augmentedAssignment(other, op, sourceLocation) {
        this.throwInvalidExpression();
    }
    hasProperty(_name) {
        return false;
    }
}

const binaryOpFolding = {
    [BuilderBinaryOp.div]: (l, r) => l / r,
    [BuilderBinaryOp.add]: (l, r) => l + r,
    [BuilderBinaryOp.sub]: (l, r) => l - r,
    [BuilderBinaryOp.mult]: (l, r) => l * r,
    [BuilderBinaryOp.mod]: (l, r) => l % r,
    [BuilderBinaryOp.pow]: (l, r) => l ** r,
    [BuilderBinaryOp.matMult]: undefined,
    [BuilderBinaryOp.lshift]: (l, r) => {
        return l << r;
    },
    [BuilderBinaryOp.rshift]: (l, r) => l >> r,
    [BuilderBinaryOp.bitOr]: (l, r) => l | r,
    [BuilderBinaryOp.bitXor]: (l, r) => l ^ r,
    [BuilderBinaryOp.bitAnd]: (l, r) => l & r,
    [BuilderBinaryOp.comma]: (l, r) => r,
};
const comparisonOpFolding = {
    [BuilderComparisonOp.eq]: (l, r) => l === r,
    [BuilderComparisonOp.ne]: (l, r) => l !== r,
    [BuilderComparisonOp.lt]: (l, r) => l < r,
    [BuilderComparisonOp.lte]: (l, r) => l <= r,
    [BuilderComparisonOp.gt]: (l, r) => l > r,
    [BuilderComparisonOp.gte]: (l, r) => l >= r,
};
function foldBinaryOp(left, right, op, sourceLocation) {
    const result = binaryOpFolding[op]?.(left, right);
    switch (typeof result) {
        case 'bigint':
            return result;
        default:
            throw new CodeError(`${op} is not supported`, { sourceLocation });
    }
}
function foldComparisonOp(left, right, op, sourceLocation) {
    const result = comparisonOpFolding[op]?.(left, right);
    switch (typeof result) {
        case 'boolean':
            return nodeFactory.boolConstant({
                value: result,
                sourceLocation: sourceLocation,
            });
        default:
            throw new CodeError(`${op} is not supported`, { sourceLocation });
    }
}

function isValidLiteralForPType(literalValue, ptype) {
    if (ptype.equals(stringPType)) {
        return typeof literalValue === 'string';
    }
    if (ptype.equals(numberPType)) {
        return (typeof literalValue === 'bigint' && BigInt(Number.MIN_SAFE_INTEGER) <= literalValue && literalValue <= BigInt(Number.MAX_SAFE_INTEGER));
    }
    if (ptype.equals(bigIntPType)) {
        return typeof literalValue === 'bigint';
    }
    if (ptype.equals(uint64PType)) {
        return typeof literalValue === 'bigint' && 0 <= literalValue && literalValue < 2n ** 64n;
    }
    if (ptype.equals(biguintPType)) {
        return typeof literalValue === 'bigint' && 0 <= literalValue && literalValue < 2n ** 512n;
    }
    if (ptype instanceof UintNType || ptype instanceof UFixedNxMType) {
        return typeof literalValue === 'bigint' && 0 <= literalValue && literalValue < 2n ** ptype.n;
    }
    if (ptype.equals(boolPType)) {
        return typeof literalValue === 'boolean';
    }
    if (ptype.equals(bytesPType)) {
        return literalValue instanceof Uint8Array;
    }
    return false;
}

class BigIntLiteralExpressionBuilder extends LiteralExpressionBuilder {
    value;
    ptype;
    singleEvaluation() {
        return this;
    }
    constructor(value, ptype, location) {
        super(location);
        this.value = value;
        this.ptype = ptype;
    }
    resolvableToPType(ptype) {
        const isUnsigned = ptype.equals(biguintPType) || ptype.equals(uint64PType);
        if (this.ptype instanceof NumericLiteralPType || this.ptype.equals(numberPType)) {
            if (isUnsigned) {
                return this.value >= 0n;
            }
            return ptype.equals(numberPType) || ptype.equals(this.ptype);
        }
        else if (this.ptype instanceof BigIntLiteralPType || this.ptype.equals(bigIntPType)) {
            if (isUnsigned) {
                return this.value >= 0n;
            }
            return ptype.equals(bigIntPType) || ptype.equals(this.ptype);
        }
        return false;
    }
    boolEval(sourceLocation, negate = false) {
        const value = negate ? !this.value : Boolean(this.value);
        return nodeFactory.boolConstant({
            value,
            sourceLocation,
        });
    }
    resolveToPType(ptype) {
        codeInvariant(this.resolvableToPType(ptype), `${this.value} cannot be converted to type ${ptype.name}`, this.sourceLocation);
        if (ptype.equals(this.ptype))
            return this;
        if (ptype instanceof TransientType && (ptype.equals(numberPType) || ptype.equals(bigIntPType))) {
            return new BigIntLiteralExpressionBuilder(this.value, ptype, this.sourceLocation);
        }
        codeInvariant(isValidLiteralForPType(this.value, ptype), `${ptype.name} overflow or underflow: ${this.value}`, this.sourceLocation);
        if (ptype.equals(uint64PType)) {
            return instanceEb(nodeFactory.uInt64Constant({ value: this.value, sourceLocation: this.sourceLocation }), uint64PType);
        }
        else if (ptype.equals(biguintPType)) {
            return instanceEb(nodeFactory.bigUIntConstant({ value: this.value, sourceLocation: this.sourceLocation }), biguintPType);
        }
        throw new CodeError(`${this.value} cannot be converted to type ${ptype.name}`, { sourceLocation: this.sourceLocation });
    }
    binaryOp(other, op, sourceLocation) {
        if (other.ptype.wtype) {
            return this.resolveToPType(other.ptype).binaryOp(other, op, sourceLocation);
        }
        if (other instanceof BigIntLiteralExpressionBuilder) {
            const folded = foldBinaryOp(this.value, other.value, op, sourceLocation);
            return new BigIntLiteralExpressionBuilder(folded, this.getUpdatedPType(folded), sourceLocation);
        }
        return super.binaryOp(other, op, sourceLocation);
    }
    compare(other, op, sourceLocation) {
        if (other.ptype.wtype) {
            return this.resolveToPType(other.ptype).compare(other, op, sourceLocation);
        }
        if (other instanceof BigIntLiteralExpressionBuilder) {
            return typeRegistry.getInstanceEb(foldComparisonOp(this.value, other.value, op, sourceLocation), boolPType);
        }
        return super.compare(other, op, sourceLocation);
    }
    prefixUnaryOp(op, sourceLocation) {
        switch (op) {
            case BuilderUnaryOp.neg:
                return new BigIntLiteralExpressionBuilder(-this.value, this.getUpdatedPType(-this.value), sourceLocation);
            case BuilderUnaryOp.pos:
                return new BigIntLiteralExpressionBuilder(this.value, this.ptype, sourceLocation);
        }
        return super.prefixUnaryOp(op, sourceLocation);
    }
    getUpdatedPType(value) {
        if (this.ptype instanceof BigIntLiteralPType) {
            return new BigIntLiteralPType({ literalValue: value });
        }
        if (this.ptype instanceof NumericLiteralPType) {
            return new NumericLiteralPType({ literalValue: value });
        }
        return this.ptype;
    }
}

function requireExpressionOfType(builder, ptype) {
    if (builder instanceof InstanceBuilder) {
        if (builder.resolvableToPType(ptype)) {
            return builder.resolveToPType(ptype).resolve();
        }
    }
    throw new CodeError(`Expected expression of type ${ptype}, got ${builder.typeDescription}`, {
        sourceLocation: builder.sourceLocation,
    });
}
function requireBuilderOfType(builder, ptype) {
    if (builder instanceof InstanceBuilder) {
        if (builder.resolvableToPType(ptype)) {
            return builder.resolveToPType(ptype);
        }
    }
    throw new CodeError(`Expected expression of type ${ptype}, got ${builder.typeDescription}`, {
        sourceLocation: builder.sourceLocation,
    });
}
function resolvableToType(builder, ptype) {
    if (builder instanceof InstanceBuilder) {
        return builder.resolvableToPType(ptype);
    }
    return false;
}
function requestExpressionOfType(builder, ptype) {
    if (builder instanceof InstanceBuilder) {
        if (builder.resolvableToPType(ptype)) {
            return builder.resolveToPType(ptype).resolve();
        }
        return undefined;
    }
    return undefined;
}
function requestBuilderOfType(builder, ptype) {
    if (builder instanceof InstanceBuilder) {
        if (builder.resolvableToPType(ptype)) {
            return builder.resolveToPType(ptype);
        }
        return undefined;
    }
    return undefined;
}
function requireInstanceBuilder(builder) {
    if (builder instanceof InstanceBuilder)
        return builder;
    throw new CodeError(`Expected instance of a type, got ${builder.typeDescription}`, { sourceLocation: builder.sourceLocation });
}
function requireStringConstant(builder) {
    const constant = requireConstantOfType(builder, stringPType);
    codeInvariant(constant instanceof StringConstant, 'Expected string literal', builder.sourceLocation);
    return constant;
}
function requireIntegerConstant(builder) {
    const constant = requestConstantOfType(builder, uint64PType) ?? requestConstantOfType(builder, biguintPType);
    codeInvariant(constant instanceof IntegerConstant, 'Expected integer literal');
    return constant;
}
function requireBooleanConstant(builder) {
    const constant = requireConstantOfType(builder, boolPType);
    codeInvariant(constant instanceof BoolConstant, 'Expected boolean literal');
    return constant;
}
function requestConstantOfType(builder, ptype) {
    if (builder instanceof LiteralExpressionBuilder) {
        if (builder.resolvableToPType(ptype)) {
            const expr = builder.resolveToPType(ptype).resolve();
            if (isConstant(expr))
                return expr;
        }
        return undefined;
    }
    if (builder instanceof InstanceBuilder && builder.ptype?.equals(ptype)) {
        const expr = builder.resolve();
        if (isConstant(expr))
            return expr;
    }
    return undefined;
}
function requireConstantOfType(builder, ptype, messageOverride) {
    const constExpr = requestConstantOfType(builder, ptype);
    if (constExpr)
        return constExpr;
    throw new CodeError(`Expected constant of type ${ptype}`, { sourceLocation: builder.sourceLocation });
}
function requireLiteralNumber(builder) {
    codeInvariant(builder instanceof BigIntLiteralExpressionBuilder, 'Expected numeric literal', builder.sourceLocation);
    return builder.value;
}

function parseTypeArgs(typeArgs, sourceLocation, funcName, expectedCount) {
    if (typeArgs.length !== expectedCount) {
        const err = new CodeError(`${funcName} expects exactly ${expectedCount} type argument${expectedCount === 1 ? '' : 's'}`, {
            sourceLocation,
        });
        if (typeArgs.length > expectedCount) {
            logger.error(err);
            return typeArgs.slice(0, expectedCount);
        }
        throw err;
    }
    return typeArgs;
}
const ArgSpecDiscriminator = Symbol('_specType');
function parseObjArg(arg, sourceLocation, subject, argMap) {
    return Object.entries(argMap).reduce((acc, [property, spec]) => {
        if (arg?.hasProperty(property)) {
            const builder = arg.memberAccess(property, sourceLocation);
            if (spec.type === 'passthrough') {
                acc[property] = builder;
                return acc;
            }
            if (spec.t.length === 0) {
                acc[property] = requireInstanceBuilder(builder);
            }
            else {
                for (const t of spec.t) {
                    const typedBuilder = requestBuilderOfType(builder, t);
                    if (typedBuilder) {
                        acc[property] = typedBuilder;
                        return acc;
                    }
                }
                throw new CodeError(`${subject} has an incorrect type for property '${property}' of ${builder.ptype}. Expected ${spec.t.join(' or ')}`, {
                    sourceLocation: arg?.sourceLocation ?? sourceLocation,
                });
            }
            return acc;
        }
        if (spec.type === 'required') {
            throw new CodeError(`${subject} is missing required property ${property}`, {
                sourceLocation: arg?.sourceLocation ?? sourceLocation,
            });
        }
        return acc;
    }, {});
}
const argSpecFactory = {
    /**
     * A required arg with one of the specified types
     * @param ptypes
     */
    required(...ptypes) {
        return { t: ptypes, type: 'required', [ArgSpecDiscriminator]: 'arg' };
    },
    /**
     * An optional arg with one of the specified types
     * @param ptypes
     */
    optional(...ptypes) {
        return { t: ptypes, type: 'optional', [ArgSpecDiscriminator]: 'arg' };
    },
    /**
     * An object map arg, if all properties are optional - the arg itself becomes optional
     * @param props A mapping of expected properties to expected ptypes
     */
    obj(props) {
        return {
            ...props,
            [ArgSpecDiscriminator]: 'obj',
        };
    },
    passthrough() {
        return {
            type: 'passthrough',
            [ArgSpecDiscriminator]: 'arg',
        };
    },
};
function parseFunctionArgs({ args, typeArgs, funcName, callLocation, genericTypeArgs, argSpec, }) {
    const argMap = argSpec(argSpecFactory);
    if (args.length > argMap.length) {
        throw new CodeError(`${funcName} has ${args.length - argMap.length} too many args`, { sourceLocation: callLocation });
    }
    return {
        ptypes: parseTypeArgs(typeArgs, callLocation, funcName, genericTypeArgs),
        args: argMap.map((a, i) => {
            const source = args[i];
            if (a[ArgSpecDiscriminator] === 'arg') {
                if (a.type === 'passthrough') {
                    return source;
                }
                if (source) {
                    if (a.t.length === 0) {
                        return requireInstanceBuilder(source);
                    }
                    else {
                        for (const t of a.t) {
                            const builder = requestBuilderOfType(source, t);
                            if (builder) {
                                return builder;
                            }
                        }
                        throw new CodeError(`Arg ${i} of ${funcName} has an incorrect type of ${source.ptype}. Expected ${a.t.join(' | ')}`, {
                            sourceLocation: source.sourceLocation,
                        });
                    }
                }
                if (a.type === 'required') {
                    throw new CodeError(`Arg ${i} of ${funcName} is missing`, { sourceLocation: callLocation });
                }
            }
            else {
                return parseObjArg(source, callLocation, `Arg ${i} for ${funcName}`, a);
            }
        }),
    };
}

class Arc28EmitFunctionBuilder extends FunctionBuilder {
    ptype = arc28EmitFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [nameOrObj, ...props], ptypes: [genericArg], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required(), ...args.slice(1).map(() => a.required())],
        });
        if (nameOrObj.ptype.equals(stringPType)) {
            const thisModule = nameOrObj.sourceLocation.file ?? '';
            const fields = {};
            const values = new Map();
            const { name, propTypes } = parseEventName(nameOrObj);
            for (const [index, prop] of props.entries()) {
                const arc4Type = ptypeToArc4EncodedType(prop.ptype, prop.sourceLocation);
                const expectedType = propTypes?.[index];
                if (expectedType) {
                    codeInvariant(expectedType.wtype.equals(arc4Type.wtype), `Expected type ${expectedType} does not match actual type ${arc4Type}`, prop.sourceLocation);
                }
                fields[index] = arc4Type;
                values.set(index.toString(), prop.ptype instanceof ARC4EncodedType
                    ? prop.resolve()
                    : nodeFactory.aRC4Encode({
                        value: prop.resolve(),
                        wtype: arc4Type.wtype,
                        sourceLocation: prop.sourceLocation,
                    }));
            }
            if (propTypes && propTypes.length !== values.size) {
                throw new CodeError(`Event signature length (${propTypes.length}) does not match number of provided values (${values.size}).`, {
                    sourceLocation: sourceLocation,
                });
            }
            const structType = new ARC4StructType({
                name: name.value,
                module: thisModule,
                fields,
                description: undefined,
                sourceLocation,
                frozen: true,
            });
            const structExpression = nodeFactory.newStruct({
                wtype: structType.wtype,
                values,
                sourceLocation,
            });
            return emitStruct(structType, structExpression, sourceLocation);
        }
        codeInvariant(props.length === 0, 'Unexpected args', props[0]?.sourceLocation);
        const eventBuilder = nameOrObj.resolveToPType(genericArg);
        const eventType = eventBuilder.ptype;
        if (eventType instanceof ARC4StructType) {
            return emitStruct(eventType, nameOrObj.resolve(), sourceLocation);
        }
        else if (eventType instanceof ObjectPType) {
            if (!eventType.alias) {
                logger.error(eventBuilder.sourceLocation, 'Event cannot be an anonymous type. If a named type exists, try specifying it explicitly via the generic parameter. Eg. `emit<YourType>({...})`');
            }
            const arc4Equivalent = ptypeToArc4EncodedType(eventType, sourceLocation);
            return emitStruct(arc4Equivalent, nodeFactory.aRC4Encode({
                wtype: arc4Equivalent.wtype,
                sourceLocation: nameOrObj.sourceLocation,
                value: nameOrObj.resolve(),
            }), sourceLocation);
        }
        throw new InternalError('Unexpected type for arg 0 of emit', { sourceLocation });
    }
}
function emitStruct(ptype, expression, sourceLocation) {
    return instanceEb(nodeFactory.emit({
        signature: ptype.signature,
        value: expression,
        wtype: voidPType.wtype,
        sourceLocation,
    }), voidPType);
}
function parseEventName(nameBuilder) {
    const name = requireStringConstant(nameBuilder);
    const parenthesisIndex = name.value.indexOf('(');
    if (parenthesisIndex === -1) {
        return {
            name,
        };
    }
    const signature = name.value.substring(parenthesisIndex);
    try {
        const signatureType = parseArc4Type(signature);
        codeInvariant(signatureType instanceof ARC4TupleType, 'Event signature must be a tuple type', name.sourceLocation);
        return {
            name: nodeFactory.stringConstant({
                value: name.value.substring(0, parenthesisIndex),
                sourceLocation: name.sourceLocation,
            }),
            propTypes: signatureType.items,
        };
    }
    catch (e) {
        if (e instanceof Arc4ParseError) {
            // Source location adjustment assumes StringConstant is all on one line
            throw new CodeError(`Invalid signature: ${e.message}`, {
                sourceLocation: new SourceLocation({
                    ...name.sourceLocation,
                    column: name.sourceLocation.column + parenthesisIndex + e.index,
                }),
            });
        }
        else {
            throw e;
        }
    }
}

class ObjectExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof ObjectPType, `ObjectExpressionBuilder must be instantiated with ptype of ObjectPType`);
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        const propertyIndex = this.ptype.orderedProperties().findIndex(([prop]) => prop === name);
        if (propertyIndex === -1) {
            return super.memberAccess(name, sourceLocation);
        }
        const propertyPtype = this.ptype.getPropertyType(name);
        return instanceEb(nodeFactory.fieldExpression({
            name,
            sourceLocation,
            base: this._expr,
            wtype: propertyPtype.wtypeOrThrow,
        }), propertyPtype);
    }
    hasProperty(name) {
        return this.ptype.orderedProperties().some(([prop]) => prop === name);
    }
    resolvableToPType(ptype) {
        if (ptype instanceof ObjectPType) {
            return ptype.orderedProperties().every(([prop, propType]) => this.ptype.hasPropertyOfType(prop, propType));
        }
        return false;
    }
    resolveToPType(ptype) {
        if (ptype.equals(this.ptype)) {
            return this;
        }
        if (this.resolvableToPType(ptype)) {
            const base = this.singleEvaluation();
            return instanceEb(nodeFactory.tupleExpression({
                sourceLocation: this.sourceLocation,
                items: ptype
                    .orderedProperties()
                    .map(([prop, propType]) => requireExpressionOfType(base.memberAccess(prop, this.sourceLocation), propType)),
                wtype: ptype.wtype,
            }), ptype);
        }
        throw CodeError.cannotResolveToType({ sourceType: this.ptype, targetType: ptype, sourceLocation: this.sourceLocation });
    }
}

class ObjectLiteralExpressionBuilder extends LiteralExpressionBuilder {
    parts;
    _ptype;
    get ptype() {
        return this._ptype;
    }
    constructor(sourceLocation, ptype, parts) {
        super(sourceLocation);
        this.parts = parts;
        this._ptype = ptype;
    }
    resolve() {
        // Resolve object to a tuple using its own inferred types
        return this.toTuple(this.ptype);
    }
    resolveLValue() {
        return nodeFactory.tupleExpression({
            items: this.ptype
                .orderedProperties()
                .map(([p, propPType]) => requireInstanceBuilder(this.memberAccess(p, this.sourceLocation)).resolveLValue()),
            sourceLocation: this.sourceLocation,
            wtype: this.ptype.wtype,
        });
    }
    memberAccess(name, sourceLocation) {
        for (const part of this.parts.toReversed()) {
            if (part.type === 'properties') {
                if (Object.hasOwn(part.properties, name)) {
                    return part.properties[name];
                }
            }
            else {
                if (part.obj.hasProperty(name)) {
                    return part.obj.memberAccess(name, sourceLocation);
                }
            }
        }
        throw new CodeError(`${name} does not exist on ${this.typeDescription}`, { sourceLocation });
    }
    hasProperty(name) {
        return this.parts.some((part) => (part.type === 'properties' ? Object.hasOwn(part.properties, name) : part.obj.hasProperty(name)));
    }
    toTuple(ptype) {
        let base;
        if (this.ptype.equals(ptype)) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            base = this;
        }
        else {
            // Resolve this object to a tuple using declared order but using the target property types.
            // This will resolve numeric literals to algo-ts types if available
            const tempType = new ObjectPType({
                properties: Object.fromEntries(this.ptype.orderedProperties().map(([p]) => [p, ptype.getPropertyType(p)])),
            });
            base = new ObjectExpressionBuilder(nodeFactory.tupleExpression({
                items: tempType
                    .orderedProperties()
                    .map(([p, propType]) => requireExpressionOfType(this.memberAccess(p, this.sourceLocation), propType)),
                sourceLocation: this.sourceLocation,
                wtype: tempType.wtype,
            }), tempType).singleEvaluation();
        }
        // Reorder properties to the target type
        return nodeFactory.tupleExpression({
            items: ptype
                .orderedProperties()
                .map(([p, propPType]) => requireExpressionOfType(base.memberAccess(p, this.sourceLocation), propPType)),
            sourceLocation: this.sourceLocation,
            wtype: ptype.wtype,
        });
    }
    resolvableToPType(ptype) {
        if (!(ptype instanceof ObjectPType))
            return false;
        for (const [prop, propPType] of ptype.orderedProperties()) {
            if (!this.hasProperty(prop))
                return false;
            const propValue = requestExpressionOfType(this.memberAccess(prop, this.sourceLocation), propPType);
            if (propValue === undefined)
                return false;
        }
        return true;
    }
    resolveToPType(ptype) {
        if (!this.resolvableToPType(ptype))
            throw new CodeError(`${this.typeDescription} cannot be resolved to ${ptype}`, { sourceLocation: this.sourceLocation });
        return new ObjectExpressionBuilder(this.toTuple(ptype), ptype);
    }
}

const ocaMap = {
    NoOp: OnCompletionAction.NoOp,
    OptIn: OnCompletionAction.OptIn,
    CloseOut: OnCompletionAction.CloseOut,
    ClearState: OnCompletionAction.ClearState,
    UpdateApplication: OnCompletionAction.UpdateApplication,
    DeleteApplication: OnCompletionAction.DeleteApplication,
};
const createMap = {
    allow: ARC4CreateOption.allow,
    require: ARC4CreateOption.require,
    disallow: ARC4CreateOption.disallow,
};
class Arc4BareMethodDecoratorBuilder extends NodeBuilder {
    get ptype() {
        return arc4BareMethodDecorator;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [{ allowActions, onCreate }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: 'arc4.baremethod',
            argSpec: (a) => [
                a.obj({
                    allowActions: a.optional(stringPType, new ArrayPType({ elementType: stringPType })),
                    onCreate: a.optional(stringPType),
                }),
            ],
        });
        return new DecoratorDataBuilder(sourceLocation, {
            type: Constants.symbolNames.arc4BareDecoratorName,
            allowedCompletionTypes: allowActions && resolveOnCompletionActions(allowActions),
            allowedCompletionTypesLocation: allowActions?.sourceLocation,
            create: onCreate && mapStringConstant(createMap, onCreate?.resolve()),
            createLocation: onCreate?.sourceLocation,
            sourceLocation: sourceLocation,
        });
    }
}
class Arc4AbiMethodDecoratorBuilder extends NodeBuilder {
    get ptype() {
        return arc4AbiMethodDecorator;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [{ allowActions, onCreate, readonly, name, defaultArguments }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: 'arc4.abimethod',
            argSpec: (a) => [
                a.obj({
                    allowActions: a.optional(stringPType, new ArrayPType({ elementType: stringPType })),
                    onCreate: a.optional(stringPType),
                    readonly: a.optional(boolPType),
                    name: a.optional(stringPType),
                    defaultArguments: a.optional(),
                }),
            ],
        });
        return new DecoratorDataBuilder(sourceLocation, {
            type: Constants.symbolNames.arc4AbiDecoratorName,
            allowedCompletionTypes: allowActions && resolveOnCompletionActions(allowActions),
            allowedCompletionTypesLocation: allowActions?.sourceLocation,
            create: onCreate && mapStringConstant(createMap, onCreate?.resolve()),
            createLocation: onCreate?.sourceLocation,
            sourceLocation: sourceLocation,
            nameOverride: name ? requireStringConstant(name).value : undefined,
            readonly: readonly ? requireBooleanConstant(readonly).value : false,
            defaultArguments: resolveDefaultArguments(defaultArguments, sourceLocation),
        });
    }
}
function mapStringConstant(map, expr) {
    codeInvariant(expr instanceof StringConstant, 'Expected string literal', expr.sourceLocation);
    const strValue = expr.value;
    if (Object.hasOwn(map, strValue))
        return map[strValue];
    throw new CodeError(`${strValue} is not valid at this location`, { sourceLocation: expr.sourceLocation });
}
function resolveOnCompletionActions(oca) {
    const value = oca.resolve();
    let ocaRawExpr;
    if (value instanceof StringConstant) {
        ocaRawExpr = [value];
    }
    else if (value instanceof TupleExpression) {
        ocaRawExpr = value.items;
    }
    else if (value instanceof NewArray) {
        ocaRawExpr = value.values;
    }
    else {
        throw new CodeError('Unexpected value for onComplete', { sourceLocation: oca.sourceLocation });
    }
    const ocas = ocaRawExpr.map((item) => mapStringConstant(ocaMap, item));
    const distinctOcas = Array.from(new Set(ocas));
    if (distinctOcas.length !== ocas.length) {
        logger.warn(oca.sourceLocation, 'Duplicate on completion actions');
    }
    codeInvariant(distinctOcas.length, 'Method must allow at least one on complete action', oca.sourceLocation);
    return ocas;
}
function resolveDefaultArguments(defaultArguments, sourceLocation) {
    const result = {};
    if (!defaultArguments)
        return result;
    codeInvariant(defaultArguments instanceof ObjectLiteralExpressionBuilder, `Default argument specification should be an object literal`);
    for (const [parameterName] of defaultArguments.ptype.orderedProperties()) {
        const paramConfig = defaultArguments.memberAccess(parameterName, sourceLocation);
        codeInvariant(paramConfig instanceof ObjectLiteralExpressionBuilder, 'Default argument specification should be an object literal');
        if (paramConfig.hasProperty('constant')) {
            result[parameterName] = {
                type: 'constant',
                value: requireInstanceBuilder(paramConfig.memberAccess('constant', sourceLocation)),
            };
        }
        else if (paramConfig.hasProperty('from')) {
            result[parameterName] = {
                type: 'member',
                name: requireStringConstant(paramConfig.memberAccess('from', sourceLocation)).value,
            };
        }
        else {
            logger.error(sourceLocation, 'Default argument specifications should specify fromConstant or fromMember');
        }
    }
    return result;
}

const intrinsicFactory = {
    bytesConcat({ left, right, sourceLocation }) {
        if (left.wtype.equals(right.wtype)) {
            if (left instanceof BytesConstant && right instanceof BytesConstant) {
                const concatValue = new Uint8Array(left.value.length + right.value.length);
                concatValue.set(left.value, 0);
                concatValue.set(right.value, left.value.length);
                return nodeFactory.bytesConstant({
                    value: concatValue,
                    wtype: left.wtype,
                    encoding: left.encoding,
                    sourceLocation,
                });
            }
            else if (left instanceof StringConstant && right instanceof StringConstant) {
                return nodeFactory.stringConstant({
                    value: left.value + right.value,
                    sourceLocation,
                });
            }
        }
        return nodeFactory.intrinsicCall({
            sourceLocation,
            stackArgs: [left, right],
            immediates: [],
            wtype: left.wtype,
            opCode: 'concat',
        });
    },
    err({ sourceLocation, comment }) {
        return nodeFactory.assertExpression({
            condition: null,
            sourceLocation,
            wtype: wtypes.voidWType,
            errorMessage: comment,
        });
    },
    assert({ sourceLocation, comment, condition }) {
        return nodeFactory.assertExpression({
            sourceLocation,
            condition,
            wtype: wtypes.voidWType,
            errorMessage: comment,
        });
    },
    bytesLen({ value, sourceLocation }) {
        return nodeFactory.intrinsicCall({
            opCode: 'len',
            stackArgs: [value],
            sourceLocation: sourceLocation,
            immediates: [],
            wtype: wtypes.uint64WType,
        });
    },
    bitLen({ value, sourceLocation }) {
        return nodeFactory.intrinsicCall({
            opCode: 'bitlen',
            stackArgs: [value],
            sourceLocation: sourceLocation,
            immediates: [],
            wtype: wtypes.uint64WType,
        });
    },
    itob({ value, sourceLocation }) {
        if (value instanceof IntegerConstant) {
            return nodeFactory.bytesConstant({
                sourceLocation,
                value: bigIntToUint8Array(value.value, value.wtype.equals(wtypes.uint64WType) ? 8 : 'dynamic'),
                encoding: BytesEncoding.base16,
            });
        }
        return nodeFactory.intrinsicCall({
            sourceLocation,
            stackArgs: [value],
            immediates: [],
            wtype: wtypes.bytesWType,
            opCode: 'itob',
        });
    },
    btoi({ value, sourceLocation }) {
        return nodeFactory.intrinsicCall({
            sourceLocation,
            stackArgs: [value],
            immediates: [],
            wtype: wtypes.uint64WType,
            opCode: 'btoi',
        });
    },
    bzero({ size, sourceLocation, wtype = wtypes.bytesWType }) {
        return nodeFactory.intrinsicCall({
            opCode: 'bzero',
            immediates: [],
            stackArgs: [
                nodeFactory.uInt64Constant({
                    value: size,
                    sourceLocation,
                }),
            ],
            sourceLocation,
            wtype: wtype,
        });
    },
};

class IterableIteratorExpressionBuilder extends InstanceExpressionBuilder {
    resolve() {
        throw new CodeError(`${this.typeDescription} can only be used in for loops`, { sourceLocation: this.sourceLocation });
    }
    constructor(expr, ptype) {
        invariant(ptype instanceof IterableIteratorType, 'ptype must be instance of IterableIteratorType');
        super(expr, ptype);
    }
    iterate(sourceLocation) {
        return this._expr;
    }
}

class Arc4CopyFunctionBuilder extends FunctionBuilder {
    baseBuilder;
    constructor(baseBuilder) {
        super(baseBuilder.sourceLocation);
        this.baseBuilder = baseBuilder;
    }
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({ args, typeArgs, genericTypeArgs: 0, argSpec: (a) => [], funcName: 'copy', callLocation: sourceLocation });
        return instanceEb(nodeFactory.copy({
            value: this.baseBuilder.resolve(),
            sourceLocation,
        }), this.baseBuilder.ptype);
    }
}

function getBigIntOrUint64Expr(builder) {
    if (builder.ptype.equals(numberPType)) {
        invariant(builder instanceof BigIntLiteralExpressionBuilder, 'Builder for number type must be BigIntLiteral', builder.sourceLocation);
        return builder.value;
    }
    else {
        invariant(builder.ptype.equals(uint64PType), 'Builder must be uint64 if not number', builder.sourceLocation);
        return builder.resolve();
    }
}

function translateNegativeIndex(arrayLength, index) {
    const indexParam = getBigIntOrUint64Expr(index);
    if (typeof indexParam === 'bigint') {
        if (typeof arrayLength === 'bigint') {
            let indexValue = indexParam < 0 ? arrayLength + indexParam : indexParam;
            if (indexValue < 0n || indexValue >= arrayLength) {
                logger.error(index.sourceLocation, 'Index access out of bounds');
                indexValue = 0n;
            }
            return nodeFactory.uInt64Constant({
                value: indexValue,
                sourceLocation: index.sourceLocation,
            });
        }
        else {
            return nodeFactory.uInt64BinaryOperation({
                op: UInt64BinaryOperator.sub,
                left: arrayLength,
                right: nodeFactory.uInt64Constant({
                    value: indexParam * -1n,
                    sourceLocation: index.sourceLocation,
                }),
                sourceLocation: index.sourceLocation,
            });
        }
    }
    else {
        return indexParam;
    }
}

class AtFunctionBuilder extends FunctionBuilder {
    expr;
    itemPType;
    exprLength;
    constructor(expr, itemPType, exprLength) {
        super(expr.sourceLocation);
        this.expr = expr;
        this.itemPType = itemPType;
        this.exprLength = exprLength;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [index], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'at',
            argSpec: (a) => [a.required(uint64PType, numberPType)],
        });
        return instanceEb(nodeFactory.indexExpression({
            base: this.expr,
            sourceLocation: sourceLocation,
            index: translateNegativeIndex(this.exprLength, index),
            wtype: this.itemPType.wtypeOrThrow,
        }), this.itemPType);
    }
}

class ArrayPopFunctionBuilder extends FunctionBuilder {
    arrayBuilder;
    constructor(arrayBuilder) {
        super(arrayBuilder.sourceLocation);
        this.arrayBuilder = arrayBuilder;
    }
    call(args, typeArgs, sourceLocation) {
        const elementType = this.arrayBuilder.ptype.elementType;
        parseFunctionArgs({
            args,
            typeArgs,
            funcName: 'pop',
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: () => [],
        });
        return instanceEb(nodeFactory.arrayPop({
            base: this.arrayBuilder.resolve(),
            sourceLocation,
            wtype: elementType.wtypeOrThrow,
        }), elementType);
    }
}

class ArrayPushFunctionBuilder extends FunctionBuilder {
    arrayBuilder;
    constructor(arrayBuilder) {
        super(arrayBuilder.sourceLocation);
        this.arrayBuilder = arrayBuilder;
    }
    call(args, typeArgs, sourceLocation) {
        const elementType = this.arrayBuilder.ptype.elementType;
        const { args: [...items], } = parseFunctionArgs({
            args,
            typeArgs,
            funcName: 'push',
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: (a) => [a.required(elementType), ...args.slice(1).map(() => a.required(elementType))],
        });
        return instanceEb(nodeFactory.arrayExtend({
            base: this.arrayBuilder.resolve(),
            other: nodeFactory.tupleExpression({
                items: items.map((i) => i.resolve()),
                sourceLocation,
            }),
            sourceLocation,
            wtype: wtypes.voidWType,
        }), voidPType);
    }
}

class SliceFunctionBuilder extends FunctionBuilder {
    base;
    resultPType;
    constructor(base, resultPType) {
        super(base.sourceLocation);
        this.base = base;
        this.resultPType = resultPType;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [start, stop], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'slice',
            argSpec: (a) => [a.optional(uint64PType, numberPType), a.optional(uint64PType, numberPType)],
        });
        return instanceEb(nodeFactory.intersectionSliceExpression({
            base: this.base,
            sourceLocation: sourceLocation,
            beginIndex: start ? getBigIntOrUint64Expr(start) : null,
            endIndex: stop ? getBigIntOrUint64Expr(stop) : null,
            wtype: this.resultPType.wtype,
        }), this.resultPType);
    }
}

class BooleanFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [value], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: 'Boolean',
            argSpec: (a) => [a.optional()],
        });
        if (!value) {
            return new BooleanExpressionBuilder(nodeFactory.boolConstant({ value: false, sourceLocation }));
        }
        if (value.ptype.equals(boolPType)) {
            return value;
        }
        if (value.ptype.equals(bytesPType)) {
            return new BooleanExpressionBuilder(nodeFactory.bytesComparisonExpression({
                sourceLocation,
                operator: EqualityComparison.ne,
                lhs: value.resolve(),
                rhs: nodeFactory.bytesConstant({ value: new Uint8Array(), sourceLocation }),
            }));
        }
        else if (value.ptype.equals(stringPType)) {
            return new BooleanExpressionBuilder(nodeFactory.bytesComparisonExpression({
                sourceLocation,
                operator: EqualityComparison.ne,
                lhs: value.toBytes(sourceLocation),
                rhs: nodeFactory.bytesConstant({ value: new Uint8Array(), sourceLocation }),
            }));
        }
        else {
            return new BooleanExpressionBuilder(nodeFactory.not({
                sourceLocation,
                expr: nodeFactory.not({
                    sourceLocation,
                    expr: value.boolEval(sourceLocation),
                }),
            }));
        }
    }
}
class BooleanExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr) {
        super(expr, boolPType);
    }
    boolEval(sourceLocation, negate) {
        if (negate) {
            return nodeFactory.not({ sourceLocation, expr: this._expr });
        }
        return this._expr;
    }
    toBytes(sourceLocation) {
        return intrinsicFactory.itob({
            value: this._expr,
            sourceLocation,
        });
    }
    compare(other, op, sourceLocation) {
        const operator = tryConvertEnum(op, BuilderComparisonOp, NumericComparison);
        codeInvariant(operator, `${op} is not supported on ${this.typeDescription}`, sourceLocation);
        return new BooleanExpressionBuilder(nodeFactory.numericComparisonExpression({
            operator,
            lhs: this.resolve(),
            rhs: other.resolveToPType(boolPType).resolve(),
            sourceLocation,
        }));
    }
}

function compareUint64(left, right, op, sourceLocation, typeDescription) {
    const numComOp = tryConvertEnum(op, BuilderComparisonOp, NumericComparison);
    if (numComOp === undefined) {
        logger.error(sourceLocation, `${typeDescription} does not support the '${op}' operator`);
    }
    return new BooleanExpressionBuilder(nodeFactory.numericComparisonExpression({
        sourceLocation,
        operator: numComOp ?? NumericComparison.eq,
        lhs: left,
        rhs: right,
    }));
}

function stringToBigint({ value, sourceLocation }) {
    try {
        return BigInt(value);
    }
    catch (e) {
        if (e instanceof SyntaxError) {
            throw new CodeError(`Cannot convert ${value} to an integer`, { sourceLocation });
        }
        throw e;
    }
}

class UInt64FunctionBuilder extends FunctionBuilder {
    ptype = Uint64Function;
    call(args, typeArgs, sourceLocation) {
        const { args: [value], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'Uint64',
            argSpec: (a) => [a.optional(uint64PType, boolPType, stringPType)],
        });
        if (!value) {
            return new UInt64ExpressionBuilder(nodeFactory.uInt64Constant({
                sourceLocation,
                value: 0n,
            }));
        }
        if (value.ptype.equals(boolPType)) {
            const expr = value.resolve();
            if (expr instanceof BoolConstant) {
                return new UInt64ExpressionBuilder(nodeFactory.uInt64Constant({
                    sourceLocation,
                    value: expr.value ? 1n : 0n,
                }));
            }
            else {
                return new UInt64ExpressionBuilder(nodeFactory.reinterpretCast({
                    expr,
                    wtype: wtypes.uint64WType,
                    sourceLocation,
                }));
            }
        }
        else if (value.ptype.equals(stringPType)) {
            const valueStr = requireStringConstant(value);
            return new UInt64ExpressionBuilder(nodeFactory.uInt64Constant({
                value: stringToBigint(valueStr),
                sourceLocation,
            }));
        }
        return value;
    }
}
class UInt64ExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr) {
        super(expr, uint64PType);
    }
    boolEval(sourceLocation, negate) {
        const asBool = nodeFactory.reinterpretCast({
            sourceLocation,
            expr: this.resolve(),
            wtype: wtypes.boolWType,
        });
        if (negate) {
            return nodeFactory.not({
                expr: asBool,
                sourceLocation,
            });
        }
        return asBool;
    }
    compare(other, op, sourceLocation) {
        const otherExpr = requireExpressionOfType(other, uint64PType);
        return compareUint64(this._expr, otherExpr, op, sourceLocation, this.typeDescription);
    }
    prefixUnaryOp(op, sourceLocation) {
        let binaryOp;
        switch (op) {
            case BuilderUnaryOp.inc:
                binaryOp = UInt64BinaryOperator.add;
                break;
            case BuilderUnaryOp.dec:
                binaryOp = UInt64BinaryOperator.sub;
                break;
            case BuilderUnaryOp.bit_inv:
                return new UInt64ExpressionBuilder(nodeFactory.uInt64UnaryOperation({
                    op: UInt64UnaryOperator.bitInvert,
                    sourceLocation,
                    expr: this.resolve(),
                    wtype: this.ptype.wtype,
                }));
            case BuilderUnaryOp.pos:
                return this;
            default:
                return super.prefixUnaryOp(op, sourceLocation);
        }
        return new UInt64ExpressionBuilder(nodeFactory.assignmentExpression({
            target: this.resolveLValue(),
            sourceLocation,
            value: nodeFactory.uInt64BinaryOperation({
                left: this.resolve(),
                right: nodeFactory.uInt64Constant({ value: 1n, sourceLocation }),
                op: binaryOp,
                sourceLocation,
            }),
        }));
    }
    postfixUnaryOp(op, sourceLocation) {
        let unaryOp;
        switch (op) {
            case BuilderUnaryOp.inc:
                unaryOp = UInt64PostfixUnaryOperator.increment;
                break;
            case BuilderUnaryOp.dec:
                unaryOp = UInt64PostfixUnaryOperator.decrement;
                break;
            default:
                return super.postfixUnaryOp(op, sourceLocation);
        }
        return new UInt64ExpressionBuilder(nodeFactory.uInt64PostfixUnaryOperation({
            sourceLocation,
            target: this.resolveLValue(),
            wtype: this.ptype.wtype,
            op: unaryOp,
        }));
    }
    binaryOp(other, op, sourceLocation) {
        const otherExpr = requireExpressionOfType(other, uint64PType);
        const uintOp = op === BuilderBinaryOp.div ? UInt64BinaryOperator.floorDiv : tryConvertEnum(op, BuilderBinaryOp, UInt64BinaryOperator);
        if (uintOp === undefined) {
            throw new NotSupported(`UInt64 binary operator ${op}`, {
                sourceLocation,
            });
        }
        return new UInt64ExpressionBuilder(nodeFactory.uInt64BinaryOperation({
            left: this._expr,
            right: otherExpr,
            op: uintOp,
            sourceLocation,
        }));
    }
    augmentedAssignment(other, op, sourceLocation) {
        return new UInt64ExpressionBuilder(nodeFactory.assignmentExpression({
            target: this.resolveLValue(),
            value: this.binaryOp(other, op, sourceLocation).resolve(),
            sourceLocation,
        }));
    }
    toBytes(sourceLocation) {
        return intrinsicFactory.itob({ value: this.resolve(), sourceLocation });
    }
}

function concatArrays(left, right, sourceLocation) {
    if (left.ptype instanceof StaticBytesType || left.ptype instanceof StaticArrayType) {
        /*
          TODO: This is only required because puya doesn't support staticarray + other => dynamic array
          To work around this, we convert arc4 static bytes and static array to dynamic bytes and dynamic array
         */
        const dynamicType = left.ptype instanceof StaticBytesType ? DynamicBytesType : new DynamicArrayType({ ...left.ptype });
        return concatArrays(toArc4Dynamic(left.ptype.arraySize, left.resolve(), dynamicType), right, sourceLocation);
    }
    const returnType = getArrayConcatType(left.ptype, right.ptype, sourceLocation);
    return instanceEb(nodeFactory.arrayConcat({
        left: left.resolve(),
        right: right.resolve(),
        wtype: returnType.wtype,
        sourceLocation,
    }), returnType);
}
function getArrayConcatType(left, right, sourceLocation) {
    if (left instanceof ARC4ArrayType) {
        if (right instanceof ARC4ArrayType) {
            sameElementType(left.elementType, right.elementType, sourceLocation);
            if (left.equals(DynamicBytesType) || left instanceof StaticBytesType) {
                return DynamicBytesType;
            }
            return new DynamicArrayType({
                elementType: left.elementType,
            });
        }
    }
    else if (left instanceof ArrayPType || left instanceof ArrayLiteralPType) {
        if (right instanceof ArrayPType || right instanceof ArrayLiteralPType || right instanceof ARC4ArrayType) {
            sameElementType(left.elementType, right.elementType, sourceLocation);
            return new ArrayPType({
                elementType: left.elementType,
            });
        }
        if (right instanceof TuplePType) {
            right.items.forEach((i) => sameElementType(left.elementType, i, sourceLocation));
            return new ArrayPType({
                elementType: left.elementType,
            });
        }
    }
    cannotConcat(left, right, sourceLocation);
}
function cannotConcat(left, right, sourceLocation) {
    throw new CodeError(`Cannot concat ${left} with ${right}`, { sourceLocation });
}
function sameElementType(left, right, sourceLocation) {
    codeInvariant(left.equals(right), `Cannot concat array of type ${left} with iterable of type ${right}`, sourceLocation);
}
function toArc4Dynamic(staticSize, staticBytes, dynamicType) {
    return instanceEb(nodeFactory.reinterpretCast({
        expr: intrinsicFactory.bytesConcat({
            left: nodeFactory.bytesConstant({
                value: bigIntToUint8Array(staticSize, 2),
                sourceLocation: staticBytes.sourceLocation,
            }),
            right: nodeFactory.reinterpretCast({
                expr: staticBytes,
                wtype: wtypes.bytesWType,
                sourceLocation: staticBytes.sourceLocation,
            }),
            sourceLocation: staticBytes.sourceLocation,
        }),
        wtype: dynamicType.wtype,
        sourceLocation: staticBytes.sourceLocation,
    }), dynamicType);
}

function arrayElementType(arrayType, sourceLocation) {
    if (arrayType instanceof ARC4ArrayType)
        return arrayType.elementType;
    if (arrayType instanceof ArrayPType)
        return arrayType.elementType;
    if (arrayType instanceof ArrayLiteralPType)
        return arrayType.elementType;
    throw new CodeError(`${arrayType} does not appear to be an array type`, { sourceLocation });
}

function indexAccess(target, index, sourceLocation) {
    const indexExpr = requireExpressionOfType(index, uint64PType);
    if (indexExpr instanceof IntegerConstant && target.ptype instanceof StaticArrayType && indexExpr.value >= target.ptype.arraySize) {
        logger.error(index.sourceLocation, 'Index access out of bounds');
    }
    const elementType = arrayElementType(target.ptype, sourceLocation);
    return instanceEb(nodeFactory.indexExpression({
        base: target.resolve(),
        sourceLocation: sourceLocation,
        index: indexExpr,
        wtype: elementType.wtypeOrThrow,
    }), elementType);
}

const StaticIterator = Symbol('StaticIterator');
function isStaticallyIterable(builder) {
    return StaticIterator in builder;
}

function arrayLength(array, sourceLocation) {
    if (isStaticallyIterable(array)) {
        return instanceEb(nodeFactory.uInt64Constant({
            value: BigInt(array[StaticIterator]().length),
            sourceLocation,
        }), uint64PType);
    }
    return instanceEb(nodeFactory.arrayLength({
        array: array.resolve(),
        sourceLocation,
    }), uint64PType);
}

/**
 * Given a builder, attempt to resolve it to the target type converting compatible types as possible
 *
 * @param builder
 * @param targetType
 */
function resolveCompatBuilder(builder, targetType) {
    codeInvariant(builder instanceof InstanceBuilder, `Cannot resolve ${builder.typeDescription} to a value`, builder.sourceLocation);
    if (builder.resolvableToPType(targetType)) {
        return builder.resolveToPType(targetType);
    }
    if (targetType.equals(accountPType)) {
        if (builder.resolvableToPType(bytesPType)) {
            // Account bytes should just be cast
            return builder.resolveToPType(bytesPType).reinterpretCast(accountPType);
        }
    }
    else if (targetType.equals(applicationPType) || targetType.equals(assetPType) || targetType.equals(onCompleteActionType)) {
        if (builder.resolvableToPType(uint64PType)) {
            return builder.resolveToPType(uint64PType).reinterpretCast(targetType);
        }
    }
    else if (targetType.equals(bytesPType)) {
        if (builder.resolvableToPType(stringPType)) {
            return instanceEb(builder.resolveToPType(stringPType).toBytes(builder.sourceLocation), bytesPType);
        }
    }
    throw new CodeError(`Cannot resolve ${builder.ptype} to ${targetType}`, { sourceLocation: builder.sourceLocation });
}
function resolveCompatExpression(builder, targetType) {
    return resolveCompatBuilder(builder, targetType).resolve();
}

class StringFunctionBuilder extends FunctionBuilder {
    taggedTemplate(head, spans, sourceLocation) {
        let result = nodeFactory.stringConstant({
            sourceLocation,
            value: head,
        });
        for (const [value, joiningText] of spans) {
            const valueStr = value.toString(sourceLocation);
            result = nodeFactory.bytesBinaryOperation({
                left: result,
                right: valueStr,
                op: BytesBinaryOperator.add,
                sourceLocation,
                wtype: wtypes.stringWType,
            });
            if (joiningText) {
                result = nodeFactory.bytesBinaryOperation({
                    left: result,
                    right: nodeFactory.stringConstant({
                        sourceLocation,
                        value: joiningText,
                    }),
                    op: BytesBinaryOperator.add,
                    sourceLocation,
                    wtype: wtypes.stringWType,
                });
            }
        }
        return new StringExpressionBuilder(result);
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [value], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: 'String',
            genericTypeArgs: 0,
            argSpec: (a) => [a.optional(bytesPType)],
        });
        if (!value) {
            return new StringExpressionBuilder(nodeFactory.stringConstant({
                sourceLocation,
                value: '',
            }));
        }
        return new StringExpressionBuilder(nodeFactory.reinterpretCast({
            expr: value.resolve(),
            sourceLocation,
            wtype: wtypes.stringWType,
        }));
    }
}
class StringExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr) {
        super(expr, stringPType);
    }
    resolvableToPType(ptype) {
        return super.resolvableToPType(ptype);
    }
    resolveToPType(ptype) {
        return super.resolveToPType(ptype);
    }
    boolEval(sourceLocation, negate = false) {
        return new UInt64ExpressionBuilder(intrinsicFactory.bytesLen({
            value: this._expr,
            sourceLocation,
        })).boolEval(sourceLocation, negate);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'concat':
                return new ConcatExpressionBuilder$1(this._expr);
        }
        return super.memberAccess(name, sourceLocation);
    }
    compare(other, op, sourceLocation) {
        const otherExpr = requireExpressionOfType(other, stringPType);
        const numComOp = tryConvertEnum(op, BuilderComparisonOp, EqualityComparison);
        if (numComOp === undefined) {
            throw new NotSupported(`Numeric comparison operator ${op}`, {
                sourceLocation,
            });
        }
        return instanceEb(nodeFactory.bytesComparisonExpression({
            lhs: this._expr,
            rhs: otherExpr,
            operator: numComOp,
            sourceLocation,
        }), boolPType);
    }
    binaryOp(other, op, sourceLocation) {
        switch (op) {
            case BuilderBinaryOp.add:
                return new StringExpressionBuilder(intrinsicFactory.bytesConcat({
                    left: this.resolve(),
                    right: requireExpressionOfType(other, stringPType),
                    sourceLocation,
                }));
        }
        return super.binaryOp(other, op, sourceLocation);
    }
    augmentedAssignment(other, op, sourceLocation) {
        const newValue = this.binaryOp(other, op, sourceLocation);
        return new StringExpressionBuilder(nodeFactory.assignmentExpression({
            target: this.resolveLValue(),
            sourceLocation,
            value: newValue.resolve(),
        }));
    }
    toBytes(sourceLocation) {
        if (this._expr instanceof StringConstant) {
            return nodeFactory.bytesConstant({
                value: utf8ToUint8Array(this._expr.value),
                encoding: BytesEncoding.utf8,
                sourceLocation: this._expr.sourceLocation,
            });
        }
        return nodeFactory.reinterpretCast({
            expr: this._expr,
            sourceLocation,
            wtype: wtypes.bytesWType,
        });
    }
    toString() {
        return this.resolve();
    }
}
let ConcatExpressionBuilder$1 = class ConcatExpressionBuilder extends FunctionBuilder {
    expr;
    constructor(expr) {
        super(expr.sourceLocation);
        this.expr = expr;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: others } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'concat',
            argSpec: (a) => args.map((_) => a.required(stringPType)),
        });
        return new StringExpressionBuilder(others.reduce((acc, cur) => intrinsicFactory.bytesConcat({
            left: acc,
            right: cur.resolve(),
            sourceLocation: sourceLocation,
        }), this.expr));
    }
};

const builderCompareToBytesCompare = {
    [BuilderComparisonOp.ne]: EqualityComparison.ne,
    [BuilderComparisonOp.eq]: EqualityComparison.eq,
    [BuilderComparisonOp.lt]: undefined,
    [BuilderComparisonOp.lte]: undefined,
    [BuilderComparisonOp.gt]: undefined,
    [BuilderComparisonOp.gte]: undefined,
};
function compareBytes(left, right, op, sourceLocation, typeDescription) {
    const equalityOp = builderCompareToBytesCompare[op];
    if (equalityOp === undefined) {
        logger.error(sourceLocation, `${typeDescription} does not support the '${op}' operator`);
    }
    return new BooleanExpressionBuilder(nodeFactory.bytesComparisonExpression({
        sourceLocation,
        operator: equalityOp ?? EqualityComparison.eq,
        lhs: left,
        rhs: right,
    }));
}

class BytesFunctionBuilder extends FunctionBuilder {
    ptype = BytesFunction;
    taggedTemplate(head, spans, sourceLocation) {
        let result = nodeFactory.bytesConstant({
            sourceLocation,
            encoding: BytesEncoding.utf8,
            value: utf8ToUint8Array(head),
        });
        for (const [value, joiningText] of spans) {
            const valueBytes = value.ptype?.equals(stringPType) ? value.resolve() : value.toBytes(sourceLocation);
            result = nodeFactory.bytesBinaryOperation({
                left: result,
                right: valueBytes,
                op: BytesBinaryOperator.add,
                sourceLocation,
                wtype: wtypes.bytesWType,
            });
            if (joiningText) {
                result = nodeFactory.bytesBinaryOperation({
                    left: result,
                    right: nodeFactory.bytesConstant({
                        sourceLocation,
                        value: utf8ToUint8Array(joiningText),
                        encoding: BytesEncoding.utf8,
                    }),
                    op: BytesBinaryOperator.add,
                    sourceLocation,
                    wtype: wtypes.bytesWType,
                });
            }
        }
        return new BytesExpressionBuilder(result);
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [initialValue], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'Bytes',
            argSpec: (a) => [
                a.optional(numberPType, bigIntPType, uint64PType, biguintPType, stringPType, bytesPType, new ArrayPType({ elementType: uint64PType })),
            ],
        });
        const empty = nodeFactory.bytesConstant({
            sourceLocation,
            value: new Uint8Array(),
        });
        let bytesExpr;
        if (!initialValue) {
            bytesExpr = empty;
        }
        else if (initialValue instanceof BigIntLiteralExpressionBuilder) {
            logger.error(initialValue.sourceLocation, initialValue.ptype.expressionMessage);
            bytesExpr = empty;
        }
        else if (initialValue.ptype.equals(uint64PType)) {
            bytesExpr = initialValue.toBytes(sourceLocation);
        }
        else if (initialValue.ptype.equals(biguintPType)) {
            bytesExpr = initialValue.toBytes(sourceLocation);
        }
        else if (initialValue.ptype.equals(stringPType)) {
            bytesExpr = initialValue.toBytes(sourceLocation);
        }
        else if (initialValue.ptype.equals(bytesPType)) {
            return initialValue;
        }
        else {
            if (isStaticallyIterable(initialValue)) {
                const bytes = [];
                for (const item of initialValue[StaticIterator]()) {
                    const byte = item.resolve();
                    if (byte instanceof IntegerConstant && byte.value < 256n) {
                        bytes.push(Number(byte.value));
                    }
                    else {
                        logger.error(item.sourceLocation, 'A compile time constant value between 0 and 255 is expected here');
                        break;
                    }
                }
                bytesExpr = nodeFactory.bytesConstant({
                    value: Uint8Array.from(bytes),
                    sourceLocation: initialValue.sourceLocation,
                });
            }
            else {
                logger.error(initialValue.sourceLocation, 'Only array literals or tuples are supported here');
                bytesExpr = empty;
            }
        }
        return new BytesExpressionBuilder(bytesExpr);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'fromHex':
                return new FromEncodingBuilder(sourceLocation, hexToUint8Array, BytesEncoding.base16, 'fromHex');
            case 'fromBase32':
                return new FromEncodingBuilder(sourceLocation, base32ToUint8Array, BytesEncoding.base32, 'fromBase32');
            case 'fromBase64':
                return new FromEncodingBuilder(sourceLocation, base64ToUint8Array, BytesEncoding.base64, 'fromBase64');
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class FromEncodingBuilder extends FunctionBuilder {
    decodeLiteral;
    encoding;
    functionName;
    constructor(sourceLocation, decodeLiteral, encoding, functionName) {
        super(sourceLocation);
        this.decodeLiteral = decodeLiteral;
        this.encoding = encoding;
        this.functionName = functionName;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [valueBuilder], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            funcName: this.functionName,
            argSpec: (a) => [a.required(stringPType)],
        });
        const value = requireStringConstant(valueBuilder);
        return new BytesExpressionBuilder(nodeFactory.bytesConstant({
            value: wrapInCodeError(() => this.decodeLiteral(value.value), value.sourceLocation),
            encoding: this.encoding,
            sourceLocation,
        }));
    }
}
class BytesExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr) {
        super(expr, bytesPType);
    }
    prefixUnaryOp(op, sourceLocation) {
        switch (op) {
            case BuilderUnaryOp.bit_inv:
                logger.error(sourceLocation, `The '~' ${this.typeDescription} operator coerces the target value to a number type. Use {bytes expression}.bitwiseInvert() instead`);
                return new BigIntLiteralExpressionBuilder(0n, new NumericLiteralPType({ literalValue: 0n }), sourceLocation);
        }
        return super.prefixUnaryOp(op, sourceLocation);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'length':
                return new UInt64ExpressionBuilder(intrinsicFactory.bytesLen({
                    value: this._expr,
                    sourceLocation,
                }));
            case 'bitwiseInvert':
                return new BytesInvertBuilder(this._expr);
            case 'bitwiseAnd':
                return new BitwiseOpFunctionBuilder(this._expr, BytesBinaryOperator.bitAnd);
            case 'bitwiseOr':
                return new BitwiseOpFunctionBuilder(this._expr, BytesBinaryOperator.bitOr);
            case 'bitwiseXor':
                return new BitwiseOpFunctionBuilder(this._expr, BytesBinaryOperator.bitXor);
            case 'toString':
                return new ToStringBuilder(this._expr);
            case 'concat':
                return new ConcatExpressionBuilder(this._expr);
            case 'at':
                return new AtFunctionBuilder(this._expr, bytesPType, requireExpressionOfType(this.memberAccess('length', sourceLocation), uint64PType));
            case 'slice':
                return new SliceFunctionBuilder(this._expr, bytesPType);
            case 'equals':
                return new EqualsFunctionBuilder(this._expr);
        }
        return super.memberAccess(name, sourceLocation);
    }
    compare(other, op, sourceLocation) {
        return compareBytes(this._expr, requireExpressionOfType(other, bytesPType), op, sourceLocation, this.typeDescription);
    }
    boolEval(sourceLocation, negate) {
        return new UInt64ExpressionBuilder(intrinsicFactory.bytesLen({
            value: this._expr,
            sourceLocation,
        })).boolEval(sourceLocation, negate);
    }
    toBytes() {
        return this.resolve();
    }
    toString(sourceLocation) {
        if (this._expr instanceof BytesConstant) {
            return nodeFactory.stringConstant({
                value: uint8ArrayToUtf8(this._expr.value),
                sourceLocation: this._expr.sourceLocation,
            });
        }
        return nodeFactory.reinterpretCast({
            expr: this._expr,
            sourceLocation,
            wtype: wtypes.stringWType,
        });
    }
}
class ConcatExpressionBuilder extends FunctionBuilder {
    expr;
    constructor(expr) {
        super(expr.sourceLocation);
        this.expr = expr;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [other], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: 'concat',
            genericTypeArgs: 0,
            argSpec: (a) => [a.required(bytesPType)],
        });
        return new BytesExpressionBuilder(intrinsicFactory.bytesConcat({
            left: this.expr,
            right: other.resolve(),
            sourceLocation: sourceLocation,
        }));
    }
}
class BytesInvertBuilder extends ParameterlessFunctionBuilder {
    expr;
    constructor(expr) {
        super(expr, (expr, sourceLocation) => new BytesExpressionBuilder(nodeFactory.bytesUnaryOperation({
            wtype: wtypes.bytesWType,
            expr: this.expr,
            op: BytesUnaryOperator.bitInvert,
            sourceLocation,
        })));
        this.expr = expr;
    }
}
class BitwiseOpFunctionBuilder extends FunctionBuilder {
    expr;
    op;
    constructor(expr, op) {
        super(expr.sourceLocation);
        this.expr = expr;
        this.op = op;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [other], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: enumKeyFromValue(this.op, BytesBinaryOperator),
            argSpec: (a) => [a.required(bytesPType)],
        });
        return new BytesExpressionBuilder(nodeFactory.bytesBinaryOperation({
            wtype: wtypes.bytesWType,
            left: this.expr,
            right: other.resolve(),
            op: this.op,
            sourceLocation,
        }));
    }
}
class ToStringBuilder extends ParameterlessFunctionBuilder {
    expr;
    constructor(expr) {
        super(expr, (expr, sourceLocation) => new StringExpressionBuilder(nodeFactory.reinterpretCast({
            wtype: wtypes.stringWType,
            expr: this.expr,
            sourceLocation,
        })));
        this.expr = expr;
    }
}
class EqualsFunctionBuilder extends FunctionBuilder {
    expr;
    constructor(expr) {
        super(expr.sourceLocation);
        this.expr = expr;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [right], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'equals',
            argSpec: (a) => [a.required(bytesPType)],
        });
        return new BooleanExpressionBuilder(nodeFactory.bytesComparisonExpression({
            operator: EqualityComparison.eq,
            lhs: this.expr,
            rhs: right.resolve(),
            sourceLocation,
        }));
    }
}

class Arc4EncodedBaseExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        super(expr, ptype);
    }
    compare(other, op, sourceLocation) {
        const equalityOp = tryConvertEnum(op, BuilderComparisonOp, EqualityComparison);
        switch (equalityOp) {
            case EqualityComparison.eq:
            case EqualityComparison.ne:
                return new BooleanExpressionBuilder(nodeFactory.bytesComparisonExpression({
                    operator: equalityOp,
                    lhs: this.toBytes(sourceLocation),
                    rhs: requireBuilderOfType(other, this.ptype).toBytes(sourceLocation),
                    sourceLocation,
                }));
        }
        return super.compare(other, op, sourceLocation);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'bytes':
                return new BytesExpressionBuilder(this.toBytes(sourceLocation));
            case 'equals':
                return new Arc4EqualsFunctionBuilder(this, sourceLocation);
            case 'native':
                if (this.ptype.nativeType === undefined)
                    break;
                return instanceEb(nodeFactory.aRC4Decode({
                    value: this.resolve(),
                    sourceLocation,
                    wtype: this.ptype.nativeType.wtypeOrThrow,
                }), this.ptype.nativeType);
        }
        return super.memberAccess(name, sourceLocation);
    }
    toBytes(sourceLocation) {
        return nodeFactory.reinterpretCast({
            expr: this.resolve(),
            wtype: wtypes.bytesWType,
            sourceLocation,
        });
    }
}
class Arc4EqualsFunctionBuilder extends FunctionBuilder {
    left;
    constructor(left, sourceLocation) {
        super(sourceLocation);
        this.left = left;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [right], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'equals',
            argSpec: (a) => [a.required(this.left.ptype)],
        });
        return new BooleanExpressionBuilder(nodeFactory.bytesComparisonExpression({
            operator: EqualityComparison.eq,
            lhs: this.left.toBytes(sourceLocation),
            rhs: right.toBytes(sourceLocation),
            sourceLocation,
        }));
    }
}

class DynamicArrayClassBuilder extends ClassBuilder {
    ptype = DynamicArrayConstructor;
    newCall(args, typeArgs, sourceLocation) {
        const { args: [...initialItems], ptypes: [elementType], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: 'DynamicArray constructor',
            genericTypeArgs: 1,
            argSpec: (a) => args.map((_) => a.required()),
        });
        codeInvariant(elementType instanceof ARC4EncodedType, 'Element type must be an ARC4 encoded type', sourceLocation);
        const initialItemExprs = initialItems.map((i) => requireExpressionOfType(i, elementType));
        const ptype = new DynamicArrayType({ elementType, sourceLocation });
        return new DynamicArrayExpressionBuilder(nodeFactory.newArray({
            values: initialItemExprs,
            wtype: ptype.wtype,
            sourceLocation,
        }), ptype);
    }
}
class StaticArrayClassBuilder extends ClassBuilder {
    ptype = StaticArrayConstructor;
    newCall(args, typeArgs, sourceLocation) {
        const { args: [...initialItems], ptypes: [elementType, arraySize], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: 'StaticArray constructor',
            genericTypeArgs: 2,
            argSpec: (a) => args.map((_) => a.required()),
        });
        codeInvariant(elementType instanceof ARC4EncodedType, 'Element type must be an ARC4 encoded type', sourceLocation);
        codeInvariant(arraySize instanceof NumericLiteralPType, `Array size type parameter of ${this.typeDescription} must be a literal number. Inferred type is ${arraySize.name}`, sourceLocation);
        const ptype = new StaticArrayType({ elementType, arraySize: arraySize.literalValue, sourceLocation });
        if (initialItems.length === 0) {
            codeInvariant(ptype.fixedByteSize !== null, 'Zero arg constructor can only be used for static arrays with a fixed size encoding.');
            return new StaticArrayExpressionBuilder(intrinsicFactory.bzero({ size: ptype.fixedByteSize, wtype: ptype.wtype, sourceLocation }), ptype);
        }
        codeInvariant(BigInt(initialItems.length) === arraySize.literalValue, `Static array of size ${arraySize.literalValue} must be initialized with ${arraySize.literalValue} values`, sourceLocation);
        return new StaticArrayExpressionBuilder(nodeFactory.newArray({
            values: initialItems.map((i) => requireExpressionOfType(i, elementType)),
            wtype: ptype.wtype,
            sourceLocation,
        }), ptype);
    }
}
class AddressClassBuilder extends ClassBuilder {
    ptype = AddressClass;
    newCall(args, typeArgs, sourceLocation) {
        const { args: [accountOrAddressOrBytes], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: 'Address constructor',
            genericTypeArgs: 0,
            argSpec: (a) => [a.optional(accountPType, stringPType, bytesPType)],
        });
        if (!accountOrAddressOrBytes) {
            return new AddressExpressionBuilder(nodeFactory.addressConstant({
                value: Constants.algo.zeroAddressB32,
                sourceLocation,
                wtype: arc4AddressAlias.wtype,
            }), arc4AddressAlias);
        }
        if (accountOrAddressOrBytes.ptype.equals(accountPType)) {
            return new AddressExpressionBuilder(nodeFactory.reinterpretCast({
                expr: accountOrAddressOrBytes.resolve(),
                sourceLocation,
                wtype: arc4AddressAlias.wtype,
            }), arc4AddressAlias);
        }
        else if (accountOrAddressOrBytes.ptype.equals(stringPType)) {
            const value = accountOrAddressOrBytes.resolve();
            if (value instanceof StringConstant) {
                wrapInCodeError(() => base32ToUint8Array(value.value), value.sourceLocation);
                return new AddressExpressionBuilder(nodeFactory.addressConstant({
                    value: value.value,
                    sourceLocation,
                    wtype: arc4AddressAlias.wtype,
                }), arc4AddressAlias);
            }
            logger.error(value.sourceLocation, `Invalid address literal. Addresses should be ${Constants.algo.encodedAddressLength} characters and not include base32 padding`);
        }
        return new AddressExpressionBuilder(nodeFactory.reinterpretCast({
            expr: accountOrAddressOrBytes.resolve(),
            sourceLocation,
            wtype: arc4AddressAlias.wtype,
        }), arc4AddressAlias);
    }
}
class StaticBytesClassBuilder extends ClassBuilder {
    ptype = StaticBytesConstructor;
    newCall(args, typeArgs, sourceLocation) {
        const { ptypes: [length], args: [initialValue], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: `${this.ptype.name} constructor`,
            genericTypeArgs: 1,
            argSpec: (a) => [a.optional(bytesPType, stringPType)],
        });
        const resultPType = StaticBytesGeneric.parameterise([length]);
        codeInvariant(length instanceof NumericLiteralPType, 'length must be numeric literal', sourceLocation);
        const byteLength = Number(length.literalValue);
        if (!initialValue) {
            return instanceEb(nodeFactory.bytesConstant({
                value: new Uint8Array(byteLength),
                sourceLocation,
                wtype: resultPType.wtype,
            }), resultPType);
        }
        const value = resolveCompatExpression(initialValue, bytesPType);
        if (value instanceof BytesConstant) {
            codeInvariant(value.value.length === byteLength, `Value should have byte length of ${byteLength}`, sourceLocation);
            return instanceEb(nodeFactory.bytesConstant({
                value: value.value,
                wtype: resultPType.wtype,
                sourceLocation,
            }), resultPType);
        }
        else {
            return instanceEb(nodeFactory.aRC4Encode({
                value: initialValue.resolve(),
                sourceLocation,
                wtype: resultPType.wtype,
            }), resultPType);
        }
    }
}
class DynamicBytesClassBuilder extends ClassBuilder {
    ptype = DynamicBytesConstructor;
    newCall(args, typeArgs, sourceLocation) {
        const { args: [initialValue], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: `${this.ptype.name} constructor`,
            genericTypeArgs: 0,
            argSpec: (a) => [a.optional(bytesPType, stringPType)],
        });
        const resultPType = DynamicBytesType;
        if (!initialValue) {
            return instanceEb(nodeFactory.bytesConstant({
                value: new Uint8Array([0, 0]),
                sourceLocation,
                wtype: resultPType.wtype,
            }), resultPType);
        }
        const value = resolveCompatExpression(initialValue, bytesPType);
        if (value instanceof BytesConstant) {
            return instanceEb(nodeFactory.bytesConstant({
                value: new Uint8Array([...bigIntToUint8Array(BigInt(value.value.length), 2), ...value.value]),
                sourceLocation,
                wtype: resultPType.wtype,
            }), resultPType);
        }
        else {
            return instanceEb(nodeFactory.aRC4Encode({
                value,
                sourceLocation,
                wtype: resultPType.wtype,
            }), resultPType);
        }
    }
}
class ArrayExpressionBuilder extends Arc4EncodedBaseExpressionBuilder {
    iterate() {
        return this.resolve();
    }
    indexAccess(index, sourceLocation) {
        return indexAccess(this, index, sourceLocation);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'length':
                return arrayLength(this, sourceLocation);
            case 'at':
                return new AtFunctionBuilder(this.resolve(), this.ptype.elementType, this.ptype instanceof StaticArrayType
                    ? this.ptype.arraySize
                    : requireExpressionOfType(this.memberAccess('length', sourceLocation), uint64PType));
            case 'entries':
                return new EntriesFunctionBuilder(this);
            case 'copy':
                return new Arc4CopyFunctionBuilder(this);
            case 'concat':
                return new ConcatFunctionBuilder$1(this);
            case 'slice': {
                const sliceResult = this.ptype instanceof StaticArrayType ? new DynamicArrayType({ elementType: this.ptype.elementType }) : this.ptype;
                return new SliceFunctionBuilder(this.resolve(), sliceResult);
            }
            case 'native':
                return instanceEb(nodeFactory.aRC4Decode({
                    value: this.resolve(),
                    wtype: this.ptype.nativeType.wtypeOrThrow,
                    sourceLocation,
                }), this.ptype.nativeType);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
let ConcatFunctionBuilder$1 = class ConcatFunctionBuilder extends FunctionBuilder {
    arrayBuilder;
    constructor(arrayBuilder) {
        super(arrayBuilder.sourceLocation);
        this.arrayBuilder = arrayBuilder;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [other], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            argSpec: (a) => [a.required()],
            funcName: 'concat',
            callLocation: sourceLocation,
        });
        return concatArrays(this.arrayBuilder, other, sourceLocation);
    }
};
class EntriesFunctionBuilder extends FunctionBuilder {
    arrayBuilder;
    constructor(arrayBuilder) {
        super(arrayBuilder.sourceLocation);
        this.arrayBuilder = arrayBuilder;
    }
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({ args, typeArgs, callLocation: sourceLocation, argSpec: (_) => [], genericTypeArgs: 0, funcName: 'entries' });
        const iteratorType = IterableIteratorGeneric.parameterise([
            new TuplePType({ items: [uint64PType, this.arrayBuilder.ptype.elementType] }),
        ]);
        return new IterableIteratorExpressionBuilder(nodeFactory.enumeration({
            expr: this.arrayBuilder.iterate(),
            sourceLocation,
            wtype: iteratorType.wtype,
        }), iteratorType);
    }
}
class DynamicArrayExpressionBuilder extends ArrayExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof DynamicArrayType, 'ptype must be instance of DynamicArrayType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'push':
                return new ArrayPushFunctionBuilder(this);
            case 'pop':
                return new ArrayPopFunctionBuilder(this);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class StaticArrayExpressionBuilder extends ArrayExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof StaticArrayType, 'ptype must be instance of StaticArrayType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'native':
                return instanceEb(nodeFactory.aRC4Decode({
                    value: this.resolve(),
                    wtype: this.ptype.nativeType.wtypeOrThrow,
                    sourceLocation,
                }), this.ptype.nativeType);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class DynamicBytesExpressionBuilder extends DynamicArrayExpressionBuilder {
}
class StaticBytesExpressionBuilder extends StaticArrayExpressionBuilder {
}
class AddressExpressionBuilder extends ArrayExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof StaticArrayType, 'ptype must be instance of StaticArrayType');
        invariant(ptype.equals(arc4AddressAlias), 'ptype must be arc4AddressAlias');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'length':
                return new UInt64ExpressionBuilder(nodeFactory.uInt64Constant({ value: this.ptype.arraySize, sourceLocation }));
        }
        return super.memberAccess(name, sourceLocation);
    }
}

class BoolClassBuilder extends ClassBuilder {
    ptype = ARC4BoolClass;
    newCall(args, typeArgs, sourceLocation) {
        const { args: [initialValue], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: `${this.typeDescription} constructor}`,
            genericTypeArgs: 0,
            argSpec: (a) => [a.optional(boolPType)],
        });
        let expr;
        if (!initialValue) {
            expr = nodeFactory.boolConstant({
                value: false,
                sourceLocation,
                wtype: wtypes.arc4BooleanWType,
            });
        }
        else {
            const value = initialValue.resolve();
            if (value instanceof BoolConstant) {
                expr = nodeFactory.boolConstant({
                    value: value.value,
                    sourceLocation,
                    wtype: wtypes.arc4BooleanWType,
                });
            }
            else {
                expr = nodeFactory.aRC4Encode({
                    value: value,
                    wtype: wtypes.arc4BooleanWType,
                    sourceLocation,
                });
            }
        }
        return new BoolExpressionBuilder(expr);
    }
}
class BoolExpressionBuilder extends Arc4EncodedBaseExpressionBuilder {
    constructor(expression) {
        super(expression, arc4BooleanType);
    }
}

class TxnFieldData {
    immediate;
    wtype;
    numValues;
    isInnerParam;
    /**
     * If field is an array, accept individual arguments and convert to an array
     */
    arrayPromote;
    constructor(data) {
        this.immediate = data.field;
        this.wtype = data.wtype;
        this.numValues = data.numValues ?? 1;
        this.isInnerParam = data.isInnerParam ?? true;
        this.arrayPromote = data.arrayPromote ?? false;
    }
}
var TxnField;
(function (TxnField) {
    TxnField["Sender"] = "Sender";
    TxnField["Fee"] = "Fee";
    TxnField["FirstValid"] = "FirstValid";
    TxnField["FirstValidTime"] = "FirstValidTime";
    TxnField["LastValid"] = "LastValid";
    TxnField["Note"] = "Note";
    TxnField["Lease"] = "Lease";
    TxnField["Receiver"] = "Receiver";
    TxnField["Amount"] = "Amount";
    TxnField["CloseRemainderTo"] = "CloseRemainderTo";
    TxnField["VotePK"] = "VotePK";
    TxnField["SelectionPK"] = "SelectionPK";
    TxnField["VoteFirst"] = "VoteFirst";
    TxnField["VoteLast"] = "VoteLast";
    TxnField["VoteKeyDilution"] = "VoteKeyDilution";
    TxnField["Type"] = "Type";
    TxnField["TypeEnum"] = "TypeEnum";
    TxnField["XferAsset"] = "XferAsset";
    TxnField["AssetAmount"] = "AssetAmount";
    TxnField["AssetSender"] = "AssetSender";
    TxnField["AssetReceiver"] = "AssetReceiver";
    TxnField["AssetCloseTo"] = "AssetCloseTo";
    TxnField["GroupIndex"] = "GroupIndex";
    TxnField["TxID"] = "TxID";
    TxnField["ApplicationID"] = "ApplicationID";
    TxnField["OnCompletion"] = "OnCompletion";
    TxnField["NumAppArgs"] = "NumAppArgs";
    TxnField["NumAccounts"] = "NumAccounts";
    TxnField["ApprovalProgram"] = "ApprovalProgram";
    TxnField["ClearStateProgram"] = "ClearStateProgram";
    TxnField["RekeyTo"] = "RekeyTo";
    TxnField["ConfigAsset"] = "ConfigAsset";
    TxnField["ConfigAssetTotal"] = "ConfigAssetTotal";
    TxnField["ConfigAssetDecimals"] = "ConfigAssetDecimals";
    TxnField["ConfigAssetDefaultFrozen"] = "ConfigAssetDefaultFrozen";
    TxnField["ConfigAssetUnitName"] = "ConfigAssetUnitName";
    TxnField["ConfigAssetName"] = "ConfigAssetName";
    TxnField["ConfigAssetURL"] = "ConfigAssetURL";
    TxnField["ConfigAssetMetadataHash"] = "ConfigAssetMetadataHash";
    TxnField["ConfigAssetManager"] = "ConfigAssetManager";
    TxnField["ConfigAssetReserve"] = "ConfigAssetReserve";
    TxnField["ConfigAssetFreeze"] = "ConfigAssetFreeze";
    TxnField["ConfigAssetClawback"] = "ConfigAssetClawback";
    TxnField["FreezeAsset"] = "FreezeAsset";
    TxnField["FreezeAssetAccount"] = "FreezeAssetAccount";
    TxnField["FreezeAssetFrozen"] = "FreezeAssetFrozen";
    TxnField["NumAssets"] = "NumAssets";
    TxnField["NumApplications"] = "NumApplications";
    TxnField["GlobalNumUint"] = "GlobalNumUint";
    TxnField["GlobalNumByteSlice"] = "GlobalNumByteSlice";
    TxnField["LocalNumUint"] = "LocalNumUint";
    TxnField["LocalNumByteSlice"] = "LocalNumByteSlice";
    TxnField["ExtraProgramPages"] = "ExtraProgramPages";
    TxnField["Nonparticipation"] = "Nonparticipation";
    TxnField["NumLogs"] = "NumLogs";
    TxnField["CreatedAssetID"] = "CreatedAssetID";
    TxnField["CreatedApplicationID"] = "CreatedApplicationID";
    TxnField["LastLog"] = "LastLog";
    TxnField["StateProofPK"] = "StateProofPK";
    TxnField["NumApprovalProgramPages"] = "NumApprovalProgramPages";
    TxnField["NumClearStateProgramPages"] = "NumClearStateProgramPages";
    TxnField["ApplicationArgs"] = "ApplicationArgs";
    TxnField["Accounts"] = "Accounts";
    TxnField["Assets"] = "Assets";
    TxnField["Applications"] = "Applications";
    TxnField["Logs"] = "Logs";
    TxnField["ApprovalProgramPages"] = "ApprovalProgramPages";
    TxnField["ClearStateProgramPages"] = "ClearStateProgramPages";
})(TxnField || (TxnField = {}));
const TxnFields = {
    Sender: new TxnFieldData({ field: TxnField.Sender, wtype: wtypes.accountWType }),
    Fee: new TxnFieldData({ field: TxnField.Fee, wtype: wtypes.uint64WType }),
    FirstValid: new TxnFieldData({ field: TxnField.FirstValid, wtype: wtypes.uint64WType, isInnerParam: false }),
    FirstValidTime: new TxnFieldData({ field: TxnField.FirstValidTime, wtype: wtypes.uint64WType, isInnerParam: false }),
    LastValid: new TxnFieldData({ field: TxnField.LastValid, wtype: wtypes.uint64WType, isInnerParam: false }),
    Note: new TxnFieldData({ field: TxnField.Note, wtype: wtypes.bytesWType }),
    Lease: new TxnFieldData({ field: TxnField.Lease, wtype: wtypes.bytesWType, isInnerParam: false }),
    Receiver: new TxnFieldData({ field: TxnField.Receiver, wtype: wtypes.accountWType }),
    Amount: new TxnFieldData({ field: TxnField.Amount, wtype: wtypes.uint64WType }),
    CloseRemainderTo: new TxnFieldData({ field: TxnField.CloseRemainderTo, wtype: wtypes.accountWType }),
    VotePK: new TxnFieldData({ field: TxnField.VotePK, wtype: wtypes.bytesWType }),
    SelectionPK: new TxnFieldData({ field: TxnField.SelectionPK, wtype: wtypes.bytesWType }),
    VoteFirst: new TxnFieldData({ field: TxnField.VoteFirst, wtype: wtypes.uint64WType }),
    VoteLast: new TxnFieldData({ field: TxnField.VoteLast, wtype: wtypes.uint64WType }),
    VoteKeyDilution: new TxnFieldData({ field: TxnField.VoteKeyDilution, wtype: wtypes.uint64WType }),
    Type: new TxnFieldData({ field: TxnField.Type, wtype: wtypes.bytesWType }),
    TypeEnum: new TxnFieldData({ field: TxnField.TypeEnum, wtype: wtypes.uint64WType }),
    XferAsset: new TxnFieldData({ field: TxnField.XferAsset, wtype: wtypes.assetWType }),
    AssetAmount: new TxnFieldData({ field: TxnField.AssetAmount, wtype: wtypes.uint64WType }),
    AssetSender: new TxnFieldData({ field: TxnField.AssetSender, wtype: wtypes.accountWType }),
    AssetReceiver: new TxnFieldData({ field: TxnField.AssetReceiver, wtype: wtypes.accountWType }),
    AssetCloseTo: new TxnFieldData({ field: TxnField.AssetCloseTo, wtype: wtypes.accountWType }),
    GroupIndex: new TxnFieldData({ field: TxnField.GroupIndex, wtype: wtypes.uint64WType, isInnerParam: false }),
    TxID: new TxnFieldData({ field: TxnField.TxID, wtype: wtypes.bytesWType, isInnerParam: false }),
    // v2
    ApplicationID: new TxnFieldData({ field: TxnField.ApplicationID, wtype: wtypes.applicationWType }),
    OnCompletion: new TxnFieldData({ field: TxnField.OnCompletion, wtype: wtypes.uint64WType }),
    NumAppArgs: new TxnFieldData({ field: TxnField.NumAppArgs, wtype: wtypes.uint64WType, isInnerParam: false }),
    NumAccounts: new TxnFieldData({ field: TxnField.NumAccounts, wtype: wtypes.uint64WType, isInnerParam: false }),
    ApprovalProgram: new TxnFieldData({ field: TxnField.ApprovalProgram, wtype: wtypes.bytesWType }),
    ClearStateProgram: new TxnFieldData({ field: TxnField.ClearStateProgram, wtype: wtypes.bytesWType }),
    RekeyTo: new TxnFieldData({ field: TxnField.RekeyTo, wtype: wtypes.accountWType }),
    ConfigAsset: new TxnFieldData({ field: TxnField.ConfigAsset, wtype: wtypes.assetWType }),
    ConfigAssetTotal: new TxnFieldData({ field: TxnField.ConfigAssetTotal, wtype: wtypes.uint64WType }),
    ConfigAssetDecimals: new TxnFieldData({ field: TxnField.ConfigAssetDecimals, wtype: wtypes.uint64WType }),
    ConfigAssetDefaultFrozen: new TxnFieldData({ field: TxnField.ConfigAssetDefaultFrozen, wtype: wtypes.boolWType }),
    ConfigAssetUnitName: new TxnFieldData({ field: TxnField.ConfigAssetUnitName, wtype: wtypes.bytesWType }),
    ConfigAssetName: new TxnFieldData({ field: TxnField.ConfigAssetName, wtype: wtypes.bytesWType }),
    ConfigAssetURL: new TxnFieldData({ field: TxnField.ConfigAssetURL, wtype: wtypes.bytesWType }),
    ConfigAssetMetadataHash: new TxnFieldData({ field: TxnField.ConfigAssetMetadataHash, wtype: wtypes.bytesWType }),
    ConfigAssetManager: new TxnFieldData({ field: TxnField.ConfigAssetManager, wtype: wtypes.accountWType }),
    ConfigAssetReserve: new TxnFieldData({ field: TxnField.ConfigAssetReserve, wtype: wtypes.accountWType }),
    ConfigAssetFreeze: new TxnFieldData({ field: TxnField.ConfigAssetFreeze, wtype: wtypes.accountWType }),
    ConfigAssetClawback: new TxnFieldData({ field: TxnField.ConfigAssetClawback, wtype: wtypes.accountWType }),
    FreezeAsset: new TxnFieldData({ field: TxnField.FreezeAsset, wtype: wtypes.assetWType }),
    FreezeAssetAccount: new TxnFieldData({ field: TxnField.FreezeAssetAccount, wtype: wtypes.accountWType }),
    FreezeAssetFrozen: new TxnFieldData({ field: TxnField.FreezeAssetFrozen, wtype: wtypes.boolWType }),
    // v3
    NumAssets: new TxnFieldData({ field: TxnField.NumAssets, wtype: wtypes.uint64WType, isInnerParam: false }),
    NumApplications: new TxnFieldData({ field: TxnField.NumApplications, wtype: wtypes.uint64WType, isInnerParam: false }),
    GlobalNumUint: new TxnFieldData({ field: TxnField.GlobalNumUint, wtype: wtypes.uint64WType }),
    GlobalNumByteSlice: new TxnFieldData({ field: TxnField.GlobalNumByteSlice, wtype: wtypes.uint64WType }),
    LocalNumUint: new TxnFieldData({ field: TxnField.LocalNumUint, wtype: wtypes.uint64WType }),
    LocalNumByteSlice: new TxnFieldData({ field: TxnField.LocalNumByteSlice, wtype: wtypes.uint64WType }),
    // v4
    ExtraProgramPages: new TxnFieldData({ field: TxnField.ExtraProgramPages, wtype: wtypes.uint64WType }),
    // v5
    Nonparticipation: new TxnFieldData({ field: TxnField.Nonparticipation, wtype: wtypes.boolWType }),
    NumLogs: new TxnFieldData({ field: TxnField.NumLogs, wtype: wtypes.uint64WType, isInnerParam: false }),
    CreatedAssetID: new TxnFieldData({ field: TxnField.CreatedAssetID, wtype: wtypes.assetWType, isInnerParam: false }),
    CreatedApplicationID: new TxnFieldData({ field: TxnField.CreatedApplicationID, wtype: wtypes.applicationWType, isInnerParam: false }),
    // v6
    LastLog: new TxnFieldData({ field: TxnField.LastLog, wtype: wtypes.bytesWType, isInnerParam: false }),
    StateProofPK: new TxnFieldData({ field: TxnField.StateProofPK, wtype: wtypes.bytesWType }),
    // v7
    NumApprovalProgramPages: new TxnFieldData({ field: TxnField.NumApprovalProgramPages, wtype: wtypes.uint64WType, isInnerParam: false }),
    NumClearStateProgramPages: new TxnFieldData({
        field: TxnField.NumClearStateProgramPages,
        wtype: wtypes.uint64WType,
        isInnerParam: false,
    }),
    // array fields
    // TODO: allow configuring as these are consensus values
    // v2
    ApplicationArgs: new TxnFieldData({ field: TxnField.ApplicationArgs, wtype: wtypes.bytesWType, numValues: 16 }),
    Accounts: new TxnFieldData({ field: TxnField.Accounts, wtype: wtypes.accountWType, numValues: 4 }),
    // v3
    Assets: new TxnFieldData({ field: TxnField.Assets, wtype: wtypes.assetWType, numValues: 8 }),
    Applications: new TxnFieldData({ field: TxnField.Applications, wtype: wtypes.applicationWType, numValues: 8 }),
    // v5
    Logs: new TxnFieldData({ field: TxnField.Logs, wtype: wtypes.bytesWType, numValues: 32, isInnerParam: false }),
    // v7
    ApprovalProgramPages: new TxnFieldData({
        field: TxnField.ApprovalProgramPages,
        wtype: wtypes.bytesWType,
        numValues: 4,
        arrayPromote: true,
    }),
    ClearStateProgramPages: new TxnFieldData({
        field: TxnField.ClearStateProgramPages,
        wtype: wtypes.bytesWType,
        numValues: 4,
        arrayPromote: true,
    }),
};

class ConstantStore {
    #constants = new Map();
    #typeChecker;
    constructor(program) {
        this.#typeChecker = program.getTypeChecker();
    }
    tryResolveConstant(node) {
        let symbol = this.#typeChecker.resolveName(node.text, node, SymbolFlags.All, true);
        if (!symbol)
            return undefined;
        if (hasFlags(symbol.flags, ts.SymbolFlags.Alias)) {
            symbol = this.#typeChecker.getAliasedSymbol(symbol);
        }
        return this.#constants.get(symbol);
    }
    addConstant(identifier, value, constantLocation) {
        const symbol = this.#typeChecker.resolveName(identifier.text, identifier, ts.SymbolFlags.All, false);
        invariant(symbol, 'Constant identifier must resolve to a symbol');
        if (this.#constants.has(symbol)) {
            logger.error(new CodeError(`Duplicate definitions found for constant ${identifier.text}`, { sourceLocation: constantLocation }));
            return;
        }
        const exportSymbol = this.#typeChecker.getExportSymbolOfSymbol(symbol);
        this.#constants.set(symbol, value);
        if (exportSymbol !== symbol)
            this.#constants.set(exportSymbol, value);
    }
}

class CustomKeyMap {
    #keySerializer;
    #map = new Map();
    constructor(keySerializer) {
        this.#keySerializer = keySerializer;
    }
    clear() {
        this.#map.clear();
    }
    delete(key) {
        return this.#map.delete(this.#keySerializer(key));
    }
    forEach(callbackfn, thisArg) {
        for (const [key, value] of this.#map.values()) {
            callbackfn.call(thisArg ?? this, value, key, this);
        }
    }
    get(key) {
        return this.#map.get(this.#keySerializer(key))?.[1];
    }
    has(key) {
        return this.#map.has(this.#keySerializer(key));
    }
    set(key, value) {
        this.#map.set(this.#keySerializer(key), [key, value]);
        return this;
    }
    get size() {
        return this.#map.size;
    }
    entries() {
        return this.#map.values();
    }
    *keys() {
        for (const [key] of this.#map.values()) {
            yield key;
        }
    }
    *values() {
        for (const [, value] of this.#map.values()) {
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.#map.values();
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}

class LogicSigClassModel {
    isAbstract = false;
    get id() {
        return LogicSigReference.fromPType(this.type);
    }
    type;
    get name() {
        return this.type.name;
    }
    description;
    bases;
    options;
    program;
    sourceLocation;
    constructor(props) {
        this.type = props.type;
        this.description = props.description;
        this.program = props.program;
        this.bases = props.bases;
        this.sourceLocation = props.sourceLocation;
        this.options = props.options;
    }
    buildLogicSignature() {
        return nodeFactory.logicSignature({
            id: this.id,
            shortName: this.options?.name ?? this.name,
            program: this.program,
            sourceLocation: this.sourceLocation,
            docstring: this.description,
            avmVersion: this.options?.avmVersion ?? null,
            reservedScratchSpace: this.options?.scratchSlots ?? new Set(),
        });
    }
}

class ContractClassModel {
    isAbstract;
    get id() {
        return ContractReference.fromPType(this.type);
    }
    type;
    get name() {
        return this.type.name;
    }
    options;
    description;
    propertyInitialization;
    approvalProgram;
    clearProgram;
    ctor;
    methods;
    appState;
    sourceLocation;
    constructor(props) {
        this.isAbstract = props.isAbstract;
        this.type = props.type;
        this.description = props.description;
        this.propertyInitialization = props.propertyInitialization;
        this.ctor = props.ctor;
        this.approvalProgram = props.approvalProgram;
        this.clearProgram = props.clearProgram;
        this.methods = props.methods;
        this.appState = props.appState;
        this.sourceLocation = props.sourceLocation;
        this.options = props.options;
    }
    hasExplicitStateTotals() {
        return this.options?.stateTotals !== undefined;
    }
    buildContract(compilationSet) {
        let approvalProgram = this.approvalProgram;
        let clearProgram = this.clearProgram;
        const methods = [...this.methods];
        const ctors = this.ctor ? [this.ctor] : [];
        const methodResolutionOrder = [];
        let firstBaseWithStateTotals = undefined;
        let reservedScratchSpace = new Set();
        const seenContractIds = new Set();
        for (const baseType of this.type.allBases()) {
            const baseClass = this.getModelForClass(compilationSet, baseType);
            if (baseClass.hasExplicitStateTotals() && firstBaseWithStateTotals === undefined) {
                firstBaseWithStateTotals = baseClass;
            }
            if (baseClass.options?.scratchSlots) {
                reservedScratchSpace = reservedScratchSpace.union(baseClass.options.scratchSlots);
            }
            methodResolutionOrder.push(baseClass.id);
            if (seenContractIds.has(baseClass.id.toString())) {
                continue;
            }
            else {
                seenContractIds.add(baseClass.id.toString());
            }
            approvalProgram ??= baseClass.approvalProgram;
            clearProgram ??= baseClass.clearProgram;
            if (baseClass.approvalProgram && baseClass.approvalProgram !== approvalProgram)
                methods.push(baseClass.approvalProgram);
            if (baseClass.clearProgram && baseClass.clearProgram !== clearProgram)
                methods.push(baseClass.clearProgram);
            for (const method of baseClass.methods) {
                // Maybe need validation??
                methods.push(method);
            }
            if (baseClass.ctor)
                ctors.push(baseClass.ctor);
        }
        if (this.type.isARC4) {
            const hasCreate = methods.some((m) => isIn(m.arc4MethodConfig?.create, [ARC4CreateOption.allow, ARC4CreateOption.require]));
            const hasBareNoop = methods.some((m) => m.arc4MethodConfig instanceof ARC4BareMethodConfig && isIn(OnCompletionAction.NoOp, m.arc4MethodConfig.allowedCompletionTypes));
            if (!hasCreate) {
                if (hasBareNoop) {
                    logger.error(this.sourceLocation, `Non-abstract ARC4 contract has no methods which can be called to create the contract. ` +
                        `An implicit one could not be inserted as there is already a bare method handling the NoOp on completion action. ` +
                        `In order to allow creating the contract specify { onCreate: 'allow' } or { onCreate: 'require' } in an @abimethod or @baremethod decorator above the chosen method.`);
                }
                else {
                    methods.push(this.makeDefaultCreate());
                }
            }
        }
        codeInvariant(approvalProgram, 'must have approval');
        codeInvariant(clearProgram, 'must have clear');
        if (!this.hasExplicitStateTotals && firstBaseWithStateTotals) {
            logger.warn(this.options?.sourceLocation ?? this.sourceLocation, `Contract extends base contract ${firstBaseWithStateTotals.id} with explicit stateTotals, but does not define its own stateTotals. This could result in insufficient reserved state at run time. An empty object may be provided in order to indicate that this contract should revert to the default behaviour`);
        }
        const stateTotals = new StateTotals({
            globalBytes: this.options?.stateTotals?.globalBytes ?? null,
            globalUints: this.options?.stateTotals?.globalUints ?? null,
            localBytes: this.options?.stateTotals?.localBytes ?? null,
            localUints: this.options?.stateTotals?.localUints ?? null,
        });
        if (this.options?.scratchSlots) {
            reservedScratchSpace = reservedScratchSpace.union(this.options.scratchSlots);
        }
        const hasSignificantConstructor = ctors.length > 1;
        return nodeFactory.contract({
            name: this.options?.name ?? this.name,
            id: this.id,
            description: this.description,
            approvalProgram: hasSignificantConstructor ? ContractClassModel.patchApprovalToCallCtor(approvalProgram, methods) : approvalProgram,
            clearProgram,
            methodResolutionOrder,
            methods: [...methods, ...(hasSignificantConstructor ? ctors : [])],
            appState: this.appState,
            stateTotals,
            reservedScratchSpace: reservedScratchSpace,
            sourceLocation: this.sourceLocation,
            avmVersion: this.options?.avmVersion ?? null,
        });
    }
    getModelForClass(compilationSet, contractType) {
        if (contractType instanceof ClusteredContractClassType) {
            return this.buildClusteredMetaClass(compilationSet, contractType);
        }
        else {
            return compilationSet.getContractClass(ContractReference.fromPType(contractType));
        }
    }
    buildClusteredMetaClass(compilationSet, clusteredType) {
        const ctor = nodeFactory.contractMethod({
            memberName: Constants.symbolNames.constructorMethodName,
            cref: ContractReference.fromPType(clusteredType),
            documentation: nodeFactory.methodDocumentation({}),
            sourceLocation: SourceLocation.None,
            args: [],
            returnType: wtypes.voidWType,
            body: nodeFactory.block({
                sourceLocation: SourceLocation.None,
            }),
            arc4MethodConfig: null,
            inline: null, // TODO: Expose inline hint option
        });
        const ctorTargets = [];
        for (const baseType of clusteredType.baseTypes) {
            for (const b of [baseType, ...baseType.allBases()]) {
                const baseClassModel = this.getModelForClass(compilationSet, b);
                if (baseClassModel.ctor) {
                    ctorTargets.push(baseClassModel.ctor);
                    break;
                }
            }
        }
        ctor.body.body.push(...ctorTargets.map((ct) => nodeFactory.expressionStatement({
            expr: nodeFactory.subroutineCallExpression({
                target: nodeFactory.contractMethodTarget({
                    memberName: ct.memberName,
                    cref: ct.cref,
                }),
                args: [],
                sourceLocation: SourceLocation.None,
                wtype: wtypes.voidWType,
            }),
        })));
        return new ContractClassModel({
            appState: [],
            approvalProgram: null,
            clearProgram: null,
            isAbstract: true,
            sourceLocation: SourceLocation.None,
            propertyInitialization: [],
            description: null,
            ctor: ctor,
            methods: [],
            options: undefined,
            type: clusteredType,
        });
    }
    static patchApprovalToCallCtor(approval, methods) {
        const callCtorIfNew = nodeFactory.ifElse({
            condition: nodeFactory.not({
                expr: nodeFactory.reinterpretCast({
                    expr: nodeFactory.intrinsicCall({
                        opCode: 'txn',
                        immediates: ['ApplicationID'],
                        stackArgs: [],
                        sourceLocation: SourceLocation.None,
                        wtype: wtypes.uint64WType,
                    }),
                    sourceLocation: SourceLocation.None,
                    wtype: wtypes.boolWType,
                }),
                sourceLocation: SourceLocation.None,
            }),
            ifBranch: nodeFactory.block({ sourceLocation: SourceLocation.None }, nodeFactory.expressionStatement({
                expr: nodeFactory.subroutineCallExpression({
                    args: [],
                    wtype: wtypes.voidWType,
                    target: nodeFactory.instanceMethodTarget({
                        memberName: Constants.symbolNames.constructorMethodName,
                    }),
                    sourceLocation: SourceLocation.None,
                }),
            })),
            sourceLocation: SourceLocation.None,
            elseBranch: null,
        });
        return nodeFactory.contractMethod({
            ...approval,
            body: nodeFactory.block({ sourceLocation: SourceLocation.None }, callCtorIfNew, approval.body),
        });
    }
    makeDefaultCreate() {
        return nodeFactory.contractMethod({
            memberName: Constants.symbolNames.defaultCreateMethodName,
            cref: ContractReference.fromPType(this.type),
            args: [],
            arc4MethodConfig: new ARC4BareMethodConfig({
                allowedCompletionTypes: [OnCompletionAction.NoOp],
                create: ARC4CreateOption.require,
                sourceLocation: this.sourceLocation,
            }),
            returnType: wtypes.voidWType,
            documentation: nodeFactory.methodDocumentation({
                description: 'Implicitly generated create method',
            }),
            sourceLocation: this.sourceLocation,
            body: nodeFactory.block({
                sourceLocation: this.sourceLocation,
            }),
            inline: null, // TODO: Expose inline hint option?
        });
    }
}
class CompilationSet extends CustomKeyMap {
    constructor() {
        super((x) => x.toString());
    }
    get compilationOutputSet() {
        return Array.from(this.entries())
            .filter(([, meta]) => !meta.isAbstract)
            .map(([ref]) => ref);
    }
    getContractClass(cref) {
        const maybeClass = this.get(cref);
        invariant(maybeClass instanceof ContractClassModel, 'Contract reference must resolve to a contract class');
        return maybeClass;
    }
    getLogicSig(lref) {
        const maybeLogicSig = this.get(lref);
        invariant(maybeLogicSig instanceof LogicSigClassModel, 'Logic sig reference must resolve to a logic signature class');
        return maybeLogicSig;
    }
}

const SyntaxKindName = {
    [ts.SyntaxKind.Unknown]: 'Unknown',
    [ts.SyntaxKind.EndOfFileToken]: 'EndOfFileToken',
    [ts.SyntaxKind.SingleLineCommentTrivia]: 'SingleLineCommentTrivia',
    [ts.SyntaxKind.MultiLineCommentTrivia]: 'MultiLineCommentTrivia',
    [ts.SyntaxKind.NewLineTrivia]: 'NewLineTrivia',
    [ts.SyntaxKind.WhitespaceTrivia]: 'WhitespaceTrivia',
    [ts.SyntaxKind.ShebangTrivia]: 'ShebangTrivia',
    [ts.SyntaxKind.ConflictMarkerTrivia]: 'ConflictMarkerTrivia',
    [ts.SyntaxKind.NonTextFileMarkerTrivia]: 'NonTextFileMarkerTrivia',
    [ts.SyntaxKind.NumericLiteral]: 'NumericLiteral',
    [ts.SyntaxKind.BigIntLiteral]: 'BigIntLiteral',
    [ts.SyntaxKind.StringLiteral]: 'StringLiteral',
    [ts.SyntaxKind.JsxText]: 'JsxText',
    [ts.SyntaxKind.JsxTextAllWhiteSpaces]: 'JsxTextAllWhiteSpaces',
    [ts.SyntaxKind.RegularExpressionLiteral]: 'RegularExpressionLiteral',
    [ts.SyntaxKind.NoSubstitutionTemplateLiteral]: 'NoSubstitutionTemplateLiteral',
    [ts.SyntaxKind.TemplateHead]: 'TemplateHead',
    [ts.SyntaxKind.TemplateMiddle]: 'TemplateMiddle',
    [ts.SyntaxKind.TemplateTail]: 'TemplateTail',
    [ts.SyntaxKind.OpenBraceToken]: 'OpenBraceToken',
    [ts.SyntaxKind.CloseBraceToken]: 'CloseBraceToken',
    [ts.SyntaxKind.OpenParenToken]: 'OpenParenToken',
    [ts.SyntaxKind.CloseParenToken]: 'CloseParenToken',
    [ts.SyntaxKind.OpenBracketToken]: 'OpenBracketToken',
    [ts.SyntaxKind.CloseBracketToken]: 'CloseBracketToken',
    [ts.SyntaxKind.DotToken]: 'DotToken',
    [ts.SyntaxKind.DotDotDotToken]: 'DotDotDotToken',
    [ts.SyntaxKind.SemicolonToken]: 'SemicolonToken',
    [ts.SyntaxKind.CommaToken]: 'CommaToken',
    [ts.SyntaxKind.QuestionDotToken]: 'QuestionDotToken',
    [ts.SyntaxKind.LessThanToken]: 'LessThanToken',
    [ts.SyntaxKind.LessThanSlashToken]: 'LessThanSlashToken',
    [ts.SyntaxKind.GreaterThanToken]: 'GreaterThanToken',
    [ts.SyntaxKind.LessThanEqualsToken]: 'LessThanEqualsToken',
    [ts.SyntaxKind.GreaterThanEqualsToken]: 'GreaterThanEqualsToken',
    [ts.SyntaxKind.EqualsEqualsToken]: 'EqualsEqualsToken',
    [ts.SyntaxKind.ExclamationEqualsToken]: 'ExclamationEqualsToken',
    [ts.SyntaxKind.EqualsEqualsEqualsToken]: 'EqualsEqualsEqualsToken',
    [ts.SyntaxKind.ExclamationEqualsEqualsToken]: 'ExclamationEqualsEqualsToken',
    [ts.SyntaxKind.EqualsGreaterThanToken]: 'EqualsGreaterThanToken',
    [ts.SyntaxKind.PlusToken]: 'PlusToken',
    [ts.SyntaxKind.MinusToken]: 'MinusToken',
    [ts.SyntaxKind.AsteriskToken]: 'AsteriskToken',
    [ts.SyntaxKind.AsteriskAsteriskToken]: 'AsteriskAsteriskToken',
    [ts.SyntaxKind.SlashToken]: 'SlashToken',
    [ts.SyntaxKind.PercentToken]: 'PercentToken',
    [ts.SyntaxKind.PlusPlusToken]: 'PlusPlusToken',
    [ts.SyntaxKind.MinusMinusToken]: 'MinusMinusToken',
    [ts.SyntaxKind.LessThanLessThanToken]: 'LessThanLessThanToken',
    [ts.SyntaxKind.GreaterThanGreaterThanToken]: 'GreaterThanGreaterThanToken',
    [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: 'GreaterThanGreaterThanGreaterThanToken',
    [ts.SyntaxKind.AmpersandToken]: 'AmpersandToken',
    [ts.SyntaxKind.BarToken]: 'BarToken',
    [ts.SyntaxKind.CaretToken]: 'CaretToken',
    [ts.SyntaxKind.ExclamationToken]: 'ExclamationToken',
    [ts.SyntaxKind.TildeToken]: 'TildeToken',
    [ts.SyntaxKind.AmpersandAmpersandToken]: 'AmpersandAmpersandToken',
    [ts.SyntaxKind.BarBarToken]: 'BarBarToken',
    [ts.SyntaxKind.QuestionToken]: 'QuestionToken',
    [ts.SyntaxKind.ColonToken]: 'ColonToken',
    [ts.SyntaxKind.AtToken]: 'AtToken',
    [ts.SyntaxKind.QuestionQuestionToken]: 'QuestionQuestionToken',
    [ts.SyntaxKind.BacktickToken]: 'BacktickToken',
    [ts.SyntaxKind.HashToken]: 'HashToken',
    [ts.SyntaxKind.EqualsToken]: 'EqualsToken',
    [ts.SyntaxKind.PlusEqualsToken]: 'PlusEqualsToken',
    [ts.SyntaxKind.MinusEqualsToken]: 'MinusEqualsToken',
    [ts.SyntaxKind.AsteriskEqualsToken]: 'AsteriskEqualsToken',
    [ts.SyntaxKind.AsteriskAsteriskEqualsToken]: 'AsteriskAsteriskEqualsToken',
    [ts.SyntaxKind.SlashEqualsToken]: 'SlashEqualsToken',
    [ts.SyntaxKind.PercentEqualsToken]: 'PercentEqualsToken',
    [ts.SyntaxKind.LessThanLessThanEqualsToken]: 'LessThanLessThanEqualsToken',
    [ts.SyntaxKind.GreaterThanGreaterThanEqualsToken]: 'GreaterThanGreaterThanEqualsToken',
    [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: 'GreaterThanGreaterThanGreaterThanEqualsToken',
    [ts.SyntaxKind.AmpersandEqualsToken]: 'AmpersandEqualsToken',
    [ts.SyntaxKind.BarEqualsToken]: 'BarEqualsToken',
    [ts.SyntaxKind.BarBarEqualsToken]: 'BarBarEqualsToken',
    [ts.SyntaxKind.AmpersandAmpersandEqualsToken]: 'AmpersandAmpersandEqualsToken',
    [ts.SyntaxKind.QuestionQuestionEqualsToken]: 'QuestionQuestionEqualsToken',
    [ts.SyntaxKind.CaretEqualsToken]: 'CaretEqualsToken',
    [ts.SyntaxKind.Identifier]: 'Identifier',
    [ts.SyntaxKind.PrivateIdentifier]: 'PrivateIdentifier',
    [ts.SyntaxKind.BreakKeyword]: 'BreakKeyword',
    [ts.SyntaxKind.CaseKeyword]: 'CaseKeyword',
    [ts.SyntaxKind.CatchKeyword]: 'CatchKeyword',
    [ts.SyntaxKind.ClassKeyword]: 'ClassKeyword',
    [ts.SyntaxKind.ConstKeyword]: 'ConstKeyword',
    [ts.SyntaxKind.ContinueKeyword]: 'ContinueKeyword',
    [ts.SyntaxKind.DebuggerKeyword]: 'DebuggerKeyword',
    [ts.SyntaxKind.DefaultKeyword]: 'DefaultKeyword',
    [ts.SyntaxKind.DeleteKeyword]: 'DeleteKeyword',
    [ts.SyntaxKind.DoKeyword]: 'DoKeyword',
    [ts.SyntaxKind.ElseKeyword]: 'ElseKeyword',
    [ts.SyntaxKind.EnumKeyword]: 'EnumKeyword',
    [ts.SyntaxKind.ExportKeyword]: 'ExportKeyword',
    [ts.SyntaxKind.ExtendsKeyword]: 'ExtendsKeyword',
    [ts.SyntaxKind.FalseKeyword]: 'FalseKeyword',
    [ts.SyntaxKind.FinallyKeyword]: 'FinallyKeyword',
    [ts.SyntaxKind.ForKeyword]: 'ForKeyword',
    [ts.SyntaxKind.FunctionKeyword]: 'FunctionKeyword',
    [ts.SyntaxKind.IfKeyword]: 'IfKeyword',
    [ts.SyntaxKind.ImportKeyword]: 'ImportKeyword',
    [ts.SyntaxKind.InKeyword]: 'InKeyword',
    [ts.SyntaxKind.InstanceOfKeyword]: 'InstanceOfKeyword',
    [ts.SyntaxKind.NewKeyword]: 'NewKeyword',
    [ts.SyntaxKind.NullKeyword]: 'NullKeyword',
    [ts.SyntaxKind.ReturnKeyword]: 'ReturnKeyword',
    [ts.SyntaxKind.SuperKeyword]: 'SuperKeyword',
    [ts.SyntaxKind.SwitchKeyword]: 'SwitchKeyword',
    [ts.SyntaxKind.ThisKeyword]: 'ThisKeyword',
    [ts.SyntaxKind.ThrowKeyword]: 'ThrowKeyword',
    [ts.SyntaxKind.TrueKeyword]: 'TrueKeyword',
    [ts.SyntaxKind.TryKeyword]: 'TryKeyword',
    [ts.SyntaxKind.TypeOfKeyword]: 'TypeOfKeyword',
    [ts.SyntaxKind.VarKeyword]: 'VarKeyword',
    [ts.SyntaxKind.VoidKeyword]: 'VoidKeyword',
    [ts.SyntaxKind.WhileKeyword]: 'WhileKeyword',
    [ts.SyntaxKind.WithKeyword]: 'WithKeyword',
    [ts.SyntaxKind.ImplementsKeyword]: 'ImplementsKeyword',
    [ts.SyntaxKind.InterfaceKeyword]: 'InterfaceKeyword',
    [ts.SyntaxKind.LetKeyword]: 'LetKeyword',
    [ts.SyntaxKind.PackageKeyword]: 'PackageKeyword',
    [ts.SyntaxKind.PrivateKeyword]: 'PrivateKeyword',
    [ts.SyntaxKind.ProtectedKeyword]: 'ProtectedKeyword',
    [ts.SyntaxKind.PublicKeyword]: 'PublicKeyword',
    [ts.SyntaxKind.StaticKeyword]: 'StaticKeyword',
    [ts.SyntaxKind.YieldKeyword]: 'YieldKeyword',
    [ts.SyntaxKind.AbstractKeyword]: 'AbstractKeyword',
    [ts.SyntaxKind.AccessorKeyword]: 'AccessorKeyword',
    [ts.SyntaxKind.AsKeyword]: 'AsKeyword',
    [ts.SyntaxKind.AssertsKeyword]: 'AssertsKeyword',
    [ts.SyntaxKind.AssertKeyword]: 'AssertKeyword',
    [ts.SyntaxKind.AnyKeyword]: 'AnyKeyword',
    [ts.SyntaxKind.AsyncKeyword]: 'AsyncKeyword',
    [ts.SyntaxKind.AwaitKeyword]: 'AwaitKeyword',
    [ts.SyntaxKind.BooleanKeyword]: 'BooleanKeyword',
    [ts.SyntaxKind.ConstructorKeyword]: 'ConstructorKeyword',
    [ts.SyntaxKind.DeclareKeyword]: 'DeclareKeyword',
    [ts.SyntaxKind.GetKeyword]: 'GetKeyword',
    [ts.SyntaxKind.InferKeyword]: 'InferKeyword',
    [ts.SyntaxKind.IntrinsicKeyword]: 'IntrinsicKeyword',
    [ts.SyntaxKind.IsKeyword]: 'IsKeyword',
    [ts.SyntaxKind.KeyOfKeyword]: 'KeyOfKeyword',
    [ts.SyntaxKind.ModuleKeyword]: 'ModuleKeyword',
    [ts.SyntaxKind.NamespaceKeyword]: 'NamespaceKeyword',
    [ts.SyntaxKind.NeverKeyword]: 'NeverKeyword',
    [ts.SyntaxKind.OutKeyword]: 'OutKeyword',
    [ts.SyntaxKind.ReadonlyKeyword]: 'ReadonlyKeyword',
    [ts.SyntaxKind.RequireKeyword]: 'RequireKeyword',
    [ts.SyntaxKind.NumberKeyword]: 'NumberKeyword',
    [ts.SyntaxKind.ObjectKeyword]: 'ObjectKeyword',
    [ts.SyntaxKind.SatisfiesKeyword]: 'SatisfiesKeyword',
    [ts.SyntaxKind.SetKeyword]: 'SetKeyword',
    [ts.SyntaxKind.StringKeyword]: 'StringKeyword',
    [ts.SyntaxKind.SymbolKeyword]: 'SymbolKeyword',
    [ts.SyntaxKind.TypeKeyword]: 'TypeKeyword',
    [ts.SyntaxKind.UndefinedKeyword]: 'UndefinedKeyword',
    [ts.SyntaxKind.UniqueKeyword]: 'UniqueKeyword',
    [ts.SyntaxKind.UnknownKeyword]: 'UnknownKeyword',
    [ts.SyntaxKind.UsingKeyword]: 'UsingKeyword',
    [ts.SyntaxKind.FromKeyword]: 'FromKeyword',
    [ts.SyntaxKind.GlobalKeyword]: 'GlobalKeyword',
    [ts.SyntaxKind.BigIntKeyword]: 'BigIntKeyword',
    [ts.SyntaxKind.OverrideKeyword]: 'OverrideKeyword',
    [ts.SyntaxKind.OfKeyword]: 'OfKeyword',
    [ts.SyntaxKind.QualifiedName]: 'QualifiedName',
    [ts.SyntaxKind.ComputedPropertyName]: 'ComputedPropertyName',
    [ts.SyntaxKind.TypeParameter]: 'TypeParameter',
    [ts.SyntaxKind.Parameter]: 'Parameter',
    [ts.SyntaxKind.Decorator]: 'Decorator',
    [ts.SyntaxKind.PropertySignature]: 'PropertySignature',
    [ts.SyntaxKind.PropertyDeclaration]: 'PropertyDeclaration',
    [ts.SyntaxKind.MethodSignature]: 'MethodSignature',
    [ts.SyntaxKind.MethodDeclaration]: 'MethodDeclaration',
    [ts.SyntaxKind.ClassStaticBlockDeclaration]: 'ClassStaticBlockDeclaration',
    [ts.SyntaxKind.Constructor]: 'Constructor',
    [ts.SyntaxKind.GetAccessor]: 'GetAccessor',
    [ts.SyntaxKind.SetAccessor]: 'SetAccessor',
    [ts.SyntaxKind.CallSignature]: 'CallSignature',
    [ts.SyntaxKind.ConstructSignature]: 'ConstructSignature',
    [ts.SyntaxKind.IndexSignature]: 'IndexSignature',
    [ts.SyntaxKind.TypePredicate]: 'TypePredicate',
    [ts.SyntaxKind.TypeReference]: 'TypeReference',
    [ts.SyntaxKind.FunctionType]: 'FunctionType',
    [ts.SyntaxKind.ConstructorType]: 'ConstructorType',
    [ts.SyntaxKind.TypeQuery]: 'TypeQuery',
    [ts.SyntaxKind.TypeLiteral]: 'TypeLiteral',
    [ts.SyntaxKind.ArrayType]: 'ArrayType',
    [ts.SyntaxKind.TupleType]: 'TupleType',
    [ts.SyntaxKind.OptionalType]: 'OptionalType',
    [ts.SyntaxKind.RestType]: 'RestType',
    [ts.SyntaxKind.UnionType]: 'UnionType',
    [ts.SyntaxKind.IntersectionType]: 'IntersectionType',
    [ts.SyntaxKind.ConditionalType]: 'ConditionalType',
    [ts.SyntaxKind.InferType]: 'InferType',
    [ts.SyntaxKind.ParenthesizedType]: 'ParenthesizedType',
    [ts.SyntaxKind.ThisType]: 'ThisType',
    [ts.SyntaxKind.TypeOperator]: 'TypeOperator',
    [ts.SyntaxKind.IndexedAccessType]: 'IndexedAccessType',
    [ts.SyntaxKind.MappedType]: 'MappedType',
    [ts.SyntaxKind.LiteralType]: 'LiteralType',
    [ts.SyntaxKind.NamedTupleMember]: 'NamedTupleMember',
    [ts.SyntaxKind.TemplateLiteralType]: 'TemplateLiteralType',
    [ts.SyntaxKind.TemplateLiteralTypeSpan]: 'TemplateLiteralTypeSpan',
    [ts.SyntaxKind.ImportType]: 'ImportType',
    [ts.SyntaxKind.ObjectBindingPattern]: 'ObjectBindingPattern',
    [ts.SyntaxKind.ArrayBindingPattern]: 'ArrayBindingPattern',
    [ts.SyntaxKind.BindingElement]: 'BindingElement',
    [ts.SyntaxKind.ArrayLiteralExpression]: 'ArrayLiteralExpression',
    [ts.SyntaxKind.ObjectLiteralExpression]: 'ObjectLiteralExpression',
    [ts.SyntaxKind.PropertyAccessExpression]: 'PropertyAccessExpression',
    [ts.SyntaxKind.ElementAccessExpression]: 'ElementAccessExpression',
    [ts.SyntaxKind.CallExpression]: 'CallExpression',
    [ts.SyntaxKind.NewExpression]: 'NewExpression',
    [ts.SyntaxKind.TaggedTemplateExpression]: 'TaggedTemplateExpression',
    [ts.SyntaxKind.TypeAssertionExpression]: 'TypeAssertionExpression',
    [ts.SyntaxKind.ParenthesizedExpression]: 'ParenthesizedExpression',
    [ts.SyntaxKind.FunctionExpression]: 'FunctionExpression',
    [ts.SyntaxKind.ArrowFunction]: 'ArrowFunction',
    [ts.SyntaxKind.DeleteExpression]: 'DeleteExpression',
    [ts.SyntaxKind.TypeOfExpression]: 'TypeOfExpression',
    [ts.SyntaxKind.VoidExpression]: 'VoidExpression',
    [ts.SyntaxKind.AwaitExpression]: 'AwaitExpression',
    [ts.SyntaxKind.PrefixUnaryExpression]: 'PrefixUnaryExpression',
    [ts.SyntaxKind.PostfixUnaryExpression]: 'PostfixUnaryExpression',
    [ts.SyntaxKind.BinaryExpression]: 'BinaryExpression',
    [ts.SyntaxKind.ConditionalExpression]: 'ConditionalExpression',
    [ts.SyntaxKind.TemplateExpression]: 'TemplateExpression',
    [ts.SyntaxKind.YieldExpression]: 'YieldExpression',
    [ts.SyntaxKind.SpreadElement]: 'SpreadElement',
    [ts.SyntaxKind.ClassExpression]: 'ClassExpression',
    [ts.SyntaxKind.OmittedExpression]: 'OmittedExpression',
    [ts.SyntaxKind.ExpressionWithTypeArguments]: 'ExpressionWithTypeArguments',
    [ts.SyntaxKind.AsExpression]: 'AsExpression',
    [ts.SyntaxKind.NonNullExpression]: 'NonNullExpression',
    [ts.SyntaxKind.MetaProperty]: 'MetaProperty',
    [ts.SyntaxKind.SyntheticExpression]: 'SyntheticExpression',
    [ts.SyntaxKind.SatisfiesExpression]: 'SatisfiesExpression',
    [ts.SyntaxKind.TemplateSpan]: 'TemplateSpan',
    [ts.SyntaxKind.SemicolonClassElement]: 'SemicolonClassElement',
    [ts.SyntaxKind.Block]: 'Block',
    [ts.SyntaxKind.EmptyStatement]: 'EmptyStatement',
    [ts.SyntaxKind.VariableStatement]: 'VariableStatement',
    [ts.SyntaxKind.ExpressionStatement]: 'ExpressionStatement',
    [ts.SyntaxKind.IfStatement]: 'IfStatement',
    [ts.SyntaxKind.DoStatement]: 'DoStatement',
    [ts.SyntaxKind.WhileStatement]: 'WhileStatement',
    [ts.SyntaxKind.ForStatement]: 'ForStatement',
    [ts.SyntaxKind.ForInStatement]: 'ForInStatement',
    [ts.SyntaxKind.ForOfStatement]: 'ForOfStatement',
    [ts.SyntaxKind.ContinueStatement]: 'ContinueStatement',
    [ts.SyntaxKind.BreakStatement]: 'BreakStatement',
    [ts.SyntaxKind.ReturnStatement]: 'ReturnStatement',
    [ts.SyntaxKind.WithStatement]: 'WithStatement',
    [ts.SyntaxKind.SwitchStatement]: 'SwitchStatement',
    [ts.SyntaxKind.LabeledStatement]: 'LabeledStatement',
    [ts.SyntaxKind.ThrowStatement]: 'ThrowStatement',
    [ts.SyntaxKind.TryStatement]: 'TryStatement',
    [ts.SyntaxKind.DebuggerStatement]: 'DebuggerStatement',
    [ts.SyntaxKind.VariableDeclaration]: 'VariableDeclaration',
    [ts.SyntaxKind.VariableDeclarationList]: 'VariableDeclarationList',
    [ts.SyntaxKind.FunctionDeclaration]: 'FunctionDeclaration',
    [ts.SyntaxKind.ClassDeclaration]: 'ClassDeclaration',
    [ts.SyntaxKind.InterfaceDeclaration]: 'InterfaceDeclaration',
    [ts.SyntaxKind.TypeAliasDeclaration]: 'TypeAliasDeclaration',
    [ts.SyntaxKind.EnumDeclaration]: 'EnumDeclaration',
    [ts.SyntaxKind.ModuleDeclaration]: 'ModuleDeclaration',
    [ts.SyntaxKind.ModuleBlock]: 'ModuleBlock',
    [ts.SyntaxKind.CaseBlock]: 'CaseBlock',
    [ts.SyntaxKind.NamespaceExportDeclaration]: 'NamespaceExportDeclaration',
    [ts.SyntaxKind.ImportEqualsDeclaration]: 'ImportEqualsDeclaration',
    [ts.SyntaxKind.ImportDeclaration]: 'ImportDeclaration',
    [ts.SyntaxKind.ImportClause]: 'ImportClause',
    [ts.SyntaxKind.NamespaceImport]: 'NamespaceImport',
    [ts.SyntaxKind.NamedImports]: 'NamedImports',
    [ts.SyntaxKind.ImportSpecifier]: 'ImportSpecifier',
    [ts.SyntaxKind.ExportAssignment]: 'ExportAssignment',
    [ts.SyntaxKind.ExportDeclaration]: 'ExportDeclaration',
    [ts.SyntaxKind.NamedExports]: 'NamedExports',
    [ts.SyntaxKind.NamespaceExport]: 'NamespaceExport',
    [ts.SyntaxKind.ExportSpecifier]: 'ExportSpecifier',
    [ts.SyntaxKind.MissingDeclaration]: 'MissingDeclaration',
    [ts.SyntaxKind.ExternalModuleReference]: 'ExternalModuleReference',
    [ts.SyntaxKind.JsxElement]: 'JsxElement',
    [ts.SyntaxKind.JsxSelfClosingElement]: 'JsxSelfClosingElement',
    [ts.SyntaxKind.JsxOpeningElement]: 'JsxOpeningElement',
    [ts.SyntaxKind.JsxClosingElement]: 'JsxClosingElement',
    [ts.SyntaxKind.JsxFragment]: 'JsxFragment',
    [ts.SyntaxKind.JsxOpeningFragment]: 'JsxOpeningFragment',
    [ts.SyntaxKind.JsxClosingFragment]: 'JsxClosingFragment',
    [ts.SyntaxKind.JsxAttribute]: 'JsxAttribute',
    [ts.SyntaxKind.JsxAttributes]: 'JsxAttributes',
    [ts.SyntaxKind.JsxSpreadAttribute]: 'JsxSpreadAttribute',
    [ts.SyntaxKind.JsxExpression]: 'JsxExpression',
    [ts.SyntaxKind.JsxNamespacedName]: 'JsxNamespacedName',
    [ts.SyntaxKind.CaseClause]: 'CaseClause',
    [ts.SyntaxKind.DefaultClause]: 'DefaultClause',
    [ts.SyntaxKind.HeritageClause]: 'HeritageClause',
    [ts.SyntaxKind.CatchClause]: 'CatchClause',
    [ts.SyntaxKind.ImportAttributes]: 'ImportAttributes',
    [ts.SyntaxKind.ImportAttribute]: 'ImportAttribute',
    [ts.SyntaxKind.PropertyAssignment]: 'PropertyAssignment',
    [ts.SyntaxKind.ShorthandPropertyAssignment]: 'ShorthandPropertyAssignment',
    [ts.SyntaxKind.SpreadAssignment]: 'SpreadAssignment',
    [ts.SyntaxKind.EnumMember]: 'EnumMember',
    [ts.SyntaxKind.SourceFile]: 'SourceFile',
    [ts.SyntaxKind.Bundle]: 'Bundle',
    [ts.SyntaxKind.JSDocTypeExpression]: 'JSDocTypeExpression',
    [ts.SyntaxKind.JSDocNameReference]: 'JSDocNameReference',
    [ts.SyntaxKind.JSDocMemberName]: 'JSDocMemberName',
    [ts.SyntaxKind.JSDocAllType]: 'JSDocAllType',
    [ts.SyntaxKind.JSDocUnknownType]: 'JSDocUnknownType',
    [ts.SyntaxKind.JSDocNullableType]: 'JSDocNullableType',
    [ts.SyntaxKind.JSDocNonNullableType]: 'JSDocNonNullableType',
    [ts.SyntaxKind.JSDocOptionalType]: 'JSDocOptionalType',
    [ts.SyntaxKind.JSDocFunctionType]: 'JSDocFunctionType',
    [ts.SyntaxKind.JSDocVariadicType]: 'JSDocVariadicType',
    [ts.SyntaxKind.JSDocNamepathType]: 'JSDocNamepathType',
    [ts.SyntaxKind.JSDoc]: 'JSDoc',
    [ts.SyntaxKind.JSDocText]: 'JSDocText',
    [ts.SyntaxKind.JSDocTypeLiteral]: 'JSDocTypeLiteral',
    [ts.SyntaxKind.JSDocSignature]: 'JSDocSignature',
    [ts.SyntaxKind.JSDocLink]: 'JSDocLink',
    [ts.SyntaxKind.JSDocLinkCode]: 'JSDocLinkCode',
    [ts.SyntaxKind.JSDocLinkPlain]: 'JSDocLinkPlain',
    [ts.SyntaxKind.JSDocTag]: 'JSDocTag',
    [ts.SyntaxKind.JSDocAugmentsTag]: 'JSDocAugmentsTag',
    [ts.SyntaxKind.JSDocImplementsTag]: 'JSDocImplementsTag',
    [ts.SyntaxKind.JSDocAuthorTag]: 'JSDocAuthorTag',
    [ts.SyntaxKind.JSDocDeprecatedTag]: 'JSDocDeprecatedTag',
    [ts.SyntaxKind.JSDocClassTag]: 'JSDocClassTag',
    [ts.SyntaxKind.JSDocPublicTag]: 'JSDocPublicTag',
    [ts.SyntaxKind.JSDocPrivateTag]: 'JSDocPrivateTag',
    [ts.SyntaxKind.JSDocProtectedTag]: 'JSDocProtectedTag',
    [ts.SyntaxKind.JSDocReadonlyTag]: 'JSDocReadonlyTag',
    [ts.SyntaxKind.JSDocOverrideTag]: 'JSDocOverrideTag',
    [ts.SyntaxKind.JSDocCallbackTag]: 'JSDocCallbackTag',
    [ts.SyntaxKind.JSDocOverloadTag]: 'JSDocOverloadTag',
    [ts.SyntaxKind.JSDocEnumTag]: 'JSDocEnumTag',
    [ts.SyntaxKind.JSDocParameterTag]: 'JSDocParameterTag',
    [ts.SyntaxKind.JSDocReturnTag]: 'JSDocReturnTag',
    [ts.SyntaxKind.JSDocThisTag]: 'JSDocThisTag',
    [ts.SyntaxKind.JSDocTypeTag]: 'JSDocTypeTag',
    [ts.SyntaxKind.JSDocTemplateTag]: 'JSDocTemplateTag',
    [ts.SyntaxKind.JSDocTypedefTag]: 'JSDocTypedefTag',
    [ts.SyntaxKind.JSDocSeeTag]: 'JSDocSeeTag',
    [ts.SyntaxKind.JSDocPropertyTag]: 'JSDocPropertyTag',
    [ts.SyntaxKind.JSDocThrowsTag]: 'JSDocThrowsTag',
    [ts.SyntaxKind.JSDocSatisfiesTag]: 'JSDocSatisfiesTag',
    [ts.SyntaxKind.SyntaxList]: 'SyntaxList',
    [ts.SyntaxKind.NotEmittedStatement]: 'NotEmittedStatement',
    [ts.SyntaxKind.PartiallyEmittedExpression]: 'PartiallyEmittedExpression',
    [ts.SyntaxKind.CommaListExpression]: 'CommaListExpression',
    [ts.SyntaxKind.SyntheticReferenceExpression]: 'SyntheticReferenceExpression',
    [ts.SyntaxKind.Count]: 'Count',
};
const namesRecord = SyntaxKindName;
const getNodeName = (node) => {
    return namesRecord[node.kind] ?? 'Unknown';
};
const getSyntaxName = (kind) => {
    return namesRecord[kind] ?? 'Unknown';
};
const BinaryOpSyntaxes = {
    [ts.SyntaxKind.PlusToken]: BuilderBinaryOp.add,
    [ts.SyntaxKind.MinusToken]: BuilderBinaryOp.sub,
    [ts.SyntaxKind.AsteriskToken]: BuilderBinaryOp.mult,
    [ts.SyntaxKind.SlashToken]: BuilderBinaryOp.div,
    [ts.SyntaxKind.PercentToken]: BuilderBinaryOp.mod,
    [ts.SyntaxKind.AsteriskAsteriskToken]: BuilderBinaryOp.pow,
    [ts.SyntaxKind.BarToken]: BuilderBinaryOp.bitOr,
    [ts.SyntaxKind.CaretToken]: BuilderBinaryOp.bitXor,
    [ts.SyntaxKind.AmpersandToken]: BuilderBinaryOp.bitAnd,
    [ts.SyntaxKind.LessThanLessThanToken]: BuilderBinaryOp.lshift,
    [ts.SyntaxKind.GreaterThanGreaterThanToken]: BuilderBinaryOp.rshift,
};
const LogicalOpSyntaxes = {
    [ts.SyntaxKind.AmpersandAmpersandToken]: BinaryBooleanOperator.and,
    [ts.SyntaxKind.BarBarToken]: BinaryBooleanOperator.or,
};
const AugmentedAssignmentLogicalOpSyntaxes = {
    [ts.SyntaxKind.AmpersandAmpersandEqualsToken]: BinaryBooleanOperator.and,
    [ts.SyntaxKind.BarBarEqualsToken]: BinaryBooleanOperator.or,
};
function isKeyOf(key, map) {
    return Object.hasOwn(map, key);
}
const ComparisonOpSyntaxes = {
    [ts.SyntaxKind.EqualsEqualsEqualsToken]: BuilderComparisonOp.eq,
    [ts.SyntaxKind.ExclamationEqualsEqualsToken]: BuilderComparisonOp.ne,
    [ts.SyntaxKind.LessThanToken]: BuilderComparisonOp.lt,
    [ts.SyntaxKind.LessThanEqualsToken]: BuilderComparisonOp.lte,
    [ts.SyntaxKind.GreaterThanToken]: BuilderComparisonOp.gt,
    [ts.SyntaxKind.GreaterThanEqualsToken]: BuilderComparisonOp.gte,
};
const AugmentedAssignmentBinaryOp = {
    [ts.SyntaxKind.PlusEqualsToken]: BuilderBinaryOp.add,
    [ts.SyntaxKind.MinusEqualsToken]: BuilderBinaryOp.sub,
    [ts.SyntaxKind.AsteriskEqualsToken]: BuilderBinaryOp.mult,
    [ts.SyntaxKind.SlashEqualsToken]: BuilderBinaryOp.div,
    [ts.SyntaxKind.PercentEqualsToken]: BuilderBinaryOp.mod,
    [ts.SyntaxKind.AsteriskAsteriskEqualsToken]: BuilderBinaryOp.pow,
    [ts.SyntaxKind.BarEqualsToken]: BuilderBinaryOp.bitOr,
    [ts.SyntaxKind.CaretEqualsToken]: BuilderBinaryOp.bitXor,
    [ts.SyntaxKind.AmpersandEqualsToken]: BuilderBinaryOp.bitAnd,
    [ts.SyntaxKind.LessThanLessThanEqualsToken]: BuilderBinaryOp.lshift,
    [ts.SyntaxKind.GreaterThanGreaterThanEqualsToken]: BuilderBinaryOp.rshift,
};
const UnaryExpressionUnaryOps = {
    [ts.SyntaxKind.PlusPlusToken]: BuilderUnaryOp.inc,
    [ts.SyntaxKind.MinusMinusToken]: BuilderUnaryOp.dec,
    [ts.SyntaxKind.PlusToken]: BuilderUnaryOp.pos,
    [ts.SyntaxKind.MinusToken]: BuilderUnaryOp.neg,
    [ts.SyntaxKind.TildeToken]: BuilderUnaryOp.bit_inv,
};

class TypeResolver {
    checker;
    programDirectory;
    constructor(checker, programDirectory) {
        this.checker = checker;
        this.programDirectory = programDirectory;
    }
    getUnaliasedSymbolForNode(node) {
        const symbol = this.checker.getSymbolAtLocation(node);
        if (symbol) {
            if (hasFlags(symbol.flags, ts.SymbolFlags.Alias)) {
                return this.checker.getAliasedSymbol(symbol);
            }
            return symbol;
        }
        return undefined;
    }
    resolveTypeParameters(node, sourceLocation) {
        if (node.typeArguments) {
            // Explicit type arguments
            return node.typeArguments.map((t) => this.resolveTypeNode(t, sourceLocation));
        }
        const sig = this.checker.getResolvedSignature(node);
        invariant(sig, 'CallExpression must resolve to a signature');
        /*
          The method getTypeArgumentsForResolvedSignature has not made it into typescript yet, but it has been
          proposed here: https://github.com/microsoft/TypeScript/issues/59637 and added to the backlog. For now
          the method has been patched into the TypeScript 5.7.2 using patch-package
         */
        const tps = this.checker.getTypeArgumentsForResolvedSignature(sig);
        return tps?.map((t) => this.resolveType(t, sourceLocation)) ?? [];
    }
    resolve(node, sourceLocation) {
        const symbol = this.getUnaliasedSymbolForNode(node);
        if (symbol !== undefined && symbol.declarations?.length) {
            const symbolName = symbol && this.getSymbolFullName(symbol, sourceLocation);
            if (symbolName.name === '*') {
                return new NamespacePType(symbolName);
            }
            const ptype = typeRegistry.tryResolveSingletonName(symbolName);
            if (ptype === undefined && symbolName.module.startsWith(Constants.algoTsPackage)) {
                /*
                 Most symbols in the algo-ts module should resolve to a singleton instance
                 This can probably be removed once we've implemented ptypes for everything in algo-ts
        
                 */
                if (symbolName.fullName !== baseContractType.fullName && symbolName.fullName !== arc4BaseContractType.fullName)
                    logger.warn(sourceLocation, `${symbolName} could not be resolved to a singleton ptype`);
            }
            if (ptype) {
                return ptype;
            }
        }
        const type = this.checker.getTypeAtLocation(node);
        if (node.kind === ts.SyntaxKind.ThisKeyword || node.kind === ts.SyntaxKind.SuperKeyword) {
            /**
             * This shouldn't be used in any code paths as `visitThisKeyword` and `visitSuperKeyword` have their own way to
             * determine the type.
             */
            logger.debug(sourceLocation, `Attempting to reflect type of ${getNodeName(node)} node which is known to be unreliable`);
        }
        if (ts.isConstructorDeclaration(node)) {
            const signature = this.checker.getSignatureFromDeclaration(node);
            invariant(signature, 'Constructor node must have call signature');
            const parentType = this.getTypeName(this.checker.getTypeAtLocation(node.parent), sourceLocation);
            return this.reflectFunctionType(new SymbolName({
                name: Constants.symbolNames.constructorMethodName,
                module: parentType.module,
            }), [signature], sourceLocation);
        }
        return this.resolveType(type, sourceLocation);
    }
    resolveTypeNode(node, sourceLocation) {
        const type = this.checker.getTypeFromTypeNode(node);
        return this.resolveType(type, sourceLocation);
    }
    resolveType(tsType, sourceLocation) {
        if (tsType.symbol) {
            const symbolType = this.checker.getTypeOfSymbol(tsType.symbol);
            if (symbolType !== tsType && !tsType.isClass() && symbolType.isClass()) {
                tsType = symbolType;
            }
        }
        intersect: if (isIntersectionType(tsType)) {
            if (tsType.aliasSymbol) {
                break intersect;
            }
            // Special handling of struct base types which are an intersection of `StructBase` and the generic `T` type
            const parts = tsType.types.map((t) => this.resolveType(t, sourceLocation));
            if (parts.some((p) => p.equals(arc4StructBaseType))) {
                return arc4StructBaseType;
            }
            else {
                return IntersectionPType.fromTypes(parts);
            }
        }
        if (isUnionType(tsType)) {
            const ut = UnionPType.fromTypes(tsType.types.map((t) => this.resolveType(t, sourceLocation)));
            if (ut.equals(gtxnUnion)) {
                return anyGtxnType;
            }
            return ut;
        }
        switch (tsType.flags) {
            case ts.TypeFlags.Undefined:
                return undefinedPType;
            case ts.TypeFlags.Null:
                return nullPType;
            case ts.TypeFlags.Any:
                return anyPType;
            case ts.TypeFlags.Boolean | ts.TypeFlags.Union:
            case ts.TypeFlags.BooleanLiteral:
                return boolPType;
            case ts.TypeFlags.Void:
                return voidPType;
            case ts.TypeFlags.String:
            case ts.TypeFlags.StringLiteral:
                return stringPType;
            case ts.TypeFlags.Never:
                return neverPType;
            case ts.TypeFlags.Unknown:
                return unknownPType;
            case ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral:
            case ts.TypeFlags.NumberLiteral:
                invariant(tsType.isNumberLiteral(), 'type must be literal', sourceLocation);
                return new NumericLiteralPType({ literalValue: BigInt(tsType.value) });
            case ts.TypeFlags.Number:
                return numberPType;
            case ts.TypeFlags.BigIntLiteral:
                invariant(tsType.isLiteral() && typeof tsType.value === 'object', 'type must be literal bigint', sourceLocation);
                return new BigIntLiteralPType({ literalValue: BigInt(tsType.value.base10Value) * (tsType.value.negative ? -1n : 1n) });
            case ts.TypeFlags.BigInt:
                return bigIntPType;
        }
        if (isTupleReference(tsType)) {
            codeInvariant(tsType.target.fixedLength !== undefined && tsType.target.fixedLength !== null, 'Tuple types should have a fixed length', sourceLocation);
            codeInvariant(tsType.typeArguments, 'Tuple items must have types', sourceLocation);
            return new TuplePType({
                items: tsType.typeArguments.map((t) => this.resolveType(t, sourceLocation)),
            });
        }
        if (isInstantiationExpression(tsType)) {
            return this.resolve(tsType.node.expression, sourceLocation);
        }
        const typeName = this.getTypeName(tsType, sourceLocation);
        logger.debug(sourceLocation, `Resolving ptype for ${typeName}`);
        if (typeName.name === '__type' && typeName.module.startsWith(Constants.algoTsPackage)) {
            // We are likely dealing with `typeof X` where X is a singleton exported by algo-ts
            const declarationNode = tsType.symbol.getDeclarations()?.[0]?.parent;
            if (declarationNode && ts.isVariableDeclaration(declarationNode)) {
                return this.resolve(declarationNode.name, sourceLocation);
            }
        }
        if (typeName.fullName === arc4StructBaseType.fullName)
            return arc4StructBaseType;
        if (typeName.fullName === ClusteredPrototype.fullName) {
            return this.resolveClusteredPrototype(tsType, sourceLocation);
        }
        if (tsType.flags === ts.TypeFlags.TypeParameter) {
            return new TypeParameterType(typeName);
        }
        if (tsType.aliasTypeArguments?.length) {
            const typeArgs = tsType.aliasTypeArguments.map((a) => this.resolveType(a, sourceLocation));
            const gt = typeRegistry.tryResolveGenericPType(typeName, typeArgs);
            if (gt)
                return gt;
        }
        else if (isTypeReference(tsType) && tsType.typeArguments?.length) {
            const typeArgs = tsType.typeArguments.map((a) => this.resolveType(a, sourceLocation));
            const gt = typeRegistry.tryResolveGenericPType(typeName, typeArgs);
            if (gt)
                return gt;
        }
        else {
            const it = typeRegistry.tryResolveInstancePType(typeName);
            if (it)
                return it;
        }
        if (tsType.getConstructSignatures().length) {
            return this.reflectConstructorType(tsType, sourceLocation);
        }
        if (tsType.isClass()) {
            if (typeName.fullName === arc4BaseContractType.fullName)
                return arc4BaseContractType;
            if (typeName.fullName === baseContractType.fullName)
                return baseContractType;
            if (typeName.fullName === logicSigBaseType.fullName)
                return logicSigBaseType;
            const [baseType, ...rest] = tsType.getBaseTypes()?.map((t) => this.resolveType(t, sourceLocation)) ?? [];
            invariant(rest.length === 0, 'Class can have at most one base type');
            // Treat sub-types of UintN type as the base type.
            if (baseType instanceof UintNType)
                return baseType;
            if (baseType instanceof ContractClassPType) {
                return this.reflectContractType(typeName, tsType, baseType, sourceLocation);
            }
            if (baseType instanceof ARC4StructType) {
                return this.reflectStructType(typeName, tsType, baseType, sourceLocation);
            }
            if (baseType instanceof LogicSigPType) {
                return new LogicSigPType({
                    ...typeName,
                    sourceLocation,
                    baseType,
                });
            }
            throw new CodeError(`${typeName.fullName} cannot be mapped to an algo ts type. Classes must extend "Contract" or "BaseContract" base classes to be considered a contract`, { sourceLocation });
        }
        const callSignatures = this.checker.getSignaturesOfType(tsType, ts.SignatureKind.Call);
        if (callSignatures.length) {
            return this.reflectFunctionType(typeName, callSignatures, sourceLocation);
        }
        if (this.checker.isArrayType(tsType)) {
            const itemType = tsType.getNumberIndexType();
            if (!itemType) {
                throw new CodeError('Cannot determine array item type', { sourceLocation });
            }
            else {
                const itemPType = this.resolveType(itemType, sourceLocation);
                return new ArrayPType({
                    elementType: itemPType,
                });
            }
        }
        if (isObjectType(tsType)) {
            return this.reflectObjectType(tsType, sourceLocation);
        }
        throw new InternalError(`Cannot determine type of ${typeName}`, { sourceLocation });
    }
    reflectObjectType(tsType, sourceLocation) {
        const typeAlias = tsType.aliasSymbol ? this.getSymbolFullName(tsType.aliasSymbol, sourceLocation) : undefined;
        const properties = {};
        for (const prop of tsType.getProperties()) {
            if (prop.name.startsWith('__@')) {
                // Symbol property - ignore
                // TODO: Check AST nodes to confirm?
                continue;
            }
            const type = this.checker.getTypeOfSymbol(prop);
            const ptype = this.resolveType(type, sourceLocation);
            if (ptype.singleton) {
                logger.error(sourceLocation, `${ptype} is not a valid object property type`);
            }
            else {
                properties[prop.name] = ptype;
            }
        }
        if (typeAlias) {
            return new ObjectPType({ alias: typeAlias, properties, description: tryGetTypeDescription(tsType) });
        }
        return ObjectPType.anonymous(properties);
    }
    reflectConstructorType(tsType, sourceLocation) {
        const constructorSignatures = tsType.getConstructSignatures();
        invariant(constructorSignatures.length, 'Must have at least one signature');
        const typeDeclaration = tsType.getSymbol()?.declarations?.[0];
        if (typeDeclaration && ts.isClassDeclaration(typeDeclaration)) {
            const ptype = this.resolve(typeDeclaration, sourceLocation);
            if (ptype instanceof ARC4StructType) {
                return ARC4StructClass.fromStructType(ptype);
            }
            else if (ptype instanceof ContractClassPType || ptype instanceof LogicSigPType) {
                return ptype;
            }
        }
        throw new CodeError('Unable to reflect constructor type', { sourceLocation });
    }
    reflectFunctionType(typeName, callSignatures, sourceLocation) {
        if (typeName.fullName === ApprovalProgram.fullName)
            return ApprovalProgram;
        if (typeName.fullName === ClearStateProgram.fullName)
            return ClearStateProgram;
        codeInvariant(callSignatures.length === 1, 'User defined functions must have exactly 1 call signature', sourceLocation);
        const [sig] = callSignatures;
        const returnType = this.resolveType(sig.getReturnType(), sourceLocation);
        const parameters = sig.getParameters().map((p) => {
            const paramType = this.checker.getTypeOfSymbol(p);
            return [p.name, this.resolveType(paramType, this.getLocationOfSymbol(p) ?? sourceLocation)];
        });
        return new FunctionPType({
            returnType,
            parameters,
            name: typeName.name,
            module: typeName.module,
            sourceLocation,
        });
    }
    reflectStructType(typeName, tsType, baseType, sourceLocation) {
        const ignoredProps = ['bytes', 'equals', 'native', 'copy', Constants.symbolNames.constructorMethodName];
        const fields = {};
        for (const prop of tsType.getProperties()) {
            if (isIn(prop.name, ignoredProps))
                continue;
            const type = this.checker.getTypeOfSymbol(prop);
            const propLocation = this.getLocationOfSymbol(prop) ?? sourceLocation;
            const ptype = this.resolveType(type, propLocation);
            if (ptype instanceof ARC4EncodedType) {
                fields[prop.name] = ptype;
            }
        }
        return new ARC4StructType({
            ...typeName,
            fields: fields,
            sourceLocation: sourceLocation,
            description: tryGetTypeDescription(tsType),
            frozen: baseType.frozen,
        });
    }
    reflectContractType(typeName, tsType, baseType, sourceLocation) {
        const properties = {};
        const methods = {};
        for (const prop of tsType.getProperties()) {
            const type = this.checker.getTypeOfSymbol(prop);
            const ptype = this.resolveType(type, this.getLocationOfSymbol(prop) ?? sourceLocation);
            if (ptype instanceof StorageProxyPType) {
                properties[prop.name] = ptype;
            }
            else if (ptype instanceof FunctionPType) {
                methods[prop.name] = ptype;
            }
        }
        return new ContractClassPType({
            properties,
            methods,
            name: typeName.name,
            module: typeName.module,
            baseTypes: [baseType],
            sourceLocation,
        });
    }
    resolveClusteredPrototype(tsType, sourceLocation) {
        invariant(isIntersectionType(tsType), 'Clustered prototypes must be an intersection type');
        const baseContracts = [];
        for (const t of tsType.types.map((t) => this.resolveType(t, sourceLocation))) {
            if (t instanceof ContractClassPType) {
                baseContracts.push(t);
            }
            else if (t instanceof SuperPrototypeSelector) ;
            else {
                throw new CodeError(`Unexpected type: ${t}. Polytype can only be used to support multiple inheritance in contracts for now. All base types must extend the Contract or BaseContract class.}`);
            }
        }
        return new ClusteredContractClassType({
            methods: {},
            baseTypes: baseContracts,
            sourceLocation,
        });
    }
    getTypeName(type, sourceLocation) {
        if (type.aliasSymbol) {
            const name = this.getSymbolFullName(type.aliasSymbol, sourceLocation);
            // We only respect type aliases within certain modules, otherwise use the
            // unaliased symbol
            if (name.module.startsWith(Constants.algoTsPackage) || name.module === Constants.moduleNames.polytype)
                return name;
        }
        invariant(type.symbol, 'Type must have a symbol', sourceLocation);
        return this.getSymbolFullName(type.symbol, sourceLocation);
    }
    getLocationOfSymbol(symbol) {
        const declaration = symbol.getDeclarations()?.[0];
        return declaration && SourceLocation.fromNode(declaration, this.programDirectory);
    }
    tryGetLocalSymbolName(symbol) {
        const dec = symbol.getDeclarations()?.[0];
        return dec?.localSymbol?.name;
    }
    getSymbolFullName(symbol, sourceLocation) {
        const symbolName = symbol.name === 'default' ? (this.tryGetLocalSymbolName(symbol) ?? symbol.name) : symbol.name;
        const declaration = symbol?.declarations?.[0];
        if (declaration) {
            if (intersectsFlags(symbol.flags, ts.SymbolFlags.Namespace) &&
                !intersectsFlags(symbol.flags, ts.SymbolFlags.Function | ts.SymbolFlags.RegularEnum)) {
                return new SymbolName({
                    module: normalisePath(declaration.getSourceFile().fileName, this.programDirectory),
                    name: '*',
                });
            }
            return new SymbolName({ module: normalisePath(declaration.getSourceFile().fileName, this.programDirectory), name: symbolName });
        }
        throw new InternalError(`Symbol does not have a declaration`, { sourceLocation });
    }
}
function isObjectType(tsType) {
    return hasFlags(tsType.flags, ts.TypeFlags.Object);
}
function isTypeReference(tsType) {
    return isObjectType(tsType) && hasFlags(tsType.objectFlags, ts.ObjectFlags.Reference);
}
function isTupleType(tsType) {
    return isObjectType(tsType) && hasFlags(tsType.objectFlags, ts.ObjectFlags.Tuple);
}
function isTupleReference(tsType) {
    return isTypeReference(tsType) && isTupleType(tsType.target);
}
function isUnionType(tsType) {
    return tsType.flags === ts.TypeFlags.Union;
}
function isIntersectionType(tsType) {
    return tsType.flags === ts.TypeFlags.Intersection;
}
function isInstantiationExpression(tsType) {
    return isObjectType(tsType) && hasFlags(tsType.objectFlags, ObjectFlags.InstantiationExpressionType);
}
function tryGetTypeDescription(tsType) {
    const dec = tsType.aliasSymbol?.valueDeclaration ?? tsType.symbol.valueDeclaration;
    if (!dec)
        return undefined;
    const docs = ts.getJSDocCommentsAndTags(dec);
    for (const doc of docs) {
        if (ts.isJSDoc(doc)) {
            return ts.getTextOfJSDocComment(doc.comment);
        }
    }
    return undefined;
}

/**
 * Tracks the context in which expressions should be evaluated.
 *
 * A boolean context is more lenient with mixed expression types as it is only concerned with truthy-ness
 */
class EvaluationContext {
    #isBoolean = false;
    get isBoolean() {
        return this.#isBoolean;
    }
    enterBooleanContext() {
        const previous = this.#isBoolean;
        this.#isBoolean = true;
        return {
            [Symbol.dispose]: () => {
                this.#isBoolean = previous;
            },
        };
    }
    leaveBooleanContext() {
        const previous = this.#isBoolean;
        this.#isBoolean = false;
        return {
            [Symbol.dispose]: () => {
                this.#isBoolean = previous;
            },
        };
    }
}

function defaultRecord(defaultInit) {
    return new Proxy({}, {
        get(target, property, receiver) {
            if (!(property in target)) {
                Object.assign(target, { [property]: defaultInit(property) });
            }
            return Reflect.get(target, property, receiver);
        },
    });
}

const breakSuffix = 'ᵇ';
const continueSuffix = 'ᶜ';
/**
 * Tracks parent switches and loops so that break and continue statements
 * can target the correct parent.
 */
class SwitchLoopContext {
    labelCount = defaultRecord(() => 0);
    unlabelledCount = defaultRecord(() => 0);
    constructor() { }
    switchLoopStack = [];
    getBreakTarget(label, sourceLocation) {
        const labelName = label?.text;
        const item = this.switchLoopStack.toReversed().find(({ label }) => labelName === undefined || label === labelName);
        codeInvariant(item, 'Break must exist inside a switch or loop construct', sourceLocation);
        item.numBreaks++;
        return `${item.uniqueName}${breakSuffix}`;
    }
    getContinueTarget(label, sourceLocation) {
        const labelName = label?.text;
        const item = this.switchLoopStack.toReversed().find(({ label }) => labelName === undefined || label === labelName);
        codeInvariant(item?.type === 'loop', 'Continue must exist inside a loop construct', sourceLocation);
        item.numContinues++;
        return `${item.uniqueName}${continueSuffix}`;
    }
    enterLoop(node, sourceLocation) {
        const label = ts.isLabeledStatement(node.parent) ? node?.parent.label : undefined;
        const uniqueName = this.uniqueNameForLabel(label, 'loop');
        const stackData = {
            uniqueName,
            label: label?.text,
            type: 'loop',
            numBreaks: 0,
            numContinues: 0,
        };
        this.switchLoopStack.push(stackData);
        return {
            breakTarget: nodeFactory.block({ sourceLocation, label: `${uniqueName}${breakSuffix}` }),
            continueTarget: nodeFactory.block({ sourceLocation, label: `${uniqueName}${continueSuffix}` }),
            [Symbol.dispose]: () => {
                const popped = this.switchLoopStack.pop();
                invariant(popped?.uniqueName === uniqueName && popped.type === 'loop', 'Switch loop stack is unbalanced');
            },
            get hasBreaks() {
                return stackData.numBreaks > 0;
            },
            get hasContinues() {
                return stackData.numContinues > 0;
            },
        };
    }
    uniqueNameForLabel(label, type) {
        if (label) {
            const count = ++this.labelCount[label.text];
            return `${label.text}${toSubScript(count)}`;
        }
        else {
            const nextCount = ++this.unlabelledCount[type];
            return `#${type}${toSubScript(nextCount)}`;
        }
    }
    enterSwitch(node, sourceLocation) {
        const label = ts.isLabeledStatement(node.parent) ? node?.parent.label : undefined;
        const uniqueName = this.uniqueNameForLabel(label, 'switch');
        const stackData = {
            uniqueName,
            label: label?.text,
            type: 'switch',
            numBreaks: 0,
        };
        this.switchLoopStack.push(stackData);
        return {
            breakTarget: nodeFactory.block({ sourceLocation, label: `${uniqueName}${breakSuffix}` }),
            caseTarget(caseIndex, sourceLocation) {
                return nodeFactory.block({ sourceLocation, label: `${uniqueName}ᶜ${toSubScript(caseIndex)}` });
            },
            gotoCase(caseIndex, sourceLocation) {
                return nodeFactory.goto({ sourceLocation, target: `${uniqueName}ᶜ${toSubScript(caseIndex)}` });
            },
            [Symbol.dispose]: () => {
                const popped = this.switchLoopStack.pop();
                invariant(popped?.uniqueName === uniqueName && popped.type === 'switch', 'Switch loop stack is unbalanced');
            },
            get hasBreaks() {
                return stackData.numBreaks > 0;
            },
        };
    }
}

class UniqueNameResolver {
    symbolToName;
    nameToCount;
    constructor(parent) {
        if (parent) {
            this.symbolToName = new Map(parent.symbolToName.entries());
            this.nameToCount = new Map(parent.nameToCount.entries());
        }
        else {
            this.symbolToName = new Map();
            this.nameToCount = new Map();
        }
    }
    /**
     * Resolve a rawName to a unique name within the scope of this resolver. When provided
     * with a symbol which has already been seen, return the same name
     * @param rawName
     * @param symbol
     */
    resolveUniqueName(rawName, symbol) {
        const name = symbol && this.symbolToName.get(symbol);
        if (name) {
            return name;
        }
        const nameCount = this.nameToCount.get(rawName) ?? 0;
        let uniqueName;
        if (nameCount === 0) {
            uniqueName = rawName;
        }
        else {
            uniqueName = `${rawName}${toSubScript(nameCount)}`;
        }
        this.nameToCount.set(rawName, nameCount + 1);
        if (symbol) {
            this.symbolToName.set(symbol, uniqueName);
        }
        return uniqueName;
    }
    createChild() {
        return new UniqueNameResolver(this);
    }
}

class AwstBuildContext {
    static get current() {
        const ctx = this.asyncStore.getStore();
        if (!ctx) {
            throw new Error('No context available!');
        }
        return ctx;
    }
    static asyncStore = new AsyncLocalStorage();
    static run(program, cb) {
        const ctx = AwstBuildContextImpl.forProgram(program);
        return AwstBuildContext.asyncStore.run(ctx, cb);
    }
    runInChildContext(cb) {
        const childCtx = this.createChildContext();
        const runDeferred = (action) => () => AwstBuildContext.asyncStore.run(childCtx, action);
        return AwstBuildContext.asyncStore.run(childCtx, () => cb(runDeferred));
    }
}
class AwstBuildContextImpl extends AwstBuildContext {
    program;
    constants;
    nameResolver;
    storageDeclarations;
    arc4MethodConfig;
    evaluationCtx = new EvaluationContext();
    switchLoopCtx = new SwitchLoopContext();
    typeResolver;
    typeChecker;
    #compilationSet;
    constructor(program, constants, nameResolver, storageDeclarations, arc4MethodConfig, compilationSet) {
        super();
        this.program = program;
        this.constants = constants;
        this.nameResolver = nameResolver;
        this.storageDeclarations = storageDeclarations;
        this.arc4MethodConfig = arc4MethodConfig;
        this.typeChecker = program.getTypeChecker();
        this.typeResolver = new TypeResolver(this.typeChecker, this.program.getCurrentDirectory());
        this.#compilationSet = compilationSet;
    }
    addArc4Config({ memberName, sourceLocation, contractReference, arc4MethodConfig, }) {
        const contractConfig = this.arc4MethodConfig.get(contractReference.id) ?? new Map();
        if (contractConfig.size === 0) {
            // Add to map if new
            this.arc4MethodConfig.set(contractReference.id, contractConfig);
        }
        if (contractConfig.has(memberName)) {
            logger.error(sourceLocation, `Duplicate declaration of member ${memberName} on ${contractReference}`);
        }
        contractConfig.set(memberName, arc4MethodConfig);
    }
    getArc4Config(contractType, memberName) {
        if (memberName) {
            for (const ct of [contractType, ...contractType.allBases()]) {
                if (ct.equals(baseContractType) || ct.equals(arc4BaseContractType))
                    continue;
                const contractMethods = this.arc4MethodConfig.get(ct.fullName);
                invariant(contractMethods, `${ct} has not been visited`);
                if (contractMethods.has(memberName)) {
                    return contractMethods.get(memberName);
                }
            }
            return undefined;
        }
        else {
            return Array.from([contractType, ...contractType.allBases()]
                .toReversed()
                .reduce((acc, ct) => {
                if (ct.equals(baseContractType) || ct.equals(arc4BaseContractType))
                    return acc;
                const contractMethods = this.arc4MethodConfig.get(ct.fullName);
                invariant(contractMethods, `${ct} has not been visited`);
                return new Map([...acc, ...contractMethods]);
            }, new Map())
                .values());
        }
    }
    static forProgram(program) {
        return new AwstBuildContextImpl(program, new ConstantStore(program), new UniqueNameResolver(), new Map(), new Map(), new CompilationSet());
    }
    addConstant(identifier, value) {
        this.constants.addConstant(identifier, value, this.getSourceLocation(identifier));
    }
    createChildContext() {
        return new AwstBuildContextImpl(this.program, this.constants, this.nameResolver.createChild(), this.storageDeclarations, this.arc4MethodConfig, this.#compilationSet);
    }
    resolveDestructuredParamName(node) {
        const symbol = node.symbol;
        invariant(symbol, 'Param node must have symbol');
        return this.nameResolver.resolveUniqueName('p', symbol);
    }
    generateDiscardedVarName() {
        return this.nameResolver.resolveUniqueName('_', undefined);
    }
    resolveVariableName(node) {
        const symbol = this.typeChecker.resolveName(node.text, node, ts.SymbolFlags.All, false);
        invariant(symbol, 'There must be a symbol for an identifier node');
        return this.nameResolver.resolveUniqueName(node.text, symbol);
    }
    getTypeParameters(node) {
        return this.typeResolver.resolveTypeParameters(node, this.getSourceLocation(node));
    }
    getPTypeForNode(node) {
        const sourceLocation = this.getSourceLocation(node);
        if (ts.isTypeNode(node)) {
            return this.typeResolver.resolveTypeNode(node, sourceLocation);
        }
        return this.typeResolver.resolve(node, sourceLocation);
    }
    getBuilderForNode(node) {
        const sourceLocation = this.getSourceLocation(node);
        const ptype = this.typeResolver.resolve(node, sourceLocation);
        if (ptype.singleton) {
            return typeRegistry.getSingletonEb(ptype, sourceLocation);
        }
        const constantValue = this.constants.tryResolveConstant(node);
        if (constantValue) {
            return typeRegistry.getInstanceEb(constantValue, ptype);
        }
        const variableName = this.resolveVariableName(node);
        return typeRegistry.getInstanceEb(nodeFactory.varExpression({
            sourceLocation,
            name: variableName,
            wtype: ptype.wtypeOrThrow,
        }), ptype);
    }
    getSourceLocation(node) {
        return SourceLocation.fromNode(node, this.program.getCurrentDirectory());
    }
    addStorageDeclaration(declaration) {
        const contractDeclarations = this.storageDeclarations.get(declaration.definedIn.fullName) ?? new Map();
        if (contractDeclarations.size === 0) {
            // Add to map if new
            this.storageDeclarations.set(declaration.definedIn.fullName, contractDeclarations);
        }
        if (contractDeclarations.has(declaration.memberName)) {
            logger.error(declaration.sourceLocation, `Duplicate declaration of member ${declaration.memberName} on ${declaration.definedIn}`);
        }
        contractDeclarations.set(declaration.memberName, declaration);
    }
    getStorageDeclaration(contractType, memberName) {
        const declaration = this.storageDeclarations.get(contractType.fullName)?.get(memberName);
        if (declaration)
            return declaration;
        for (const baseType of contractType.baseTypes) {
            const baseDeclaration = this.getStorageDeclaration(baseType, memberName);
            if (baseDeclaration)
                return baseDeclaration;
        }
        return undefined;
    }
    getStorageDefinitionsForContract(contractType) {
        const result = new Map();
        const seenContracts = new Set();
        for (const ct of [contractType, ...contractType.allBases()]) {
            if (seenContracts.has(ct.fullName))
                continue;
            seenContracts.add(ct.fullName);
            for (const [memberName, declaration] of this.storageDeclarations.get(ct.fullName) ?? []) {
                if (result.has(memberName)) {
                    logger.error(result.get(memberName)?.sourceLocation, `Redefinition of app storage member, original declared in ${declaration.sourceLocation}`);
                }
                result.set(memberName, declaration.definition);
            }
        }
        return Array.from(result.values());
    }
    addToCompilationSet(compilationTarget, contractOrSig) {
        if (this.#compilationSet.has(compilationTarget)) {
            logger.debug(undefined, `${compilationTarget.id} already exists in compilation set`);
            return;
        }
        this.#compilationSet.set(compilationTarget, contractOrSig);
    }
    get compilationSet() {
        return this.#compilationSet;
    }
}

const baseTxnFields = {
    sender: { field: TxnField.Sender, ptype: accountPType, comment: '32 byte address' },
    fee: { field: TxnField.Fee, ptype: uint64PType, comment: 'microalgos' },
    firstValid: { field: TxnField.FirstValid, ptype: uint64PType, comment: 'round number' },
    firstValidTime: {
        field: TxnField.FirstValidTime,
        ptype: uint64PType,
        comment: 'UNIX timestamp of block before txn.FirstValid. Fails if negative',
    },
    lastValid: { field: TxnField.LastValid, ptype: uint64PType, comment: 'round number' },
    note: { field: TxnField.Note, ptype: bytesPType, comment: 'Any data up to 1024 bytes' },
    lease: { field: TxnField.Lease, ptype: bytesPType, comment: '32 byte lease value' },
    typeBytes: { field: TxnField.Type, ptype: bytesPType, comment: 'Transaction type as bytes', computed: true },
    type: { field: TxnField.TypeEnum, ptype: transactionTypeType.memberType, comment: 'Transaction type', computed: true },
    groupIndex: {
        field: TxnField.GroupIndex,
        ptype: uint64PType,
        comment: ['Position of this transaction within an atomic group', 'A stand-alone transaction is implicitly element 0 in a group of 1'],
        computed: true,
    },
    txnId: { field: TxnField.TxID, ptype: bytesPType, comment: 'The computed ID for this transaction. 32 bytes.', computed: true },
    rekeyTo: { field: TxnField.RekeyTo, ptype: accountPType, comment: "32 byte Sender's new AuthAddr" },
};
const paymentTxnFields = {
    ...baseTxnFields,
    receiver: { field: TxnField.Receiver, ptype: accountPType, comment: '32 byte address' },
    amount: { field: TxnField.Amount, ptype: uint64PType, comment: 'microalgos' },
    closeRemainderTo: { field: TxnField.CloseRemainderTo, ptype: accountPType, comment: '32 byte address' },
};
const keyRegistrationTxnFields = {
    ...baseTxnFields,
    voteKey: { field: TxnField.VotePK, ptype: bytesPType, comment: '32 byte address' },
    selectionKey: { field: TxnField.SelectionPK, ptype: bytesPType, comment: '32 byte address' },
    voteFirst: { field: TxnField.VoteFirst, ptype: uint64PType, comment: 'The first round that the participation key is valid.' },
    voteLast: { field: TxnField.VoteLast, ptype: uint64PType, comment: 'The last round that the participation key is valid.' },
    voteKeyDilution: { field: TxnField.VoteKeyDilution, ptype: uint64PType, comment: 'Dilution for the 2-level participation key' },
    nonparticipation: { field: TxnField.Nonparticipation, ptype: boolPType, comment: 'Marks an account nonparticipating for rewards' },
    stateProofKey: { field: TxnField.StateProofPK, ptype: bytesPType, comment: '64 byte state proof public key' },
};
const assetConfigTxnFields = {
    ...baseTxnFields,
    configAsset: { field: TxnField.ConfigAsset, ptype: assetPType, comment: 'Asset ID in asset config transaction' },
    createdAsset: { field: TxnField.CreatedAssetID, ptype: assetPType, comment: 'The asset created by this transaction', computed: true },
    total: { field: TxnField.ConfigAssetTotal, ptype: uint64PType, comment: 'Total number of units of this asset created' },
    decimals: {
        field: TxnField.ConfigAssetDecimals,
        ptype: uint64PType,
        comment: 'Number of digits to display after the decimal place when displaying the asset',
    },
    defaultFrozen: {
        field: TxnField.ConfigAssetDefaultFrozen,
        ptype: boolPType,
        comment: "Whether the asset's slots are frozen by default or not, 0 or 1",
    },
    unitName: { field: TxnField.ConfigAssetUnitName, ptype: bytesPType, comment: 'Unit name of the asset' },
    assetName: { field: TxnField.ConfigAssetName, ptype: bytesPType, comment: 'The asset name' },
    url: { field: TxnField.ConfigAssetURL, ptype: bytesPType, comment: 'URL' },
    metadataHash: { field: TxnField.ConfigAssetMetadataHash, ptype: bytesPType, comment: '32 byte commitment to unspecified asset metadata' },
    manager: { field: TxnField.ConfigAssetManager, ptype: accountPType, comment: '32 byte address' },
    reserve: { field: TxnField.ConfigAssetReserve, ptype: accountPType, comment: '32 byte address' },
    freeze: { field: TxnField.ConfigAssetFreeze, ptype: accountPType, comment: '32 byte address' },
    clawback: { field: TxnField.ConfigAssetClawback, ptype: accountPType, comment: '32 byte address' },
};
const assetTransferTxnFields = {
    ...baseTxnFields,
    xferAsset: { field: TxnField.XferAsset, ptype: assetPType, comment: 'Asset ID' },
    assetAmount: { field: TxnField.AssetAmount, ptype: uint64PType, comment: "value in Asset's units" },
    assetSender: {
        field: TxnField.AssetSender,
        ptype: accountPType,
        comment: "32 byte address. Source of assets if Sender is the Asset's Clawback address.",
    },
    assetReceiver: { field: TxnField.AssetReceiver, ptype: accountPType, comment: '32 byte address' },
    assetCloseTo: { field: TxnField.AssetCloseTo, ptype: accountPType, comment: '32 byte address' },
};
const assetFreezeTxnFields = {
    ...baseTxnFields,
    freezeAsset: { field: TxnField.FreezeAsset, ptype: assetPType, comment: 'Asset ID being frozen or un-frozen' },
    freezeAccount: {
        field: TxnField.FreezeAssetAccount,
        ptype: accountPType,
        comment: '32 byte address of the account whose asset slot is being frozen or un-frozen',
    },
    frozen: { field: TxnField.FreezeAssetFrozen, ptype: boolPType, comment: 'The new frozen value' },
};
const applicationCallTxnFields = {
    ...baseTxnFields,
    appId: { field: TxnField.ApplicationID, ptype: applicationPType, comment: 'ApplicationID from ApplicationCall transaction' },
    onCompletion: {
        field: TxnField.OnCompletion,
        ptype: onCompleteActionType.memberType,
        comment: 'ApplicationCall transaction on completion action',
    },
    numAppArgs: { field: TxnField.NumAppArgs, ptype: uint64PType, comment: 'Number of ApplicationArgs', computed: true },
    numAccounts: { field: TxnField.NumAccounts, ptype: uint64PType, comment: 'Number of ApplicationArgs', computed: true },
    approvalProgram: {
        field: TxnField.ApprovalProgramPages,
        ptype: bytesPType,
        comment: 'The first page of the Approval program',
        computed: true,
    },
    clearStateProgram: {
        field: TxnField.ClearStateProgramPages,
        ptype: bytesPType,
        comment: 'The first page of the Clear State program',
        computed: true,
    },
    numAssets: { field: TxnField.NumAssets, ptype: uint64PType, comment: 'Number of Assets', computed: true },
    numApps: { field: TxnField.NumApplications, ptype: uint64PType, comment: 'Number of Applications', computed: true },
    globalNumUint: {
        field: TxnField.GlobalNumUint,
        ptype: uint64PType,
        comment: 'Number of global state integers this application makes use of.',
    },
    globalNumBytes: {
        field: TxnField.GlobalNumByteSlice,
        ptype: uint64PType,
        comment: 'Number of global state byteslices this application makes use of.',
    },
    localNumUint: {
        field: TxnField.LocalNumUint,
        ptype: uint64PType,
        comment: 'Number of local state integers this application makes use of.',
    },
    localNumBytes: {
        field: TxnField.LocalNumByteSlice,
        ptype: uint64PType,
        comment: 'Number of local state byteslices this application makes use of.',
    },
    extraProgramPages: {
        field: TxnField.ExtraProgramPages,
        ptype: uint64PType,
        comment: "Number of additional pages for each of the application's approval and clear state program",
    },
    lastLog: {
        field: TxnField.LastLog,
        ptype: bytesPType,
        comment: 'The last message emitted. Empty bytes if none were emitted. App mode only',
        computed: true,
    },
    logs: {
        field: TxnField.Logs,
        ptype: bytesPType,
        comment: ['Read application logs', '@param index Index of the log to get'],
        indexable: true,
        computed: true,
    },
    numApprovalProgramPages: {
        field: TxnField.NumApprovalProgramPages,
        ptype: uint64PType,
        comment: 'Number of Approval Program pages',
        computed: true,
    },
    approvalProgramPages: {
        field: TxnField.ApprovalProgramPages,
        ptype: bytesPType,
        comment: ['All approval program pages', '@param index Index of the page to get'],
        indexable: true,
        arrayPromote: true,
    },
    numClearStateProgramPages: {
        field: TxnField.NumClearStateProgramPages,
        ptype: uint64PType,
        comment: 'Number of Clear State Program pages',
        computed: true,
    },
    clearStateProgramPages: {
        field: TxnField.ClearStateProgramPages,
        ptype: bytesPType,
        comment: ['All clear state program pages', '@param index Index of the page to get'],
        indexable: true,
        arrayPromote: true,
    },
    appArgs: {
        field: TxnField.ApplicationArgs,
        ptype: bytesPType,
        comment: ['Arguments passed to the application in the ApplicationCall transaction', '@param index Index of the arg to get'],
        indexable: true,
    },
    accounts: {
        field: TxnField.Accounts,
        ptype: accountPType,
        comment: ['Accounts listed in the ApplicationCall transaction', '@param index Index of the account to get'],
        indexable: true,
    },
    assets: {
        field: TxnField.Assets,
        ptype: assetPType,
        comment: ['Foreign Assets listed in the ApplicationCall transaction', '@param index Index of the asset to get'],
        indexable: true,
    },
    apps: {
        field: TxnField.Applications,
        ptype: applicationPType,
        comment: ['Foreign Apps listed in the ApplicationCall transaction', '@param index Index of the application to get'],
        indexable: true,
    },
    createdApp: {
        field: TxnField.CreatedApplicationID,
        ptype: applicationPType,
        comment: 'The id of the created application',
        computed: true,
    },
    /**
     * Number of logs
     */
    numLogs: { field: TxnField.NumLogs, ptype: uint64PType, comment: 'Number of logs', computed: true },
};
const anyTxnFields = {
    ...paymentTxnFields,
    ...keyRegistrationTxnFields,
    ...assetConfigTxnFields,
    ...assetTransferTxnFields,
    ...assetFreezeTxnFields,
    ...applicationCallTxnFields,
};
const txnKindToFields = {
    [TransactionKind.pay]: paymentTxnFields,
    [TransactionKind.keyreg]: keyRegistrationTxnFields,
    [TransactionKind.acfg]: assetConfigTxnFields,
    [TransactionKind.axfer]: assetTransferTxnFields,
    [TransactionKind.afrz]: assetFreezeTxnFields,
    [TransactionKind.appl]: applicationCallTxnFields,
};
const txnFieldName = new Proxy({}, {
    get(_, prop) {
        if (prop in anyTxnFields)
            return prop;
        return Reflect.get(_, prop);
    },
});

class CompileFunctionBuilder extends FunctionBuilder {
    ptype = compileFunctionType;
    call(args, typeArgs, sourceLocation) {
        const { args: [contractOrSig, options], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required(ContractClassPType, LogicSigPType), a.optional()],
        });
        const templateVarOptions = parseTemplateVars(options);
        if (contractOrSig.ptype instanceof ContractClassPType) {
            return instanceEb(nodeFactory.compiledContract({
                contract: ContractReference.fromPType(contractOrSig.ptype),
                allocationOverrides: parseAllocationOverrides(options),
                ...templateVarOptions,
                wtype: compiledContractType.wtype,
                sourceLocation,
            }), compiledContractType);
        }
        else {
            invariant(contractOrSig.ptype instanceof LogicSigPType, 'ptype must be LogicSigPType');
            return instanceEb(nodeFactory.compiledLogicSig({
                logicSig: LogicSigReference.fromPType(contractOrSig.ptype),
                ...templateVarOptions,
                wtype: compiledLogicSigType.wtype,
                sourceLocation,
            }), compiledLogicSigType);
        }
    }
}
const optionsNames = {
    prefix: 'templateVarsPrefix',
    templateVars: 'templateVars',
};
function parseTemplateVars(options) {
    const prefix = options?.hasProperty(optionsNames.prefix)
        ? requireStringConstant(options.memberAccess(optionsNames.prefix, options.sourceLocation)).value
        : null;
    const templateVariables = new Map();
    if (options?.hasProperty(optionsNames.templateVars)) {
        const templateVars = requireInstanceBuilder(options.memberAccess(optionsNames.templateVars, options.sourceLocation));
        codeInvariant(templateVars.ptype instanceof ObjectPType, `${optionsNames.templateVars} must be an object type`, templateVars.sourceLocation);
        for (const [varName] of templateVars.ptype.orderedProperties()) {
            templateVariables.set(varName, requireInstanceBuilder(templateVars.memberAccess(varName, templateVars.sourceLocation)).resolve());
        }
    }
    return {
        prefix,
        templateVariables,
    };
}
const allocationOverrides = {
    extraProgramPages: [TxnField.ExtraProgramPages, uint64PType],
    globalUints: [TxnField.ExtraProgramPages, uint64PType],
    globalBytes: [TxnField.ExtraProgramPages, uint64PType],
    localUints: [TxnField.ExtraProgramPages, uint64PType],
    localBytes: [TxnField.ExtraProgramPages, uint64PType],
};
function parseAllocationOverrides(options) {
    const overrides = new Map();
    if (options) {
        for (const [property, [field, fieldType]] of Object.entries(allocationOverrides)) {
            if (options.hasProperty(property)) {
                overrides.set(field, requireBuilderOfType(options.memberAccess(property, options.sourceLocation), fieldType).resolve());
            }
        }
    }
    return overrides;
}

class SubroutineExpressionBuilder extends FunctionBuilder {
    ptype;
    target;
    constructor(sourceLocation, ptype, target) {
        super(sourceLocation);
        this.ptype = ptype;
        this.target = target;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: mappedArgs } = parseFunctionArgs({
            args,
            typeArgs,
            funcName: this.ptype.name,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: (a) => this.ptype.parameters.map(([_, ptype]) => a.required(ptype)),
        });
        return typeRegistry.getInstanceEb(nodeFactory.subroutineCallExpression({
            target: this.target,
            args: mappedArgs.map((a) => nodeFactory.callArg({ name: null, value: a.resolve() })),
            sourceLocation: sourceLocation,
            wtype: this.ptype.returnType.wtypeOrThrow,
        }), this.ptype.returnType);
    }
}
/**
 * Invoke a contract method on the current contract (ie. this.someMethod())
 */
class ContractMethodExpressionBuilder extends SubroutineExpressionBuilder {
    contractType;
    constructor(sourceLocation, ptype, contractType) {
        super(sourceLocation, ptype, nodeFactory.contractMethodTarget({
            cref: ContractReference.fromPType(contractType),
            memberName: ptype.name,
        }));
        this.contractType = contractType;
    }
    getMethodSelector(sourceLocation = this.sourceLocation) {
        const methodTarget = this.target;
        const arc4Config = AwstBuildContext.current.getArc4Config(this.contractType, methodTarget.memberName);
        codeInvariant(arc4Config instanceof ARC4ABIMethodConfig, `${methodTarget.memberName} is not an ABI method`, this.sourceLocation);
        return buildArc4MethodConstant(this.ptype, arc4Config, sourceLocation);
    }
}
/**
 * Invoke a contract method on the super contract (ie. super.someMethod())
 */
class BaseContractMethodExpressionBuilder extends SubroutineExpressionBuilder {
    constructor(sourceLocation, ptype) {
        super(sourceLocation, ptype, nodeFactory.instanceSuperMethodTarget({
            memberName: ptype.name,
        }));
    }
}
/**
 * Invoke a free subroutine (ie. someMethod())
 */
class FreeSubroutineExpressionBuilder extends SubroutineExpressionBuilder {
    constructor(sourceLocation, ptype) {
        if (!(ptype instanceof FunctionPType)) {
            throw new InternalError(`Invalid ptype`);
        }
        super(sourceLocation, ptype, nodeFactory.subroutineID({
            target: ptype.fullName,
        }));
    }
}

class InnerTransactionExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof InnerTransactionPType, 'ptype must be InnerTransactionPType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        const txnKind = this.ptype.kind;
        const fields = txnKind === undefined ? anyTxnFields : txnKindToFields[txnKind];
        if (name in fields) {
            const { field, ptype: returnType } = fields[name];
            const data = TxnFields[field];
            if (data.numValues === 1) {
                return instanceEb(nodeFactory.innerTransactionField({
                    sourceLocation,
                    itxn: this.resolve(),
                    arrayIndex: null,
                    field,
                    wtype: data.wtype,
                }), returnType);
            }
            else {
                return new IndexedTransactionFieldFunctionBuilder$1(this._expr, {
                    txnData: data,
                    returnType,
                    memberName: name,
                    field,
                });
            }
        }
        return super.memberAccess(name, sourceLocation);
    }
}
let IndexedTransactionFieldFunctionBuilder$1 = class IndexedTransactionFieldFunctionBuilder extends FunctionBuilder {
    gtxn;
    config;
    constructor(gtxn, config) {
        super(gtxn.sourceLocation);
        this.gtxn = gtxn;
        this.config = config;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [index], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: this.config.memberName,
            argSpec: (a) => [a.required(uint64PType)],
        });
        return instanceEb(nodeFactory.innerTransactionField({
            sourceLocation,
            itxn: this.gtxn,
            arrayIndex: index.resolve(),
            field: this.config.field,
            wtype: this.config.txnData.wtype,
        }), this.config.returnType);
    }
};

class ItxnParamsFactoryFunctionBuilder extends FunctionBuilder {
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof TransactionFunctionType, 'ptype must be TransactionFunctionType');
        this.ptype = ptype;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [initialFields], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            funcName: this.ptype.name,
            argSpec: (a) => [a.required()],
        });
        const mappedFields = new Map();
        // Set default fee to 0 (transaction will be paid for from transaction group budget, rather than from the application balance)
        mappedFields.set(TxnField.Fee, nodeFactory.uInt64Constant({ value: 0n, sourceLocation }));
        if (this.ptype.kind)
            mappedFields.set(TxnField.TypeEnum, nodeFactory.uInt64Constant({ value: BigInt(this.ptype.kind), sourceLocation }));
        mapTransactionFields(mappedFields, initialFields, this.ptype.kind, sourceLocation);
        invariant(this.ptype.kind !== undefined, 'Cannot have untyped itxn params factory', sourceLocation);
        const fieldsType = getItxnParamsType(this.ptype.kind);
        return new ItxnParamsExpressionBuilder(nodeFactory.createInnerTransaction({
            fields: mappedFields,
            sourceLocation,
            wtype: fieldsType.wtype,
        }), fieldsType);
    }
}
function mapTransactionFields(mappedFields, fields, kind, sourceLocation, ignoreProps) {
    codeInvariant(fields.ptype instanceof ObjectPType, 'fields argument must be an object type');
    const validFields = kind !== undefined ? txnKindToFields[kind] : anyTxnFields;
    for (const [prop] of fields.ptype.orderedProperties()) {
        if (ignoreProps?.has(prop))
            continue;
        if (prop in validFields) {
            const { field: txnField, ptype: fieldType } = validFields[prop];
            const txnFieldData = TxnFields[txnField];
            const propValue = fields.memberAccess(prop, sourceLocation);
            if (txnField === TxnField.ApplicationArgs) {
                codeInvariant(isStaticallyIterable(propValue), 'Unsupported expression for appArgs', propValue.sourceLocation);
                mappedFields.set(txnField, nodeFactory.tupleExpression({
                    items: propValue[StaticIterator]().map((i) => i.toBytes(propValue.sourceLocation)),
                    sourceLocation: propValue.sourceLocation,
                }));
            }
            else if (txnFieldData.numValues > 1) {
                if (isStaticallyIterable(propValue)) {
                    mappedFields.set(txnField, nodeFactory.tupleExpression({
                        items: propValue[StaticIterator]().map((i) => resolveCompatExpression(i, fieldType)),
                        sourceLocation: propValue.sourceLocation,
                    }));
                }
                else if (txnFieldData.arrayPromote) {
                    mappedFields.set(txnField, nodeFactory.tupleExpression({
                        items: [resolveCompatExpression(propValue, fieldType)],
                        sourceLocation: propValue.sourceLocation,
                    }));
                }
                else {
                    logger.error(propValue.sourceLocation, `Unsupported expression for ${prop}`);
                }
            }
            else {
                mappedFields.set(txnField, resolveCompatExpression(propValue, fieldType));
            }
        }
        else {
            logger.warn(sourceLocation, `Ignoring additional property: ${prop}`);
        }
    }
}
class InnerTxnFieldsMethodBuilder extends FunctionBuilder {
    builder;
    constructor(builder, sourceLocation) {
        super(sourceLocation);
        this.builder = builder;
    }
}
class SubmitInnerTxnMethodBuilder extends InnerTxnFieldsMethodBuilder {
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            funcName: 'submit',
            argSpec: () => [],
        });
        invariant(this.builder.ptype.kind !== undefined, 'Cannot have untyped itxn params type', sourceLocation);
        const transactionPType = getInnerTransactionType(this.builder.ptype.kind);
        return new InnerTransactionExpressionBuilder(nodeFactory.submitInnerTransaction({
            itxns: [this.builder.resolve()],
            sourceLocation,
        }), transactionPType);
    }
}
class SubmitItxnGroupFunctionBuilder extends FunctionBuilder {
    ptype = submitGroupItxnFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: itxnParams } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required(ItxnParamsPType), ...args.slice(1).map((_) => a.required(ItxnParamsPType))],
        });
        const resultType = new TuplePType({
            items: itxnParams.map((p, i) => {
                codeInvariant(p.ptype instanceof ItxnParamsPType, `Argument ${i} must be an itxn params type`, p.sourceLocation);
                invariant(p.ptype.kind !== undefined, 'Cannot have untyped itxn params type', sourceLocation);
                return getInnerTransactionType(p.ptype.kind);
            }),
        });
        return instanceEb(nodeFactory.submitInnerTransaction({
            itxns: itxnParams.map((p) => p.resolve()),
            sourceLocation,
        }), resultType);
    }
}
class SetInnerTxnMethodBuilder extends InnerTxnFieldsMethodBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [updatedFields], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            funcName: 'set',
            argSpec: (a) => [a.required()],
        });
        const mappedFields = new Map();
        const fieldsType = this.builder.ptype;
        mapTransactionFields(mappedFields, updatedFields, fieldsType.kind, sourceLocation);
        return new ItxnParamsExpressionBuilder(nodeFactory.updateInnerTransaction({
            itxn: this.builder.resolve(),
            fields: mappedFields,
            sourceLocation,
            wtype: fieldsType.wtype,
        }), fieldsType);
    }
}
class CopyInnerTxnMethodBuilder extends InnerTxnFieldsMethodBuilder {
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            funcName: 'copy',
            argSpec: () => [],
        });
        return new ItxnParamsExpressionBuilder(nodeFactory.copy({
            value: this.builder.resolve(),
            sourceLocation,
        }), this.builder.ptype);
    }
}
class ItxnParamsExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof ItxnParamsPType, 'ptype must be InnerTransactionFieldsPType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'submit':
                return new SubmitInnerTxnMethodBuilder(this, sourceLocation);
            case 'set':
                return new SetInnerTxnMethodBuilder(this, sourceLocation);
            case 'copy':
                return new CopyInnerTxnMethodBuilder(this, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
}

class InterpretAsArc4FunctionBuilder extends FunctionBuilder {
    ptype = interpretAsArc4Function;
    call(args, typeArgs, sourceLocation) {
        const { ptypes: [ptype], args: [theBytes, prefixType], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required(bytesPType), a.optional(stringPType)],
            callLocation: sourceLocation,
        });
        codeInvariant(ptype instanceof ARC4EncodedType, 'Generic type must be an ARC4 encoded type');
        const prefixBytes = getPrefixValue(prefixType);
        return instanceEb(nodeFactory.reinterpretCast({
            expr: validatePrefix(theBytes, prefixBytes, sourceLocation),
            wtype: ptype.wtype,
            sourceLocation,
        }), ptype);
    }
}
class EncodeArc4FunctionBuilder extends FunctionBuilder {
    ptype = encodeArc4Function;
    call(args, typeArgs, sourceLocation) {
        const { args: [valueToEncode], ptypes: [valueType], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required()],
            callLocation: sourceLocation,
        });
        if (valueType instanceof ARC4EncodedType) {
            // Already encoded, just reinterpret as bytes
            return instanceEb(nodeFactory.reinterpretCast({
                expr: valueToEncode.resolve(),
                wtype: wtypes.bytesWType,
                sourceLocation,
            }), bytesPType);
        }
        const encodedType = ptypeToArc4EncodedType(valueType, sourceLocation);
        return instanceEb(nodeFactory.reinterpretCast({
            expr: nodeFactory.aRC4Encode({
                value: valueToEncode.resolveToPType(valueType).resolve(),
                wtype: encodedType.wtype,
                sourceLocation,
            }),
            sourceLocation,
            wtype: bytesPType.wtype,
        }), bytesPType);
    }
}
class DecodeArc4FunctionBuilder extends FunctionBuilder {
    ptype = decodeArc4Function;
    call(args, typeArgs, sourceLocation) {
        const { ptypes: [ptype], args: [theBytes, prefixType], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required(bytesPType), a.optional(stringPType)],
            callLocation: sourceLocation,
        });
        codeInvariant(!(ptype instanceof ARC4EncodedType), `Cannot decode to ${ptype} as it is an ARC4 type. Use \`interpretAsArc4<${ptype}>\` instead`, sourceLocation);
        codeInvariant(isArc4EncodableType(ptype), `Cannot determine ARC4 encoding for ${ptype}`, sourceLocation);
        const arc4Encoded = ptypeToArc4EncodedType(ptype, sourceLocation);
        const prefixBytes = getPrefixValue(prefixType);
        return instanceEb(nodeFactory.aRC4Decode({
            value: nodeFactory.reinterpretCast({
                expr: validatePrefix(theBytes, prefixBytes, sourceLocation),
                sourceLocation,
                wtype: arc4Encoded.wtype,
            }),
            wtype: ptype.wtypeOrThrow,
            sourceLocation,
        }), ptype);
    }
}
function validatePrefix(base, expectedPrefix, sourceLocation) {
    if (expectedPrefix === undefined)
        return base.resolve();
    const baseSingle = base.singleEvaluation().resolve();
    const baseNoPrefix = nodeFactory.intrinsicCall({
        opCode: 'extract',
        immediates: [4n, 0n],
        wtype: bytesPType.wtype,
        stackArgs: [baseSingle],
        sourceLocation,
    });
    const observedPrefix = nodeFactory.intrinsicCall({
        opCode: 'extract',
        immediates: [0n, 4n],
        wtype: bytesPType.wtype,
        stackArgs: [baseSingle],
        sourceLocation,
    });
    const prefixIsValid = nodeFactory.bytesComparisonExpression({
        operator: EqualityComparison.eq,
        lhs: observedPrefix,
        rhs: expectedPrefix,
        sourceLocation,
    });
    return nodeFactory.checkedMaybe({
        expr: nodeFactory.tupleExpression({ items: [baseNoPrefix, prefixIsValid], sourceLocation }),
        comment: 'Bytes has valid prefix',
    });
}
function getPrefixValue(arg) {
    if (arg === undefined)
        return undefined;
    const value = requireStringConstant(arg).value;
    switch (value) {
        case 'log':
            return nodeFactory.bytesConstant({ value: hexToUint8Array(Constants.algo.arc4.logPrefixHex), sourceLocation: arg.sourceLocation });
        case 'none':
            return undefined;
        default:
            logger.error(arg.sourceLocation, `Expected literal string: 'none' | 'log'`);
    }
}
class MethodSelectorFunctionBuilder extends FunctionBuilder {
    ptype = methodSelectorFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [methodSignature], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [a.passthrough()],
        });
        if (methodSignature instanceof SubroutineExpressionBuilder) {
            codeInvariant(methodSignature instanceof ContractMethodExpressionBuilder, `Expected contract instance method, found ${methodSignature.typeDescription}`);
            return instanceEb(methodSignature.getMethodSelector(sourceLocation), bytesPType);
        }
        else {
            if (methodSignature === undefined) {
                throw new CodeError(`${this.typeDescription} expects exactly 1 argument that is either a string literal, or a contract function reference`, { sourceLocation });
            }
            return instanceEb(nodeFactory.methodConstant({
                value: requireStringConstant(methodSignature).value,
                wtype: wtypes.bytesWType,
                sourceLocation,
            }), bytesPType);
        }
    }
}
class Arc4EncodedLengthFunctionBuilder extends FunctionBuilder {
    ptype = arc4EncodedLengthFunction;
    call(args, typeArgs, sourceLocation) {
        const { ptypes: [typeToEncode], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            funcName: this.typeDescription,
            argSpec: (a) => [],
            callLocation: sourceLocation,
        });
        const arc4Type = ptypeToArc4EncodedType(typeToEncode, sourceLocation);
        codeInvariant(arc4Type.fixedByteSize !== null, `Target type must encode to a fixed size. ${typeToEncode} encodes with a variable length`, sourceLocation);
        return instanceEb(nodeFactory.uInt64Constant({
            value: arc4Type.fixedByteSize,
            sourceLocation,
        }), uint64PType);
    }
}

class AbiCallFunctionBuilder extends FunctionBuilder {
    ptype = abiCallFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [functionRef, fields], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 2,
            argSpec: (a) => [a.passthrough(), a.required()],
            callLocation: sourceLocation,
            funcName: this.typeDescription,
        });
        invariant(functionRef instanceof ContractMethodExpressionBuilder, `Arg 0 of ${this.typeDescription} should be an arc4 contract method`);
        const { target: { memberName }, contractType, ptype: functionType, } = functionRef;
        const arc4Config = AwstBuildContext.current.getArc4Config(contractType, memberName);
        codeInvariant(arc4Config instanceof ARC4ABIMethodConfig, `${memberName} is not an ABI method`, functionRef.sourceLocation);
        const methodSelector = buildArc4MethodConstant(functionType, arc4Config, sourceLocation);
        const itxnResult = makeApplicationCall({
            fields,
            methodSelector: methodSelector,
            functionType,
            arc4Config,
            sourceLocation,
        });
        return formatApplicationCallResponse({ itxnResult, functionType, sourceLocation });
    }
}
class CompileArc4FunctionBuilder extends CompileFunctionBuilder {
    ptype = compileArc4Function;
    call(args, typeArgs, sourceLocation) {
        const result = requireInstanceBuilder(super.call(args, [], sourceLocation)).resolve();
        codeInvariant(result instanceof CompiledContract, `${this.typeDescription} expects a contract type`, sourceLocation);
        const proxyType = ContractProxyGeneric.parameterise([...typeArgs]);
        return new ContractProxyExpressionBuilder(result, proxyType);
    }
}
class ContractProxyExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof ContractProxyType, 'ptype must be instance of ContractProxyType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'call':
                return new ContractProxyCallBuilder(this, sourceLocation);
            case 'bareCreate':
                return new ContractProxyBareCreateFunctionBuilder(this, sourceLocation);
        }
        if (name in compiledContractType.properties) {
            return instanceEb(nodeFactory.fieldExpression({
                base: this._expr,
                name,
                wtype: compiledContractType.properties[name].wtypeOrThrow,
                sourceLocation,
            }), compiledContractType.properties[name]);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class ContractProxyBareCreateFunctionBuilder extends FunctionBuilder {
    proxy;
    constructor(proxy, sourceLocation) {
        super(sourceLocation);
        this.proxy = proxy;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [fields], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'bareCreate',
            argSpec: (a) => [a.optional()],
            callLocation: sourceLocation,
        });
        const arc4Configs = AwstBuildContext.current.getArc4Config(this.proxy.ptype.contractType);
        const createConfigs = arc4Configs.filter((c) => c.create !== ARC4CreateOption.disallow);
        const bareCreate = createConfigs.find((c) => c instanceof ARC4BareMethodConfig);
        if (createConfigs.length && !bareCreate) {
            logger.error(sourceLocation, `${this.proxy.ptype.contractType} has no bare create method`);
        }
        const itxnResult = makeApplicationCall({
            arc4Config: bareCreate ??
                new ARC4BareMethodConfig({
                    allowedCompletionTypes: [OnCompletionAction.NoOp],
                    create: ARC4CreateOption.require,
                    sourceLocation: SourceLocation.None,
                }),
            sourceLocation,
            methodSelector: null,
            functionType: null,
            fields,
            proxy: this.proxy,
        });
        return instanceEb(itxnResult, applicationItxnType);
    }
}
class ContractProxyCallBuilder extends NodeBuilder {
    proxy;
    ptype = undefined;
    constructor(proxy, sourceLocation) {
        super(sourceLocation);
        this.proxy = proxy;
    }
    memberAccess(name, sourceLocation) {
        const maybeFunction = this.proxy.ptype.contractType.methods[name];
        if (maybeFunction) {
            return new ContractProxyCallFunctionBuilder(this.proxy, maybeFunction, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class ContractProxyCallFunctionBuilder extends FunctionBuilder {
    proxy;
    functionType;
    constructor(proxy, functionType, sourceLocation) {
        super(sourceLocation);
        this.proxy = proxy;
        this.functionType = functionType;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [fields], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: this.functionType.name,
            argSpec: (a) => [a.optional()],
            callLocation: sourceLocation,
        });
        const arc4Config = AwstBuildContext.current.getArc4Config(this.proxy.ptype.contractType, this.functionType.name);
        codeInvariant(arc4Config, `${this.functionType.name} is not callable`);
        const methodSelector = arc4Config instanceof ARC4ABIMethodConfig ? buildArc4MethodConstant(this.functionType, arc4Config, sourceLocation) : null;
        return formatApplicationCallResponse({
            itxnResult: makeApplicationCall({
                proxy: this.proxy,
                arc4Config: arc4Config,
                functionType: this.functionType,
                methodSelector,
                fields,
                sourceLocation,
            }),
            functionType: this.functionType,
            sourceLocation,
        });
    }
}
const typedAppCallIgnoredFields = new Set(['args', 'appArgs']);
function makeApplicationCall({ sourceLocation, fields, arc4Config, proxy, methodSelector, functionType, }) {
    const itxnGroup = [];
    const mappedFields = new Map([
        // Set default fee to 0 (transaction will be paid for from transaction group budget, rather than from the application balance)
        [TxnField.Fee, nodeFactory.uInt64Constant({ value: 0n, sourceLocation })],
        [TxnField.TypeEnum, nodeFactory.uInt64Constant({ value: 6n, sourceLocation, tealAlias: 'appl' })],
    ]);
    // Map any explicitly provided fields
    if (fields) {
        mapTransactionFields(mappedFields, fields, TransactionKind.appl, sourceLocation, typedAppCallIgnoredFields);
    }
    // Add implicit fields
    if (proxy) {
        // Create a copy of the fields
        const implicitFields = getImplicitFields({ proxy, mappedFields, sourceLocation, methodConfig: arc4Config });
        // Only add fields that aren't explicitly provided
        for (const [key, expr] of implicitFields) {
            if (!mappedFields.has(key)) {
                mappedFields.set(key, expr);
            }
        }
    }
    // Add app args by merging provided args with method selector
    if (arc4Config instanceof ARC4ABIMethodConfig) {
        invariant(methodSelector && functionType, 'methodSelector and functionType both required for abi calls');
        const { itxns, appArgs, foreignApps, foreignAssets, foreignAccounts } = parseAppArgs({
            fields,
            methodSelector,
            sourceLocation,
            functionType,
        });
        mappedFields.set(TxnField.ApplicationArgs, appArgs);
        if (foreignApps)
            mappedFields.set(TxnField.Applications, foreignApps);
        if (foreignAssets)
            mappedFields.set(TxnField.Assets, foreignAssets);
        if (foreignAccounts)
            mappedFields.set(TxnField.Accounts, foreignAccounts);
        itxnGroup.push(...itxns);
    }
    // Build itxn and submit
    itxnGroup.push(nodeFactory.createInnerTransaction({
        fields: mappedFields,
        sourceLocation,
        wtype: applicationCallItxnParamsType.wtype,
    }));
    const txnGroup = nodeFactory.submitInnerTransaction({
        itxns: itxnGroup,
        sourceLocation,
    });
    return txnGroup.itxns.length === 1
        ? txnGroup
        : nodeFactory.tupleItemExpression({
            base: txnGroup,
            index: BigInt(txnGroup.itxns.length - 1),
            sourceLocation,
        });
}
function formatApplicationCallResponse({ itxnResult, functionType, sourceLocation, }) {
    if (functionType.returnType.equals(voidPType)) {
        const responseType = TypedApplicationCallResponseGeneric.parameterise([voidPType]);
        return instanceEb(nodeFactory.tupleExpression({
            items: [itxnResult],
            sourceLocation,
            wtype: responseType.wtype,
        }), responseType);
    }
    // Extract return value and return
    const itxnSingle = nodeFactory.singleEvaluation({ source: itxnResult });
    const responseType = TypedApplicationCallResponseGeneric.parameterise([functionType.returnType]);
    const returnValue = getReturnValueExpr(itxnSingle, functionType.returnType, sourceLocation);
    return instanceEb(nodeFactory.tupleExpression({
        items: [itxnSingle, returnValue],
        sourceLocation,
        wtype: responseType.wtype,
    }), responseType);
}
function getImplicitFields({ proxy, methodConfig, mappedFields, sourceLocation, }) {
    const implicitFields = new Map();
    const hasAppId = mappedFields.has(TxnField.ApplicationID);
    const oca = getOca(mappedFields.get(TxnField.OnCompletion), methodConfig.allowedCompletionTypes, sourceLocation);
    implicitFields.set(TxnField.OnCompletion, nodeFactory.uInt64Constant({
        value: BigInt(oca),
        sourceLocation,
    }));
    if (hasAppId) {
        codeInvariant(methodConfig.create !== ARC4CreateOption.require, `Cannot specify ${txnFieldName.appId} as target method is only callable in a create scenario`, mappedFields.get(TxnField.ApplicationID)?.sourceLocation);
    }
    else {
        codeInvariant(methodConfig.create !== ARC4CreateOption.disallow, `${txnFieldName.appId} must be specified to call this method`, sourceLocation);
    }
    // Update or possible create
    if (oca === OnCompletionAction.UpdateApplication || !hasAppId) {
        implicitFields.set(TxnField.ApprovalProgramPages, requireInstanceBuilder(proxy.memberAccess('approvalProgram', sourceLocation)).resolve());
        implicitFields.set(TxnField.ClearStateProgramPages, requireInstanceBuilder(proxy.memberAccess('clearStateProgram', sourceLocation)).resolve());
        if (!hasAppId) {
            implicitFields.set(TxnField.GlobalNumUint, requireInstanceBuilder(proxy.memberAccess('globalUints', sourceLocation)).resolve());
            implicitFields.set(TxnField.GlobalNumByteSlice, requireInstanceBuilder(proxy.memberAccess('globalBytes', sourceLocation)).resolve());
            implicitFields.set(TxnField.LocalNumByteSlice, requireInstanceBuilder(proxy.memberAccess('localBytes', sourceLocation)).resolve());
            implicitFields.set(TxnField.LocalNumUint, requireInstanceBuilder(proxy.memberAccess('localUints', sourceLocation)).resolve());
            implicitFields.set(TxnField.ExtraProgramPages, requireInstanceBuilder(proxy.memberAccess('extraProgramPages', sourceLocation)).resolve());
        }
    }
    return implicitFields;
}
function getOca(ocaField, allowedCompletionTypes, sourceLocation) {
    if (ocaField) {
        codeInvariant(ocaField instanceof IntegerConstant, `${txnFieldName.onCompletion} should be a compile time constant`, ocaField.sourceLocation);
        const oca = enumFromValue(Number(ocaField.value), OnCompletionAction);
        codeInvariant(allowedCompletionTypes.includes(oca), `${txnFieldName.onCompletion} should be one of ${allowedCompletionTypes}`);
        return oca;
    }
    else {
        const oca = allowedCompletionTypes[0];
        if (allowedCompletionTypes.length > 1) {
            logger.warn(sourceLocation, `Method allows multiple on complete actions, defaulting to ${oca}`);
        }
        return oca;
    }
}
function parseAppArgs({ fields, methodSelector, functionType, sourceLocation, }) {
    const results = {
        itxns: new Array(),
        foreignApps: new Array(),
        foreignAccounts: new Array(),
        foreignAssets: new Array(),
    };
    const appArgsBuilder = fields && fields.hasProperty('args') && fields.memberAccess('args', sourceLocation);
    const appArgs = [methodSelector];
    if (appArgsBuilder) {
        codeInvariant(isStaticallyIterable(appArgsBuilder), 'Unsupported expression for args', appArgsBuilder.sourceLocation);
        appArgs.push(...appArgsBuilder[StaticIterator]().flatMap((arg, index) => {
            const [paramName, paramType] = functionType.parameters[index];
            if (paramType instanceof GroupTransactionPType) {
                codeInvariant(arg.ptype instanceof ItxnParamsPType, `${paramName} should be an ItxnParams object`);
                if (paramType.kind !== undefined) {
                    codeInvariant(arg.ptype.kind === paramType.kind, `${paramName} should be an ItxnParams object for a ${TransactionKind[paramType.kind]} txn`);
                }
                // Push any itxn params to the itxn array in order
                results.itxns.push(arg.resolve());
                return [];
            }
            if (paramType.equals(assetPType)) {
                return handleForeignRef(results.foreignAssets, 0n, paramType, arg);
            }
            if (paramType.equals(applicationPType)) {
                return handleForeignRef(results.foreignApps, 1n, paramType, arg);
            }
            if (paramType.equals(accountPType)) {
                return handleForeignRef(results.foreignAccounts, 1n, paramType, arg);
            }
            const encodedType = ptypeToArc4EncodedType(paramType, sourceLocation);
            const resolvedArg = requireExpressionOfType(arg, paramType);
            if (encodedType.equals(paramType)) {
                return resolvedArg;
            }
            return nodeFactory.aRC4Encode({
                value: resolvedArg,
                wtype: encodedType.wtype,
                sourceLocation: arg.sourceLocation,
            });
        }));
    }
    return {
        appArgs: nodeFactory.tupleExpression({
            items: appArgs,
            sourceLocation,
        }),
        itxns: results.itxns,
        foreignApps: results.foreignApps.length
            ? nodeFactory.tupleExpression({
                items: results.foreignApps,
                sourceLocation,
            })
            : null,
        foreignAccounts: results.foreignAccounts.length
            ? nodeFactory.tupleExpression({
                items: results.foreignAccounts,
                sourceLocation,
            })
            : null,
        foreignAssets: results.foreignAssets.length
            ? nodeFactory.tupleExpression({
                items: results.foreignAssets,
                sourceLocation,
            })
            : null,
    };
}
/**
 * Adds the arg expression to the foreign refs array and returns the index of that item
 * @param refsArray The foreign refs array associated with the ref type
 * @param offset The initial offset for the ref type. Account 0 is Txn.sender and App 0 is Global.currentApplication
 * @param paramType The ptype for the parameter
 * @param arg The builder for the arg value
 */
function handleForeignRef(refsArray, offset, paramType, arg) {
    refsArray.push(requireExpressionOfType(arg, paramType));
    return nodeFactory.integerConstant({
        value: BigInt(refsArray.length - 1) + offset,
        wtype: new wtypes.ARC4UIntN({ n: 8n }),
        sourceLocation: SourceLocation.None,
        tealAlias: null,
    });
}
function getReturnValueExpr(itxnResult, returnType, sourceLocation) {
    const returnValueLog = nodeFactory.innerTransactionField({
        field: TxnField.LastLog,
        arrayIndex: null,
        itxn: itxnResult,
        wtype: wtypes.bytesWType,
        sourceLocation,
    });
    const logPrefix = nodeFactory.bytesConstant({ value: hexToUint8Array(Constants.algo.arc4.logPrefixHex), sourceLocation });
    const unprefixedLog = validatePrefix(instanceEb(returnValueLog, bytesPType), logPrefix, sourceLocation);
    const arc4Return = ptypeToArc4EncodedType(returnType, sourceLocation);
    const returnValueArc4 = nodeFactory.reinterpretCast({
        expr: unprefixedLog,
        sourceLocation,
        wtype: arc4Return.wtype,
    });
    if (returnType.equals(arc4Return))
        return returnValueArc4;
    return nodeFactory.aRC4Decode({
        value: returnValueArc4,
        wtype: returnType.wtypeOrThrow,
        sourceLocation,
    });
}

class StrClassBuilder extends ClassBuilder {
    ptype = ARC4StrClass;
    newCall(args, typeArgs, sourceLocation) {
        const { args: [initialValue], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: this.typeDescription,
            callLocation: sourceLocation,
            argSpec: (a) => [a.optional(stringPType)],
        });
        if (!initialValue) {
            return new StrExpressionBuilder(nodeFactory.stringConstant({
                value: '',
                sourceLocation: sourceLocation,
                wtype: wtypes.arc4StringAliasWType,
            }));
        }
        const expr = initialValue.resolve();
        if (expr instanceof StringConstant) {
            return new StrExpressionBuilder(nodeFactory.stringConstant({
                value: expr.value,
                sourceLocation: sourceLocation,
                wtype: wtypes.arc4StringAliasWType,
            }));
        }
        else {
            return new StrExpressionBuilder(nodeFactory.aRC4Encode({
                value: expr,
                wtype: wtypes.arc4StringAliasWType,
                sourceLocation,
            }));
        }
    }
}
class StrExpressionBuilder extends Arc4EncodedBaseExpressionBuilder {
    constructor(expression) {
        super(expression, arc4StringType);
    }
}

class StructClassBuilder extends ClassBuilder {
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof ARC4StructClass, 'ptype must be ARC4StructClass');
        this.ptype = ptype;
    }
    newCall(args, typeArgs, sourceLocation) {
        const { args: [initialValues], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required(this.ptype.instanceType.nativeType)],
        });
        const initialSingle = initialValues.singleEvaluation();
        const structFields = Object.entries(this.ptype.instanceType.fields).map(([p, t]) => [p, requireExpressionOfType(initialSingle.memberAccess(p, sourceLocation), t)]);
        return new StructExpressionBuilder(nodeFactory.newStruct({
            wtype: this.ptype.instanceType.wtype,
            values: new Map(structFields),
            sourceLocation,
        }), this.ptype.instanceType);
    }
}
class StructExpressionBuilder extends Arc4EncodedBaseExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof ARC4StructType, 'ptype must be ARC4StructType');
        super(expr, ptype);
    }
    hasProperty(name) {
        return name in this.ptype.fields || super.hasProperty(name);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'copy':
                return new Arc4CopyFunctionBuilder(this);
        }
        if (name in this.ptype.fields) {
            const fieldType = this.ptype.fields[name];
            return instanceEb(nodeFactory.fieldExpression({
                name,
                sourceLocation,
                wtype: fieldType.wtype,
                base: this._expr,
            }), fieldType);
        }
        return super.memberAccess(name, sourceLocation);
    }
    resolvableToPType(ptype) {
        if (ptype.equals(this.ptype))
            return true;
        if (ptype instanceof ObjectPType) {
            const native = this.memberAccess('native', this.sourceLocation);
            if (native instanceof InstanceBuilder) {
                return native.resolvableToPType(ptype);
            }
        }
        return false;
    }
    resolveToPType(ptype) {
        if (ptype.equals(this.ptype))
            return this;
        if (ptype instanceof ObjectPType) {
            const native = this.memberAccess('native', this.sourceLocation);
            if (native instanceof InstanceBuilder) {
                return native.resolveToPType(ptype);
            }
        }
        return super.resolveToPType(ptype);
    }
}

class Arc4TupleClassBuilder extends ClassBuilder {
    ptype = Arc4TupleClass;
    newCall(args, typeArgs, sourceLocation) {
        const { args: tupleItems, ptypes: [tupleType], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            funcName: this.typeDescription,
            callLocation: sourceLocation,
            argSpec: (a) => args.map(() => a.required()),
        });
        codeInvariant(tupleType instanceof TuplePType, 'Generic type must be a native tuple type', sourceLocation);
        if (args.length === 0) {
            const arc4Type = ptypeToArc4EncodedType(tupleType, sourceLocation);
            codeInvariant(arc4Type.fixedByteSize !== null, 'Zero arg constructor can only be used for tuples with a fixed size encoding.');
            return new Arc4TupleExpressionBuilder(intrinsicFactory.bzero({ size: arc4Type.fixedByteSize, wtype: arc4Type.wtype, sourceLocation }), arc4Type);
        }
        const expressions = [];
        const types = [];
        for (const item of tupleItems) {
            if (item.ptype instanceof ARC4EncodedType) {
                expressions.push(item.resolve());
                types.push(item.ptype);
            }
            else {
                logger.error(item.sourceLocation, 'ARC4 tuple items must be ARC4 encoded types');
            }
        }
        const arc4TupleType = new ARC4TupleType({
            types,
            sourceLocation,
        });
        return new Arc4TupleExpressionBuilder(nodeFactory.aRC4Encode({
            value: nodeFactory.tupleExpression({
                items: expressions,
                wtype: tupleType.wtype,
                sourceLocation,
            }),
            wtype: arc4TupleType.wtype,
            sourceLocation,
        }), arc4TupleType);
    }
}
class Arc4TupleExpressionBuilder extends Arc4EncodedBaseExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof ARC4TupleType, 'ptype must be ARC4TupleType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'at':
                return new Arc4TupleAtFunctionBuilder(this, sourceLocation);
            case 'length':
                return instanceEb(nodeFactory.uInt64Constant({
                    value: BigInt(this.ptype.items.length),
                    sourceLocation,
                }), uint64PType);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class Arc4TupleAtFunctionBuilder extends FunctionBuilder {
    builder;
    constructor(builder, sourceLocation) {
        super(sourceLocation);
        this.builder = builder;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [index], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: 'at',
            argSpec: (a) => [a.required(numberPType)],
        });
        const indexNum = requireIntegerConstant(index).value;
        codeInvariant(indexNum < this.builder.ptype.items.length && indexNum >= 0, "Index arg must be a numeric literal between 0 and the tuple's length");
        const itemType = this.builder.ptype.items[Number(indexNum)];
        return instanceEb(nodeFactory.tupleItemExpression({
            index: indexNum,
            sourceLocation,
            base: this.builder.resolve(),
        }), itemType);
    }
}

class UFixedNxMClassBuilder extends ClassBuilder {
    ptype = UFixedNxMClass;
    newCall(args, typeArgs, sourceLocation) {
        const { ptypes: [size, decimals], args: [initialValueBuilder], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 2,
            funcName: this.typeDescription,
            argSpec: (a) => [a.optional(stringPType)],
            callLocation: sourceLocation,
        });
        codeInvariant(size instanceof NumericLiteralPType, `Generic type N of ${this.typeDescription} must be a literal number. Inferred type is ${size.name}`, sourceLocation);
        codeInvariant(decimals instanceof NumericLiteralPType, `Generic type M of ${this.typeDescription} must be a literal number. Inferred type is ${decimals.name}`, sourceLocation);
        const ptype = new UFixedNxMType({ n: size.literalValue, m: decimals.literalValue });
        return newUFixedNxM(initialValueBuilder, ptype, sourceLocation);
    }
}
function newUFixedNxM(initialValue, ptype, sourceLocation) {
    let expr;
    if (initialValue === undefined) {
        expr = nodeFactory.decimalConstant({
            wtype: ptype.wtype,
            value: '0',
            sourceLocation,
        });
    }
    else if (initialValue.ptype.equals(stringPType)) {
        const strConstant = requireStringConstant(initialValue);
        expr = fromDecimalString(strConstant, ptype);
    }
    else {
        throw new CodeError(`Unsupported expression of type ${initialValue.ptype}`, { sourceLocation: initialValue.sourceLocation });
    }
    return new UFixedNxMExpressionBuilder(expr, ptype);
}
function fromDecimalString(strConst, ptype) {
    const [integer, decimal, ...rest] = strConst.value.split('.');
    codeInvariant(rest.length === 0, 'Decimals should have at most 1 decimal point', strConst.sourceLocation);
    codeInvariant(decimal === undefined || decimal.length <= ptype.m, 'Number of decimal places cannot exceed M', strConst.sourceLocation);
    const d = decimal === undefined ? 0n : BigInt(decimal.padEnd(Number(ptype.m), '0'));
    const i = BigInt(integer);
    const val = i * 10n ** ptype.m + d;
    codeInvariant(isValidLiteralForPType(val, ptype), `${strConst} is not a valid literal for ${ptype.name}`, strConst.sourceLocation);
    return nodeFactory.decimalConstant({
        wtype: ptype.wtype,
        value: strConst.value,
        sourceLocation: strConst.sourceLocation,
    });
}
class UFixedNxMExpressionBuilder extends Arc4EncodedBaseExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof UFixedNxMType, 'ptype must be UFixedNxMType');
        super(expr, ptype);
    }
}

class UintNClassBuilder extends ClassBuilder {
    ptype = UintNClass;
    newCall(args, typeArgs, sourceLocation) {
        const { ptypes: [size], args: [initialValueBuilder], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            funcName: this.typeDescription,
            argSpec: (a) => [a.optional()],
            callLocation: sourceLocation,
        });
        codeInvariant(size instanceof NumericLiteralPType, `Generic type of ${this.typeDescription} must be a literal number. Inferred type is ${size.name}`, sourceLocation);
        const ptype = new UintNType({ n: size.literalValue });
        return newUintN(initialValueBuilder, ptype, sourceLocation);
    }
}
const classBuilderForUintNAlias = (aliasClass, aliasInstance) => {
    return class extends ClassBuilder {
        ptype = aliasClass;
        newCall(args, typeArgs, sourceLocation) {
            const { args: [initialValueBuilder], } = parseFunctionArgs({
                args,
                typeArgs,
                genericTypeArgs: 1,
                funcName: `${this.typeDescription} constructor`,
                argSpec: (a) => [a.optional()],
                callLocation: sourceLocation,
            });
            return newUintN(initialValueBuilder, aliasInstance, sourceLocation);
        }
    };
};
function newUintN(initialValueBuilder, ptype, sourceLocation) {
    if (initialValueBuilder === undefined) {
        return new UintNExpressionBuilder(nodeFactory.integerConstant({
            value: 0n,
            tealAlias: null,
            wtype: ptype.wtype,
            sourceLocation: sourceLocation,
        }), ptype);
    }
    if (ptype.n <= 64 && initialValueBuilder.resolvableToPType(uint64PType)) {
        const initialValue = initialValueBuilder.resolveToPType(uint64PType).resolve();
        if (initialValue instanceof IntegerConstant) {
            codeInvariant(isValidLiteralForPType(initialValue.value, ptype), `${initialValue.value} cannot be converted to ${ptype}`);
            return new UintNExpressionBuilder(nodeFactory.integerConstant({
                value: initialValue.value,
                wtype: ptype.wtype,
                tealAlias: null,
                sourceLocation: sourceLocation,
            }), ptype);
        }
        else {
            return new UintNExpressionBuilder(nodeFactory.aRC4Encode({
                wtype: ptype.wtype,
                sourceLocation,
                value: initialValue,
            }), ptype);
        }
    }
    if (initialValueBuilder.resolvableToPType(biguintPType)) {
        const initialValue = initialValueBuilder.resolveToPType(biguintPType).resolve();
        if (initialValue instanceof IntegerConstant) {
            codeInvariant(isValidLiteralForPType(initialValue.value, ptype), `${initialValue.value} cannot be converted to ${ptype}`);
            return new UintNExpressionBuilder(nodeFactory.integerConstant({
                value: initialValue.value,
                wtype: ptype.wtypeOrThrow,
                sourceLocation: sourceLocation,
                tealAlias: null,
            }), ptype);
        }
        else {
            return new UintNExpressionBuilder(nodeFactory.aRC4Encode({
                wtype: ptype.wtype,
                sourceLocation,
                value: initialValue,
            }), ptype);
        }
    }
    throw CodeError.unexpectedUnhandledArgs({ sourceLocation });
}
class UintNExpressionBuilder extends Arc4EncodedBaseExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof UintNType, 'ptype must be instance of UIntNType');
        super(expr, ptype);
    }
}

class VoidExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr) {
        super(expr, voidPType);
    }
    resolveLValue() {
        throw new CodeError(`${this.typeDescription} is not a valid assignment target`);
    }
}

class AssertFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const [condition, message, ...rest] = args;
        if (rest.length !== 0) {
            throw CodeError.unexpectedUnhandledArgs({ sourceLocation });
        }
        if (condition === undefined) {
            throw new CodeError('Missing required argument: condition', { sourceLocation });
        }
        let messageStr = null;
        if (message) {
            const messageConst = requireConstantOfType(message, stringPType);
            invariant(messageConst instanceof StringConstant, 'messageConst must be StringConst');
            messageStr = messageConst.value;
        }
        return new VoidExpressionBuilder(intrinsicFactory.assert({
            sourceLocation,
            condition: condition.boolEval(sourceLocation),
            comment: messageStr,
        }));
    }
}
class ErrFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [message], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            argSpec: (a) => [a.optional(stringPType)],
            funcName: 'err',
        });
        return new VoidExpressionBuilder(intrinsicFactory.err({
            sourceLocation,
            comment: message ? requireStringConstant(message).value : null,
        }));
    }
}

class MatchFunctionBuilder extends NodeBuilder {
    ptype = matchFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [subject, tests], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 1,
            funcName: 'match',
            argSpec: (a) => [a.passthrough(), a.required()],
        });
        codeInvariant(subject, 'subject parameter is missing', sourceLocation);
        return buildComparisons(subject, tests, this.typeDescription, sourceLocation);
    }
}
function buildComparisons(subject, tests, functionName, sourceLocation) {
    if (tests.ptype instanceof ObjectPType) {
        const condition = tests.ptype
            .orderedProperties()
            .reduce((acc, [propName, propType]) => {
            const subjectProperty = requireInstanceBuilder(subject.memberAccess(propName, sourceLocation));
            const testProperty = requireInstanceBuilder(tests.memberAccess(propName, sourceLocation));
            const comparison = buildComparison(subjectProperty, testProperty, functionName, sourceLocation);
            return combineConditions(acc, comparison.resolve(), sourceLocation);
        }, undefined);
        codeInvariant(condition, `${functionName} must have at least 1 condition`, sourceLocation);
        return instanceEb(condition, boolPType);
    }
    else if (isStaticallyIterable(tests)) {
        const condition = tests[StaticIterator]().reduce((acc, testItem, index) => {
            const indexAsBuilder = instanceEb(nodeFactory.uInt64Constant({ value: BigInt(index), sourceLocation }), uint64PType);
            const subjectItem = requireInstanceBuilder(subject.indexAccess(indexAsBuilder, sourceLocation));
            const comparison = buildComparison(subjectItem, testItem, functionName, sourceLocation);
            return combineConditions(acc, comparison.resolve(), sourceLocation);
        }, compareLengths(subject, tests, functionName, sourceLocation));
        codeInvariant(condition, `${functionName} must have at least 1 condition`, sourceLocation);
        return instanceEb(condition, boolPType);
    }
    else if (tests.ptype instanceof ArrayPType) {
        throw new CodeError(`${functionName} doesn't support matching against non literal arrays`, { sourceLocation: tests.sourceLocation });
    }
    else {
        throw new CodeError(`${functionName} requires either an object, array literal, or tuple`, { sourceLocation: tests.sourceLocation });
    }
}
function compareLengths(subject, tests, functionName, sourceLocation) {
    const subjectLength = requireInstanceBuilder(subject.memberAccess('length', sourceLocation));
    const testsLength = requireInstanceBuilder(tests.memberAccess('length', sourceLocation));
    return buildComparison(subjectLength, testsLength, functionName, sourceLocation).resolve();
}
function buildComparison(subjectProperty, testProperty, functionName, sourceLocation) {
    const subjectType = subjectProperty.ptype;
    // Recurse comparisons for nested objects
    if (subjectProperty.ptype instanceof ObjectPType ||
        subjectProperty.ptype instanceof TuplePType ||
        subjectProperty.ptype instanceof ArrayPType) {
        return buildComparisons(subjectProperty, testProperty, functionName, sourceLocation);
    }
    if (testProperty.resolvableToPType(subjectType)) {
        return subjectProperty.compare(testProperty, BuilderComparisonOp.eq, sourceLocation);
    }
    else if (testProperty.hasProperty('between')) {
        const range = requireInstanceBuilder(testProperty.memberAccess('between', sourceLocation)).singleEvaluation();
        const rangePType = new TuplePType({ items: [subjectType, subjectType] });
        codeInvariant(range.resolvableToPType(rangePType), 'Between range must be of type $');
        const zeroIndex = instanceEb(nodeFactory.uInt64Constant({ value: 0n, sourceLocation }), uint64PType);
        const gte = subjectProperty
            .compare(requireBuilderOfType(range.indexAccess(zeroIndex, sourceLocation), subjectType), BuilderComparisonOp.gte, sourceLocation)
            .resolve();
        const oneIndex = instanceEb(nodeFactory.uInt64Constant({ value: 1n, sourceLocation }), uint64PType);
        const lte = subjectProperty
            .compare(requireBuilderOfType(range.indexAccess(oneIndex, sourceLocation), subjectType), BuilderComparisonOp.lte, sourceLocation)
            .resolve();
        return instanceEb(combineConditions(lte, gte, sourceLocation), boolPType);
    }
    else {
        const [op, operand] = getComparisonOpAndOperand(testProperty, subjectType);
        return subjectProperty.compare(operand, op, sourceLocation);
    }
}
function getComparisonOpAndOperand(testProperty, targetType) {
    const ops = {
        lessThan: BuilderComparisonOp.lt,
        lessThanEq: BuilderComparisonOp.lte,
        greaterThan: BuilderComparisonOp.gt,
        greaterThanEq: BuilderComparisonOp.gte,
    };
    for (const [prop, op] of Object.entries(ops)) {
        if (testProperty.hasProperty(prop)) {
            return [op, requireBuilderOfType(testProperty.memberAccess(prop, testProperty.sourceLocation), targetType)];
        }
    }
    throw new CodeError(`Cannot compare values of type ${testProperty.ptype} and ${targetType.name}`, {
        sourceLocation: testProperty.sourceLocation,
    });
}
function combineConditions(left, right, sourceLocation) {
    if (left) {
        return nodeFactory.booleanBinaryOperation({
            left: left,
            right: right,
            op: BinaryBooleanOperator.and,
            sourceLocation,
        });
    }
    return right;
}

class AssertMatchFunctionBuilder extends NodeBuilder {
    ptype = assertMatchFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [subject, tests, comment], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 1,
            funcName: 'assertMatch',
            argSpec: (a) => [a.passthrough(), a.required(), a.optional(stringPType)],
        });
        codeInvariant(subject, 'subject parameter is missing', sourceLocation);
        const condition = buildComparisons(subject, tests, this.typeDescription, sourceLocation).resolve();
        codeInvariant(condition, 'assertMatch must have at least 1 condition', sourceLocation);
        const commentStr = comment ? requireStringConstant(comment).value : 'assert target is match for conditions';
        return new VoidExpressionBuilder(intrinsicFactory.assert({
            condition,
            comment: commentStr,
            sourceLocation,
        }));
    }
}

class BigUintFunctionBuilder extends FunctionBuilder {
    ptype = BigUintFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [initialValue], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'BigUInt',
            argSpec: (a) => [a.optional(boolPType, stringPType, bytesPType, biguintPType, uint64PType)],
        });
        let biguint;
        if (!initialValue) {
            biguint = nodeFactory.bigUIntConstant({
                sourceLocation,
                value: 0n,
            });
        }
        else if (initialValue.ptype.equals(boolPType)) {
            biguint = nodeFactory.reinterpretCast({
                expr: initialValue.toBytes(sourceLocation),
                sourceLocation,
                wtype: biguintPType.wtype,
            });
        }
        else if (initialValue.ptype.equals(stringPType)) {
            const expr = initialValue.resolve();
            if (expr instanceof StringConstant) {
                biguint = nodeFactory.bigUIntConstant({
                    value: BigInt(expr.value),
                    sourceLocation,
                });
            }
            else {
                logger.error(initialValue.sourceLocation, 'Only compile time constant string values are supported');
                biguint = nodeFactory.bigUIntConstant({ value: 0n, sourceLocation });
            }
        }
        else if (initialValue.ptype.equals(bytesPType)) {
            biguint = nodeFactory.reinterpretCast({
                expr: initialValue.resolve(),
                sourceLocation,
                wtype: biguintPType.wtype,
            });
        }
        else if (initialValue.ptype.equals(uint64PType)) {
            const expr = initialValue.resolve();
            if (expr instanceof IntegerConstant) {
                biguint = nodeFactory.bigUIntConstant({
                    ...expr,
                    sourceLocation,
                });
            }
            else {
                biguint = nodeFactory.reinterpretCast({
                    expr: initialValue.toBytes(sourceLocation),
                    sourceLocation,
                    wtype: biguintPType.wtype,
                });
            }
        }
        else {
            return initialValue;
        }
        return new BigUintExpressionBuilder(biguint);
    }
}
class BigUintExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr) {
        super(expr, biguintPType);
    }
    compare(other, op, sourceLocation) {
        const otherExpr = requireExpressionOfType(other, biguintPType);
        const numComOp = tryConvertEnum(op, BuilderComparisonOp, NumericComparison);
        if (numComOp === undefined) {
            throw new NotSupported(`Numeric comparison operator ${op}`, {
                sourceLocation,
            });
        }
        return instanceEb(nodeFactory.numericComparisonExpression({
            lhs: this._expr,
            rhs: otherExpr,
            operator: numComOp,
            sourceLocation,
        }), boolPType);
    }
    boolEval(sourceLocation, negate = false) {
        return new UInt64ExpressionBuilder(intrinsicFactory.bitLen({
            value: this._expr,
            sourceLocation,
        })).boolEval(sourceLocation, negate);
    }
    prefixUnaryOp(op, sourceLocation) {
        let binaryOp;
        switch (op) {
            case BuilderUnaryOp.inc:
                binaryOp = BigUIntBinaryOperator.add;
                break;
            case BuilderUnaryOp.dec:
                binaryOp = BigUIntBinaryOperator.sub;
                break;
            case BuilderUnaryOp.bit_inv:
                logger.error(sourceLocation, `Bitwise inversion of ${this.typeDescription} is not supported as the bit size is indeterminate`);
                return this;
            case BuilderUnaryOp.pos:
                return this;
            default:
                return super.prefixUnaryOp(op, sourceLocation);
        }
        return new BigUintExpressionBuilder(nodeFactory.assignmentExpression({
            target: this.resolveLValue(),
            sourceLocation,
            value: nodeFactory.bigUIntBinaryOperation({
                left: this.resolve(),
                right: nodeFactory.bigUIntConstant({ value: 1n, sourceLocation }),
                op: binaryOp,
                sourceLocation,
            }),
        }));
    }
    postfixUnaryOp(op, sourceLocation) {
        let unaryOp;
        switch (op) {
            case BuilderUnaryOp.inc:
                unaryOp = BigUIntPostfixUnaryOperator.increment;
                break;
            case BuilderUnaryOp.dec:
                unaryOp = BigUIntPostfixUnaryOperator.decrement;
                break;
            default:
                return super.postfixUnaryOp(op, sourceLocation);
        }
        return new BigUintExpressionBuilder(nodeFactory.bigUIntPostfixUnaryOperation({
            sourceLocation,
            target: this.resolveLValue(),
            wtype: this.ptype.wtype,
            op: unaryOp,
        }));
    }
    binaryOp(other, op, sourceLocation) {
        const otherExpr = requireExpressionOfType(other, biguintPType);
        const uintOp = op === BuilderBinaryOp.div ? BigUIntBinaryOperator.floorDiv : tryConvertEnum(op, BuilderBinaryOp, BigUIntBinaryOperator);
        if (uintOp === undefined) {
            throw new NotSupported(`BigUint binary operator '${op}'`, {
                sourceLocation,
            });
        }
        return new BigUintExpressionBuilder(nodeFactory.bigUIntBinaryOperation({
            left: this._expr,
            right: otherExpr,
            op: uintOp,
            sourceLocation,
        }));
    }
    augmentedAssignment(other, op, sourceLocation) {
        return new BigUintExpressionBuilder(nodeFactory.assignmentExpression({
            target: this.resolveLValue(),
            value: this.binaryOp(other, op, sourceLocation).resolve(),
            sourceLocation,
        }));
    }
    toBytes(sourceLocation) {
        return nodeFactory.reinterpretCast({ expr: this.resolve(), sourceLocation, wtype: wtypes.bytesWType });
    }
}

function requireAvmVersion(builder) {
    const value = requireIntegerConstant(builder);
    codeInvariant(isIn(value.value, Constants.supportedAvmVersions), `${value.value} is not a supported AVM version`, value.sourceLocation);
    return value.value;
}

class TupleExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expression, ptype) {
        invariant(ptype instanceof TuplePType, 'TupleExpressionBuilder must be built with ptype of type TuplePType');
        super(expression, ptype);
    }
    iterate() {
        return this.resolve();
    }
    resolvableToPType(ptype) {
        if (ptype instanceof ArrayPType && this.ptype.items.every((i) => i.equals(ptype.elementType))) {
            return true;
        }
        return super.resolvableToPType(ptype);
    }
    resolveToPType(ptype) {
        if (ptype instanceof ArrayPType && this.ptype.items.every((i) => i.equals(ptype.elementType))) {
            return instanceEb(nodeFactory.newArray({
                values: this[StaticIterator]().map((i) => i.resolve()),
                wtype: ptype.wtype,
                sourceLocation: this.sourceLocation,
            }), ptype);
        }
        return super.resolveToPType(ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'length':
                return instanceEb(nodeFactory.uInt64Constant({
                    value: BigInt(this.ptype.items.length),
                    sourceLocation,
                }), uint64PType);
        }
        return super.memberAccess(name, sourceLocation);
    }
    indexAccess(index, sourceLocation) {
        const indexNum = requireIntegerConstant(index).value;
        const itemType = this.ptype.items[Number(indexNum)];
        codeInvariant(indexNum < this.ptype.items.length && indexNum >= 0, "Index arg must be a numeric literal between 0 and the tuple's length");
        return instanceEb(nodeFactory.tupleItemExpression({
            index: indexNum,
            sourceLocation,
            base: this._expr,
        }), itemType);
    }
    [StaticIterator]() {
        return this.ptype.items.map((itemType, index) => instanceEb(nodeFactory.tupleItemExpression({
            index: BigInt(index),
            sourceLocation: this.sourceLocation,
            base: this._expr,
        }), itemType));
    }
}

class ArrayLiteralExpressionBuilder extends InstanceBuilder {
    items;
    ptype;
    constructor(sourceLocation, items, ptype) {
        super(sourceLocation);
        this.items = items;
        this.ptype = ptype ?? new ArrayLiteralPType({ items: items.map((i) => i.ptype) });
    }
    resolve() {
        const arrayType = this.ptype instanceof ArrayPType ? this.ptype : this.ptype.getArrayType();
        return nodeFactory.newArray({
            sourceLocation: this.sourceLocation,
            values: this.items.map((i) => i.resolve()),
            wtype: arrayType.wtype,
        });
    }
    resolveLValue() {
        throw new CodeError('Array literal is not a valid lvalue');
    }
    singleEvaluation() {
        return new ArrayLiteralExpressionBuilder(this.sourceLocation, this.items.map((i) => i.singleEvaluation()));
    }
    indexAccess(index, sourceLocation) {
        const indexNum = Number(requireIntegerConstant(index).value);
        codeInvariant(indexNum < this.items.length, `Index ${indexNum} out of bounds of array`, sourceLocation);
        return this.items[indexNum];
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'length':
                return arrayLength(this, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
    resolveToPType(ptype) {
        if (ptype instanceof TuplePType) {
            codeInvariant(ptype.items.length <= this.items.length, `Value of length ${this.items.length} cannot be resolved to type of length ${ptype.items.length}`);
            return new TupleExpressionBuilder(nodeFactory.tupleExpression({
                items: ptype.items.map((itemType, index) => this.items[index].resolveToPType(itemType).resolve()),
                sourceLocation: this.sourceLocation,
            }), ptype);
        }
        if (ptype instanceof ArrayPType) {
            return new ArrayLiteralExpressionBuilder(this.sourceLocation, this.items.map((i) => i.resolveToPType(ptype.elementType)), ptype);
        }
        return super.resolveToPType(ptype);
    }
    resolvableToPType(ptype) {
        if (ptype.equals(this.ptype))
            return true;
        if (ptype instanceof TuplePType) {
            return ptype.items.every((itemType, index) => this.items[index].resolvableToPType(itemType));
        }
        if (ptype instanceof ArrayPType) {
            return this.items.every((i) => i.resolveToPType(ptype.elementType));
        }
        return false;
    }
    [StaticIterator]() {
        return this.items;
    }
}

function processScratchRanges(builder) {
    codeInvariant(builder instanceof ArrayLiteralExpressionBuilder, 'Scratch ranges should be specified in an array literal', builder.sourceLocation);
    const slots = new Set();
    for (const item of builder[StaticIterator]()) {
        if (item.resolvableToPType(numberPType)) {
            slots.add(requireLiteralNumber(item));
        }
        else {
            const from = getRangeProp(item, 'from');
            const to = getRangeProp(item, 'to');
            for (let i = from; i <= to; i++) {
                slots.add(i);
            }
        }
    }
    return slots;
}
function getRangeProp(builder, name) {
    if (builder.hasProperty(name)) {
        return requireLiteralNumber(builder.memberAccess(name, builder.sourceLocation));
    }
    throw new CodeError('Scratch slot reservations should be either a single slot or an object containing a from and to property', {
        sourceLocation: builder.sourceLocation,
    });
}

/**
 * Handles expressions using `this` in the context of a contract
 */
class ContractThisBuilder extends InstanceBuilder {
    resolve() {
        throw new CodeError('this keyword is not valid as a value', { sourceLocation: this.sourceLocation });
    }
    resolveLValue() {
        throw new CodeError('this keyword is not valid as a value', { sourceLocation: this.sourceLocation });
    }
    #ptype;
    constructor(ptype, sourceLocation) {
        super(sourceLocation);
        this.#ptype = ptype;
    }
    get ptype() {
        return this.#ptype;
    }
    memberAccess(name, sourceLocation) {
        const property = this.ptype.properties[name];
        if (property) {
            const storageDeclaration = AwstBuildContext.current.getStorageDeclaration(this.ptype, name);
            if (property instanceof StorageProxyPType) {
                codeInvariant(storageDeclaration, `No declaration exists for property ${property}.`, sourceLocation);
                return instanceEb(storageDeclaration.key, property);
            }
        }
        const method = this.ptype.methods[name];
        if (method) {
            return new ContractMethodExpressionBuilder(sourceLocation, method, this.ptype);
        }
        for (const base of this.ptype.allBases()) {
            if (name in base.methods) {
                return new ContractMethodExpressionBuilder(sourceLocation, base.methods[name], base);
            }
        }
        return super.memberAccess(name, sourceLocation);
    }
}
/**
 * Handles expressions using `super` in the context of a contract
 */
class ContractSuperBuilder extends ContractThisBuilder {
    constructor(ptype, sourceLocation) {
        super(ptype, sourceLocation);
    }
    call(args, typeArgs, sourceLocation) {
        codeInvariant(args.length === 0, 'Constructor arguments are not supported', sourceLocation);
        codeInvariant(typeArgs.length === 0, 'Super calls cannot be generic', sourceLocation);
        return new VoidExpressionBuilder(nodeFactory.subroutineCallExpression({
            target: nodeFactory.instanceSuperMethodTarget({
                memberName: Constants.symbolNames.constructorMethodName,
            }),
            args: [],
            sourceLocation,
            wtype: wtypes.voidWType,
        }));
    }
    memberAccess(name, sourceLocation) {
        if (this.ptype instanceof ClusteredContractClassType && name === 'class') {
            return new PolytypeClassSuperMethodBuilder(this.ptype, sourceLocation);
        }
        const method = this.ptype.methods[name];
        if (method) {
            return new BaseContractMethodExpressionBuilder(sourceLocation, method);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
/**
 * Handles calls of `super.class` from polytype library which is used to access the prototype of a specific base type
 */
class PolytypeClassSuperMethodBuilder extends FunctionBuilder {
    ptype;
    constructor(ptype, sourceLocation) {
        super(sourceLocation);
        this.ptype = ptype;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [contract], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: 'super.class',
            argSpec: (a) => [a.required(ContractClassPType)],
        });
        const matchedBaseType = this.ptype.baseTypes.find((b) => b.equals(contract.ptype));
        codeInvariant(matchedBaseType, `${contract.ptype} must be a direct base type of this class`);
        return new PolytypeExplicitClassAccessExpressionBuilder(matchedBaseType, sourceLocation);
    }
}
/**
 * Matches polytype's super.class(SomeType) expression
 */
class PolytypeExplicitClassAccessExpressionBuilder extends InstanceBuilder {
    ptype;
    resolve() {
        throw new CodeError('Contract class cannot be used as a value');
    }
    resolveLValue() {
        throw new CodeError('Contract class cannot be used as a value');
    }
    constructor(ptype, sourceLocation) {
        super(sourceLocation);
        this.ptype = ptype;
    }
    memberAccess(name, sourceLocation) {
        const method = this.ptype.methods[name];
        if (method) {
            return new ContractMethodExpressionBuilder(sourceLocation, method, this.ptype);
        }
        if (name in this.ptype.properties) {
            throw new CodeError(`Not Supported: Accessing properties of a specific base type. Instead just use \`this.${name}\``, {
                sourceLocation,
            });
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class ContractClassBuilder extends InstanceBuilder {
    resolve() {
        throw new CodeError('Contract class cannot be used as a value');
    }
    resolveLValue() {
        throw new CodeError('Contract class cannot be used as a value');
    }
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof ContractClassPType, 'ptype must be ContractClassPType');
        this.ptype = ptype;
    }
    newCall(args, typeArgs, sourceLocation) {
        throw new CodeError('Contract class cannot be constructed manually');
    }
    call(args, typeArgs, sourceLocation) {
        throw new CodeError('Contract class cannot be called manually');
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'prototype':
                return new ContractClassPrototypeBuilder(sourceLocation, this.ptype);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class ContractClassPrototypeBuilder extends NodeBuilder {
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        this.ptype = ptype;
    }
    memberAccess(name, sourceLocation) {
        const method = this.ptype.methods[name];
        if (method) {
            return new ContractMethodExpressionBuilder(sourceLocation, method, this.ptype);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class ContractOptionsDecoratorBuilder extends FunctionBuilder {
    ptype = contractOptionsDecorator;
    call(args, typeArgs, sourceLocation) {
        const { args: [{ avmVersion, name, stateTotals, scratchSlots }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [
                a.obj({
                    avmVersion: a.optional(numberPType),
                    name: a.optional(stringPType),
                    scratchSlots: a.optional(),
                    stateTotals: a.optional(),
                }),
            ],
        });
        return new DecoratorDataBuilder(sourceLocation, {
            type: 'contract',
            avmVersion: avmVersion && requireAvmVersion(avmVersion),
            name: name && requireStringConstant(name).value,
            stateTotals: stateTotals && buildStateTotals(stateTotals),
            scratchSlots: scratchSlots && processScratchRanges(scratchSlots),
            sourceLocation,
        });
    }
}
function buildStateTotals(builder) {
    function tryGetProp(name) {
        if (builder.hasProperty(name)) {
            return requireLiteralNumber(builder.memberAccess(name, builder.sourceLocation));
        }
        return undefined;
    }
    return {
        globalBytes: tryGetProp('globalBytes'),
        globalUints: tryGetProp('globalUints'),
        localBytes: tryGetProp('localBytes'),
        localUints: tryGetProp('localUints'),
    };
}

class EnsureBudgetFunctionBuilder extends FunctionBuilder {
    ptype = ensureBudgetFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [budget, feeSource], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: this.ptype.name,
            genericTypeArgs: 0,
            argSpec: (a) => [a.required(uint64PType), a.optional(opUpFeeSourceType.memberType)],
        });
        return new VoidExpressionBuilder(nodeFactory.puyaLibCall({
            func: PuyaLibFunction.ensureBudget,
            args: [
                nodeFactory.callArg({
                    name: null,
                    value: budget.resolve(),
                }),
                nodeFactory.callArg({
                    name: null,
                    value: feeSource
                        ? requireExpressionOfType(feeSource, opUpFeeSourceType.memberType)
                        : nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
                }),
            ],
            sourceLocation,
            wtype: wtypes.voidWType,
        }));
    }
}

class IntrinsicEnumBuilder extends NodeBuilder {
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof IntrinsicEnumType, 'ptype must be instance of IntrinsicEnumType');
        this.ptype = ptype;
    }
    memberAccess(name, sourceLocation) {
        const matchedMember = this.ptype.members.find(([memberName]) => memberName === name);
        if (matchedMember) {
            return new StringExpressionBuilder(nodeFactory.stringConstant({
                value: matchedMember[1],
                sourceLocation,
            }));
        }
        throw new CodeError(`Member ${name} does not exist on ${this.typeDescription}`, { sourceLocation });
    }
}

class LogFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const argsExps = args.map((a) => requireInstanceBuilder(a));
        let logBytes;
        if (argsExps.length === 0) {
            throw new CodeError(`log expects at least 1 argument`, { sourceLocation });
        }
        else if (argsExps.length === 1) {
            logBytes = argsExps[0].toBytes(sourceLocation);
        }
        else {
            logBytes =
                argsExps.reduce((a, b) => a === undefined
                    ? b.toBytes(sourceLocation)
                    : intrinsicFactory.bytesConcat({ left: a, right: b.toBytes(sourceLocation), sourceLocation }), undefined) ?? throwError(new InternalError('Should never get here given previous conditions', { sourceLocation }));
        }
        return new VoidExpressionBuilder(nodeFactory.intrinsicCall({
            sourceLocation: sourceLocation,
            immediates: [],
            stackArgs: [logBytes],
            opCode: 'log',
            wtype: wtypes.voidWType,
        }));
    }
}

class LogicSigClassBuilder extends InstanceBuilder {
    resolve() {
        throw new CodeError('LogicSig class cannot be used as a value');
    }
    resolveLValue() {
        throw new CodeError('LogicSig class cannot be used as a value');
    }
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof LogicSigPType, 'ptype must be LogicSigPType');
        this.ptype = ptype;
    }
    newCall(args, typeArgs, sourceLocation) {
        throw new CodeError('LogicSig class cannot be constructed manually');
    }
    call(args, typeArgs, sourceLocation) {
        throw new CodeError('LogicSig class cannot be called manually');
    }
}
class LogicSigOptionsDecoratorBuilder extends FunctionBuilder {
    ptype = logicSigOptionsDecorator;
    call(args, typeArgs, sourceLocation) {
        const { args: [{ avmVersion, name, scratchSlots }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [
                a.obj({
                    avmVersion: a.optional(numberPType),
                    name: a.optional(stringPType),
                    scratchSlots: a.optional(),
                }),
            ],
        });
        return new DecoratorDataBuilder(sourceLocation, {
            type: 'logicsig',
            avmVersion: avmVersion ? requireAvmVersion(avmVersion) : undefined,
            name: name ? requireStringConstant(name).value : undefined,
            sourceLocation,
            scratchSlots: scratchSlots && processScratchRanges(scratchSlots),
        });
    }
}

class MutableArrayClassBuilder extends ClassBuilder {
    ptype = MutableArrayConstructor;
    newCall(args, typeArgs, sourceLocation) {
        const { args: [...initialValues], ptypes: [itemType], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            genericTypeArgs: 1,
            argSpec: (a) => args.map((_) => a.required()),
        });
        const arrayType = MutableArrayGeneric.parameterise([itemType]);
        return new MutableArrayExpressionBuilder(nodeFactory.newArray({
            values: initialValues.map((iv) => requireExpressionOfType(iv, itemType)),
            sourceLocation,
            wtype: arrayType.wtype,
        }), MutableArrayGeneric.parameterise([itemType]));
    }
}
class MutableArrayExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof MutableArrayType, 'ptype must be MutableArrayType');
        super(expr, ptype);
    }
    iterate(sourceLocation) {
        return this.resolve();
    }
    indexAccess(index, sourceLocation) {
        return indexAccess(this, index, sourceLocation);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'push':
                return new ArrayPushFunctionBuilder(this);
            case 'pop':
                return new ArrayPopFunctionBuilder(this);
            case 'length':
                return arrayLength(this, sourceLocation);
            case 'copy':
                return new Arc4CopyFunctionBuilder(this);
            case 'at':
                return new AtFunctionBuilder(this._expr, this.ptype.elementType, arrayLength(this, sourceLocation).resolve());
        }
        return super.memberAccess(name, sourceLocation);
    }
}

class NamespaceBuilder extends NodeBuilder {
    _ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof NamespacePType, 'NamespaceBuilder must be constructed with NamespacePType');
        this._ptype = ptype;
    }
    get ptype() {
        return this._ptype;
    }
}

class NativeArrayExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof ArrayPType, 'ptype must be instance of ArrayPType');
        super(expr, ptype);
    }
    iterate(sourceLocation) {
        return this.resolve();
    }
    indexAccess(index, sourceLocation) {
        return indexAccess(this, index, sourceLocation);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'with':
                return new WithFunctionBuilder(this, sourceLocation);
            case 'length':
                return arrayLength(this, sourceLocation);
            case 'slice':
                return new SliceFunctionBuilder(this.resolve(), this.ptype);
            case 'concat':
                return new ConcatFunctionBuilder(this, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class ConcatFunctionBuilder extends FunctionBuilder {
    arrayBuilder;
    constructor(arrayBuilder, sourceLocation) {
        super(sourceLocation);
        this.arrayBuilder = arrayBuilder;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [...items], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            argSpec: (a) => args.map(() => a.required()),
            callLocation: sourceLocation,
            funcName: 'Array.concat',
        });
        const elementType = this.arrayBuilder.ptype.elementType;
        return new NativeArrayExpressionBuilder(items
            .reduce((acc, cur) => {
            if (cur.resolvableToPType(elementType)) {
                return concatArrays(acc, instanceEb(nodeFactory.tupleExpression({
                    items: [cur.resolveToPType(elementType).resolve()],
                    sourceLocation: cur.sourceLocation,
                }), new TuplePType({ items: [elementType] })), sourceLocation);
            }
            else if (cur.resolvableToPType(this.arrayBuilder.ptype)) {
                if (cur.ptype instanceof TuplePType) {
                    // Tuple can stay as a tuple, as long as it _is_ resolvable to an array
                    return concatArrays(acc, cur, sourceLocation);
                }
                return concatArrays(acc, cur.resolveToPType(this.arrayBuilder.ptype), sourceLocation);
            }
            if (!(elementType instanceof ARC4EncodedType)) {
                throw new CodeError(`${cur.typeDescription} cannot be concatenated to ${this.typeDescription}`, { sourceLocation });
            }
            if (cur.ptype instanceof ARC4ArrayType && cur.ptype.elementType.equals(elementType)) {
                return concatArrays(acc, cur, sourceLocation);
            }
            throw new Error('TODO');
        }, this.arrayBuilder)
            .resolve(), this.arrayBuilder.ptype);
    }
}
class WithFunctionBuilder extends FunctionBuilder {
    arrayBuilder;
    constructor(arrayBuilder, sourceLocation) {
        super(sourceLocation);
        this.arrayBuilder = arrayBuilder;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [index, newValue], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            argSpec: (a) => [a.required(uint64PType, numberPType), a.required(this.arrayBuilder.ptype.elementType)],
            callLocation: sourceLocation,
            funcName: 'Array.with',
        });
        return new NativeArrayExpressionBuilder(nodeFactory.arrayReplace({
            base: this.arrayBuilder.resolve(),
            value: newValue.resolve(),
            index: translateNegativeIndex(arrayLength(this.arrayBuilder, index.sourceLocation).resolve(), index),
            sourceLocation,
        }), this.arrayBuilder.ptype);
    }
}

class NeverExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof InstanceType && ptype.equals(neverPType), 'ptype must be neverPType');
        super(expr, neverPType);
    }
    resolve() {
        throw new CodeError('Cannot resolve expression of type never', { sourceLocation: this.sourceLocation });
    }
    resolveLValue() {
        throw new CodeError('Expression of type never is not a valid assignment target', { sourceLocation: this.sourceLocation });
    }
}

/* THIS FILE IS GENERATED BY ~/scripts/generate-op-metadata.ts - DO NOT MODIFY DIRECTLY */
const OP_METADATA = {
    AcctParams: {
        type: 'op-grouping',
        name: 'AcctParams',
        ops: {
            acctBalance: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctBalance'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctMinBalance: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctMinBalance'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctAuthAddr: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctAuthAddr'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
            acctTotalNumUint: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalNumUint'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalNumByteSlice: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalNumByteSlice'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalExtraAppPages: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalExtraAppPages'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalAppsCreated: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalAppsCreated'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalAppsOptedIn: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalAppsOptedIn'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalAssetsCreated: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalAssetsCreated'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalAssets: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalAssets'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalBoxes: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalBoxes'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctTotalBoxBytes: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctTotalBoxBytes'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctIncentiveEligible: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctIncentiveEligible'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [boolPType, boolPType] }),
                    },
                ],
            },
            acctLastProposed: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctLastProposed'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            acctLastHeartbeat: {
                type: 'op-mapping',
                op: 'acct_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AcctLastHeartbeat'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
        },
    },
    addw: {
        type: 'op-mapping',
        op: 'addw',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: new TuplePType({ items: [uint64PType, uint64PType] }),
            },
        ],
    },
    AppGlobal: {
        type: 'op-grouping',
        name: 'AppGlobal',
        ops: {
            delete: {
                type: 'op-mapping',
                op: 'app_global_del',
                signatures: [
                    { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: voidPType },
                ],
            },
            getBytes: {
                type: 'op-mapping',
                op: 'app_global_get',
                signatures: [
                    { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: bytesPType },
                ],
            },
            getUint64: {
                type: 'op-mapping',
                op: 'app_global_get',
                signatures: [
                    { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: uint64PType },
                ],
            },
            getExBytes: {
                type: 'op-mapping',
                op: 'app_global_get_ex',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [applicationPType, uint64PType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            getExUint64: {
                type: 'op-mapping',
                op: 'app_global_get_ex',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [applicationPType, uint64PType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            put: {
                type: 'op-mapping',
                op: 'app_global_put',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [uint64PType, bytesPType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
        },
    },
    AppLocal: {
        type: 'op-grouping',
        name: 'AppLocal',
        ops: {
            delete: {
                type: 'op-mapping',
                op: 'app_local_del',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
            getBytes: {
                type: 'op-mapping',
                op: 'app_local_get',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            getUint64: {
                type: 'op-mapping',
                op: 'app_local_get',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: uint64PType,
                    },
                ],
            },
            getExBytes: {
                type: 'op-mapping',
                op: 'app_local_get_ex',
                signatures: [
                    {
                        argNames: ['a', 'b', 'c'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [applicationPType, uint64PType] },
                            { name: 'c', ptypes: [bytesPType] },
                        ],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            getExUint64: {
                type: 'op-mapping',
                op: 'app_local_get_ex',
                signatures: [
                    {
                        argNames: ['a', 'b', 'c'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [applicationPType, uint64PType] },
                            { name: 'c', ptypes: [bytesPType] },
                        ],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            put: {
                type: 'op-mapping',
                op: 'app_local_put',
                signatures: [
                    {
                        argNames: ['a', 'b', 'c'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [bytesPType] },
                            { name: 'c', ptypes: [uint64PType, bytesPType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
        },
    },
    appOptedIn: {
        type: 'op-mapping',
        op: 'app_opted_in',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [accountPType, uint64PType] },
                    { name: 'b', ptypes: [applicationPType, uint64PType] },
                ],
                returnType: boolPType,
            },
        ],
    },
    AppParams: {
        type: 'op-grouping',
        name: 'AppParams',
        ops: {
            appApprovalProgram: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppApprovalProgram'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            appClearStateProgram: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppClearStateProgram'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            appGlobalNumUint: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppGlobalNumUint'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            appGlobalNumByteSlice: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppGlobalNumByteSlice'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            appLocalNumUint: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppLocalNumUint'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            appLocalNumByteSlice: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppLocalNumByteSlice'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            appExtraProgramPages: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppExtraProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            appCreator: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppCreator'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
            appAddress: {
                type: 'op-mapping',
                op: 'app_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AppAddress'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
        },
    },
    arg: {
        type: 'op-mapping',
        op: 'args',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [uint64PType] }], returnType: bytesPType },
        ],
    },
    AssetHolding: {
        type: 'op-grouping',
        name: 'AssetHolding',
        ops: {
            assetBalance: {
                type: 'op-mapping',
                op: 'asset_holding_get',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['AssetBalance'],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [assetPType, uint64PType] },
                        ],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            assetFrozen: {
                type: 'op-mapping',
                op: 'asset_holding_get',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['AssetFrozen'],
                        stackArgs: [
                            { name: 'a', ptypes: [accountPType, uint64PType] },
                            { name: 'b', ptypes: [assetPType, uint64PType] },
                        ],
                        returnType: new TuplePType({ items: [boolPType, boolPType] }),
                    },
                ],
            },
        },
    },
    AssetParams: {
        type: 'op-grouping',
        name: 'AssetParams',
        ops: {
            assetTotal: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetTotal'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            assetDecimals: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetDecimals'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            assetDefaultFrozen: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetDefaultFrozen'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [boolPType, boolPType] }),
                    },
                ],
            },
            assetUnitName: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetUnitName'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            assetName: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetName'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            assetUrl: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetURL'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            assetMetadataHash: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetMetadataHash'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            assetManager: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetManager'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
            assetReserve: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetReserve'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
            assetFreeze: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetFreeze'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
            assetClawback: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetClawback'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
            assetCreator: {
                type: 'op-mapping',
                op: 'asset_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetCreator'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: new TuplePType({ items: [accountPType, boolPType] }),
                    },
                ],
            },
        },
    },
    balance: {
        type: 'op-mapping',
        op: 'balance',
        signatures: [
            {
                argNames: ['a'],
                immediateArgs: [],
                stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                returnType: uint64PType,
            },
        ],
    },
    base64Decode: {
        type: 'op-mapping',
        op: 'base64_decode',
        signatures: [
            {
                argNames: ['e', 'a'],
                immediateArgs: [{ name: 'e', ptypes: [base64PType] }],
                stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                returnType: bytesPType,
            },
        ],
    },
    bitLength: {
        type: 'op-mapping',
        op: 'bitlen',
        signatures: [
            {
                argNames: ['a'],
                immediateArgs: [],
                stackArgs: [{ name: 'a', ptypes: [uint64PType, bytesPType] }],
                returnType: uint64PType,
            },
        ],
    },
    Block: {
        type: 'op-grouping',
        name: 'Block',
        ops: {
            blkSeed: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkSeed'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            blkTimestamp: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkTimestamp'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            blkProposer: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkProposer'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            blkFeesCollected: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkFeesCollected'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            blkBonus: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkBonus'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            blkBranch: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkBranch'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            blkFeeSink: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkFeeSink'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            blkProtocol: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkProtocol'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            blkTxnCounter: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkTxnCounter'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            blkProposerPayout: {
                type: 'op-mapping',
                op: 'block',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['BlkProposerPayout'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
        },
    },
    Box: {
        type: 'op-grouping',
        name: 'Box',
        ops: {
            create: {
                type: 'op-mapping',
                op: 'box_create',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: boolPType,
                    },
                ],
            },
            delete: {
                type: 'op-mapping',
                op: 'box_del',
                signatures: [
                    { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: boolPType },
                ],
            },
            extract: {
                type: 'op-mapping',
                op: 'box_extract',
                signatures: [
                    {
                        argNames: ['a', 'b', 'c'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [uint64PType] },
                            { name: 'c', ptypes: [uint64PType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            get: {
                type: 'op-mapping',
                op: 'box_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: [],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: new TuplePType({ items: [bytesPType, boolPType] }),
                    },
                ],
            },
            length: {
                type: 'op-mapping',
                op: 'box_len',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: [],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            put: {
                type: 'op-mapping',
                op: 'box_put',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
            replace: {
                type: 'op-mapping',
                op: 'box_replace',
                signatures: [
                    {
                        argNames: ['a', 'b', 'c'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [uint64PType] },
                            { name: 'c', ptypes: [bytesPType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
            resize: {
                type: 'op-mapping',
                op: 'box_resize',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
            splice: {
                type: 'op-mapping',
                op: 'box_splice',
                signatures: [
                    {
                        argNames: ['a', 'b', 'c', 'd'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [uint64PType] },
                            { name: 'c', ptypes: [uint64PType] },
                            { name: 'd', ptypes: [bytesPType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
        },
    },
    bsqrt: {
        type: 'op-mapping',
        op: 'bsqrt',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [biguintPType] }], returnType: biguintPType },
        ],
    },
    btoi: {
        type: 'op-mapping',
        op: 'btoi',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: uint64PType },
        ],
    },
    bzero: {
        type: 'op-mapping',
        op: 'bzero',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [uint64PType] }], returnType: bytesPType },
        ],
    },
    concat: {
        type: 'op-mapping',
        op: 'concat',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [bytesPType] },
                ],
                returnType: bytesPType,
            },
        ],
    },
    divmodw: {
        type: 'op-mapping',
        op: 'divmodw',
        signatures: [
            {
                argNames: ['a', 'b', 'c', 'd'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                    { name: 'd', ptypes: [uint64PType] },
                ],
                returnType: new TuplePType({ items: [uint64PType, uint64PType, uint64PType, uint64PType] }),
            },
        ],
    },
    divw: {
        type: 'op-mapping',
        op: 'divw',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    EllipticCurve: {
        type: 'op-grouping',
        name: 'EllipticCurve',
        ops: {
            add: {
                type: 'op-mapping',
                op: 'ec_add',
                signatures: [
                    {
                        argNames: ['g', 'a', 'b'],
                        immediateArgs: [{ name: 'g', ptypes: [ecPType] }],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            mapTo: {
                type: 'op-mapping',
                op: 'ec_map_to',
                signatures: [
                    {
                        argNames: ['g', 'a'],
                        immediateArgs: [{ name: 'g', ptypes: [ecPType] }],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            scalarMulMulti: {
                type: 'op-mapping',
                op: 'ec_multi_scalar_mul',
                signatures: [
                    {
                        argNames: ['g', 'a', 'b'],
                        immediateArgs: [{ name: 'g', ptypes: [ecPType] }],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            pairingCheck: {
                type: 'op-mapping',
                op: 'ec_pairing_check',
                signatures: [
                    {
                        argNames: ['g', 'a', 'b'],
                        immediateArgs: [{ name: 'g', ptypes: [ecPType] }],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: boolPType,
                    },
                ],
            },
            scalarMul: {
                type: 'op-mapping',
                op: 'ec_scalar_mul',
                signatures: [
                    {
                        argNames: ['g', 'a', 'b'],
                        immediateArgs: [{ name: 'g', ptypes: [ecPType] }],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            subgroupCheck: {
                type: 'op-mapping',
                op: 'ec_subgroup_check',
                signatures: [
                    {
                        argNames: ['g', 'a'],
                        immediateArgs: [{ name: 'g', ptypes: [ecPType] }],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: boolPType,
                    },
                ],
            },
        },
    },
    ecdsaPkDecompress: {
        type: 'op-mapping',
        op: 'ecdsa_pk_decompress',
        signatures: [
            {
                argNames: ['v', 'a'],
                immediateArgs: [{ name: 'v', ptypes: [ecdsaPType] }],
                stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                returnType: new TuplePType({ items: [bytesPType, bytesPType] }),
            },
        ],
    },
    ecdsaPkRecover: {
        type: 'op-mapping',
        op: 'ecdsa_pk_recover',
        signatures: [
            {
                argNames: ['v', 'a', 'b', 'c', 'd'],
                immediateArgs: [{ name: 'v', ptypes: [ecdsaPType] }],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [bytesPType] },
                    { name: 'd', ptypes: [bytesPType] },
                ],
                returnType: new TuplePType({ items: [bytesPType, bytesPType] }),
            },
        ],
    },
    ecdsaVerify: {
        type: 'op-mapping',
        op: 'ecdsa_verify',
        signatures: [
            {
                argNames: ['v', 'a', 'b', 'c', 'd', 'e'],
                immediateArgs: [{ name: 'v', ptypes: [ecdsaPType] }],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [bytesPType] },
                    { name: 'c', ptypes: [bytesPType] },
                    { name: 'd', ptypes: [bytesPType] },
                    { name: 'e', ptypes: [bytesPType] },
                ],
                returnType: boolPType,
            },
        ],
    },
    ed25519verify: {
        type: 'op-mapping',
        op: 'ed25519verify',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [bytesPType] },
                    { name: 'c', ptypes: [bytesPType] },
                ],
                returnType: boolPType,
            },
        ],
    },
    ed25519verifyBare: {
        type: 'op-mapping',
        op: 'ed25519verify_bare',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [bytesPType] },
                    { name: 'c', ptypes: [bytesPType] },
                ],
                returnType: boolPType,
            },
        ],
    },
    exp: {
        type: 'op-mapping',
        op: 'exp',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    expw: {
        type: 'op-mapping',
        op: 'expw',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: new TuplePType({ items: [uint64PType, uint64PType] }),
            },
        ],
    },
    extractUint16: {
        type: 'op-mapping',
        op: 'extract_uint16',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    extractUint32: {
        type: 'op-mapping',
        op: 'extract_uint32',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    extractUint64: {
        type: 'op-mapping',
        op: 'extract_uint64',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    falconVerify: {
        type: 'op-mapping',
        op: 'falcon_verify',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [bytesPType] },
                    { name: 'c', ptypes: [bytesPType] },
                ],
                returnType: boolPType,
            },
        ],
    },
    gaid: {
        type: 'op-mapping',
        op: 'gaids',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [uint64PType] }], returnType: uint64PType },
        ],
    },
    getBit: {
        type: 'op-mapping',
        op: 'getbit',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType, bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    getByte: {
        type: 'op-mapping',
        op: 'getbyte',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    GITxn: {
        type: 'op-grouping',
        name: 'GITxn',
        ops: {
            sender: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Sender'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            fee: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Fee'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            firstValid: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'FirstValid'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            firstValidTime: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'FirstValidTime'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            lastValid: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'LastValid'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            note: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Note'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            lease: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Lease'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            receiver: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Receiver'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            amount: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Amount'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            closeRemainderTo: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'CloseRemainderTo'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            votePk: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'VotePK'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            selectionPk: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'SelectionPK'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            voteFirst: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'VoteFirst'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            voteLast: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'VoteLast'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            voteKeyDilution: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'VoteKeyDilution'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            type: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Type'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            typeEnum: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'TypeEnum'],
                        stackArgs: [],
                        returnType: transactionTypeType.memberType,
                    },
                ],
            },
            xferAsset: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'XferAsset'],
                        stackArgs: [],
                        returnType: assetPType,
                    },
                ],
            },
            assetAmount: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'AssetAmount'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            assetSender: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'AssetSender'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            assetReceiver: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'AssetReceiver'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            assetCloseTo: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'AssetCloseTo'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            groupIndex: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'GroupIndex'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            txId: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'TxID'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            applicationId: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ApplicationID'],
                        stackArgs: [],
                        returnType: applicationPType,
                    },
                ],
            },
            onCompletion: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'OnCompletion'],
                        stackArgs: [],
                        returnType: onCompleteActionType.memberType,
                    },
                ],
            },
            applicationArgs: {
                type: 'op-mapping',
                op: 'gitxnas',
                signatures: [
                    {
                        argNames: ['t', 'a'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ApplicationArgs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numAppArgs: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'NumAppArgs'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            accounts: {
                type: 'op-mapping',
                op: 'gitxnas',
                signatures: [
                    {
                        argNames: ['t', 'a'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Accounts'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            numAccounts: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'NumAccounts'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            approvalProgram: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ApprovalProgram'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            clearStateProgram: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ClearStateProgram'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            rekeyTo: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'RekeyTo'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            configAsset: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAsset'],
                        stackArgs: [],
                        returnType: assetPType,
                    },
                ],
            },
            configAssetTotal: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetTotal'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            configAssetDecimals: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetDecimals'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            configAssetDefaultFrozen: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetDefaultFrozen'],
                        stackArgs: [],
                        returnType: boolPType,
                    },
                ],
            },
            configAssetUnitName: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetUnitName'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetName: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetName'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetUrl: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetURL'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetMetadataHash: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetMetadataHash'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetManager: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetManager'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            configAssetReserve: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetReserve'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            configAssetFreeze: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetFreeze'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            configAssetClawback: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ConfigAssetClawback'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            freezeAsset: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'FreezeAsset'],
                        stackArgs: [],
                        returnType: assetPType,
                    },
                ],
            },
            freezeAssetAccount: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'FreezeAssetAccount'],
                        stackArgs: [],
                        returnType: accountPType,
                    },
                ],
            },
            freezeAssetFrozen: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'FreezeAssetFrozen'],
                        stackArgs: [],
                        returnType: boolPType,
                    },
                ],
            },
            assets: {
                type: 'op-mapping',
                op: 'gitxnas',
                signatures: [
                    {
                        argNames: ['t', 'a'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Assets'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: assetPType,
                    },
                ],
            },
            numAssets: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'NumAssets'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            applications: {
                type: 'op-mapping',
                op: 'gitxnas',
                signatures: [
                    {
                        argNames: ['t', 'a'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Applications'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: applicationPType,
                    },
                ],
            },
            numApplications: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'NumApplications'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            globalNumUint: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'GlobalNumUint'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            globalNumByteSlice: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'GlobalNumByteSlice'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            localNumUint: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'LocalNumUint'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            localNumByteSlice: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'LocalNumByteSlice'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            extraProgramPages: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ExtraProgramPages'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            nonparticipation: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Nonparticipation'],
                        stackArgs: [],
                        returnType: boolPType,
                    },
                ],
            },
            logs: {
                type: 'op-mapping',
                op: 'gitxnas',
                signatures: [
                    {
                        argNames: ['t', 'a'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'Logs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numLogs: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'NumLogs'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            createdAssetId: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'CreatedAssetID'],
                        stackArgs: [],
                        returnType: assetPType,
                    },
                ],
            },
            createdApplicationId: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'CreatedApplicationID'],
                        stackArgs: [],
                        returnType: applicationPType,
                    },
                ],
            },
            lastLog: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'LastLog'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            stateProofPk: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'StateProofPK'],
                        stackArgs: [],
                        returnType: bytesPType,
                    },
                ],
            },
            approvalProgramPages: {
                type: 'op-mapping',
                op: 'gitxnas',
                signatures: [
                    {
                        argNames: ['t', 'a'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ApprovalProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numApprovalProgramPages: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'NumApprovalProgramPages'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
            clearStateProgramPages: {
                type: 'op-mapping',
                op: 'gitxnas',
                signatures: [
                    {
                        argNames: ['t', 'a'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'ClearStateProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numClearStateProgramPages: {
                type: 'op-mapping',
                op: 'gitxn',
                signatures: [
                    {
                        argNames: ['t'],
                        immediateArgs: [{ name: 't', ptypes: [uint64PType] }, 'NumClearStateProgramPages'],
                        stackArgs: [],
                        returnType: uint64PType,
                    },
                ],
            },
        },
    },
    gloadBytes: {
        type: 'op-mapping',
        op: 'gloadss',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: bytesPType,
            },
        ],
    },
    gloadUint64: {
        type: 'op-mapping',
        op: 'gloadss',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    Global: {
        type: 'op-grouping',
        name: 'Global',
        ops: {
            minTxnFee: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['MinTxnFee'], stackArgs: [], returnType: uint64PType }],
            },
            minBalance: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['MinBalance'], stackArgs: [], returnType: uint64PType }],
            },
            maxTxnLife: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['MaxTxnLife'], stackArgs: [], returnType: uint64PType }],
            },
            zeroAddress: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['ZeroAddress'], stackArgs: [], returnType: accountPType }],
            },
            groupSize: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['GroupSize'], stackArgs: [], returnType: uint64PType }],
            },
            logicSigVersion: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['LogicSigVersion'], stackArgs: [], returnType: uint64PType }],
            },
            round: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['Round'], stackArgs: [], returnType: uint64PType }],
            },
            latestTimestamp: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['LatestTimestamp'], stackArgs: [], returnType: uint64PType }],
            },
            currentApplicationId: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['CurrentApplicationID'], stackArgs: [], returnType: applicationPType }],
            },
            creatorAddress: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['CreatorAddress'], stackArgs: [], returnType: accountPType }],
            },
            currentApplicationAddress: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['CurrentApplicationAddress'], stackArgs: [], returnType: accountPType }],
            },
            groupId: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['GroupID'], stackArgs: [], returnType: bytesPType }],
            },
            opcodeBudget: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['OpcodeBudget'], stackArgs: [], returnType: uint64PType }],
            },
            callerApplicationId: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['CallerApplicationID'], stackArgs: [], returnType: uint64PType }],
            },
            callerApplicationAddress: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['CallerApplicationAddress'], stackArgs: [], returnType: accountPType }],
            },
            assetCreateMinBalance: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['AssetCreateMinBalance'], stackArgs: [], returnType: uint64PType }],
            },
            assetOptInMinBalance: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['AssetOptInMinBalance'], stackArgs: [], returnType: uint64PType }],
            },
            genesisHash: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['GenesisHash'], stackArgs: [], returnType: bytesPType }],
            },
            payoutsEnabled: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['PayoutsEnabled'], stackArgs: [], returnType: boolPType }],
            },
            payoutsGoOnlineFee: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['PayoutsGoOnlineFee'], stackArgs: [], returnType: uint64PType }],
            },
            payoutsPercent: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['PayoutsPercent'], stackArgs: [], returnType: uint64PType }],
            },
            payoutsMinBalance: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['PayoutsMinBalance'], stackArgs: [], returnType: uint64PType }],
            },
            payoutsMaxBalance: {
                type: 'op-mapping',
                op: 'global',
                signatures: [{ argNames: [], immediateArgs: ['PayoutsMaxBalance'], stackArgs: [], returnType: uint64PType }],
            },
        },
    },
    GTxn: {
        type: 'op-grouping',
        name: 'GTxn',
        ops: {
            sender: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Sender'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            fee: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Fee'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            firstValid: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FirstValid'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            firstValidTime: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FirstValidTime'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            lastValid: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['LastValid'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            note: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Note'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            lease: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Lease'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            receiver: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Receiver'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            amount: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Amount'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            closeRemainderTo: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['CloseRemainderTo'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            votePk: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VotePK'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            selectionPk: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['SelectionPK'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            voteFirst: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoteFirst'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            voteLast: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoteLast'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            voteKeyDilution: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoteKeyDilution'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            type: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Type'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            typeEnum: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['TypeEnum'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: transactionTypeType.memberType,
                    },
                ],
            },
            xferAsset: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['XferAsset'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: assetPType,
                    },
                ],
            },
            assetAmount: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetAmount'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            assetSender: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetSender'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            assetReceiver: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetReceiver'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            assetCloseTo: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetCloseTo'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            groupIndex: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['GroupIndex'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            txId: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['TxID'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            applicationId: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApplicationID'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: applicationPType,
                    },
                ],
            },
            onCompletion: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['OnCompletion'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: onCompleteActionType.memberType,
                    },
                ],
            },
            applicationArgs: {
                type: 'op-mapping',
                op: 'gtxnsas',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['ApplicationArgs'],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            numAppArgs: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['NumAppArgs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            accounts: {
                type: 'op-mapping',
                op: 'gtxnsas',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['Accounts'],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: accountPType,
                    },
                ],
            },
            numAccounts: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['NumAccounts'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            approvalProgram: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApprovalProgram'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            clearStateProgram: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ClearStateProgram'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            rekeyTo: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['RekeyTo'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            configAsset: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAsset'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: assetPType,
                    },
                ],
            },
            configAssetTotal: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetTotal'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            configAssetDecimals: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetDecimals'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            configAssetDefaultFrozen: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetDefaultFrozen'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: boolPType,
                    },
                ],
            },
            configAssetUnitName: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetUnitName'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetName: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetName'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetUrl: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetURL'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetMetadataHash: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetMetadataHash'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            configAssetManager: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetManager'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            configAssetReserve: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetReserve'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            configAssetFreeze: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetFreeze'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            configAssetClawback: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetClawback'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            freezeAsset: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FreezeAsset'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: assetPType,
                    },
                ],
            },
            freezeAssetAccount: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FreezeAssetAccount'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            freezeAssetFrozen: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FreezeAssetFrozen'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: boolPType,
                    },
                ],
            },
            assets: {
                type: 'op-mapping',
                op: 'gtxnsas',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['Assets'],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: assetPType,
                    },
                ],
            },
            numAssets: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['NumAssets'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            applications: {
                type: 'op-mapping',
                op: 'gtxnsas',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['Applications'],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: applicationPType,
                    },
                ],
            },
            numApplications: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['NumApplications'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            globalNumUint: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['GlobalNumUint'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            globalNumByteSlice: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['GlobalNumByteSlice'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            localNumUint: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['LocalNumUint'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            localNumByteSlice: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['LocalNumByteSlice'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            extraProgramPages: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ExtraProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            nonparticipation: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Nonparticipation'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: boolPType,
                    },
                ],
            },
            logs: {
                type: 'op-mapping',
                op: 'gtxnsas',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['Logs'],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            numLogs: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['NumLogs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            createdAssetId: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['CreatedAssetID'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: assetPType,
                    },
                ],
            },
            createdApplicationId: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['CreatedApplicationID'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: applicationPType,
                    },
                ],
            },
            lastLog: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['LastLog'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            stateProofPk: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['StateProofPK'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            approvalProgramPages: {
                type: 'op-mapping',
                op: 'gtxnsas',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['ApprovalProgramPages'],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            numApprovalProgramPages: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['NumApprovalProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
            clearStateProgramPages: {
                type: 'op-mapping',
                op: 'gtxnsas',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['ClearStateProgramPages'],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            numClearStateProgramPages: {
                type: 'op-mapping',
                op: 'gtxns',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['NumClearStateProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: uint64PType,
                    },
                ],
            },
        },
    },
    itob: {
        type: 'op-mapping',
        op: 'itob',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [uint64PType] }], returnType: bytesPType },
        ],
    },
    ITxn: {
        type: 'op-grouping',
        name: 'ITxn',
        ops: {
            sender: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Sender'], stackArgs: [], returnType: accountPType }],
            },
            fee: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Fee'], stackArgs: [], returnType: uint64PType }],
            },
            firstValid: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['FirstValid'], stackArgs: [], returnType: uint64PType }],
            },
            firstValidTime: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['FirstValidTime'], stackArgs: [], returnType: uint64PType }],
            },
            lastValid: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['LastValid'], stackArgs: [], returnType: uint64PType }],
            },
            note: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Note'], stackArgs: [], returnType: bytesPType }],
            },
            lease: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Lease'], stackArgs: [], returnType: bytesPType }],
            },
            receiver: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Receiver'], stackArgs: [], returnType: accountPType }],
            },
            amount: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Amount'], stackArgs: [], returnType: uint64PType }],
            },
            closeRemainderTo: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['CloseRemainderTo'], stackArgs: [], returnType: accountPType }],
            },
            votePk: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['VotePK'], stackArgs: [], returnType: bytesPType }],
            },
            selectionPk: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['SelectionPK'], stackArgs: [], returnType: bytesPType }],
            },
            voteFirst: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['VoteFirst'], stackArgs: [], returnType: uint64PType }],
            },
            voteLast: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['VoteLast'], stackArgs: [], returnType: uint64PType }],
            },
            voteKeyDilution: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['VoteKeyDilution'], stackArgs: [], returnType: uint64PType }],
            },
            type: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Type'], stackArgs: [], returnType: bytesPType }],
            },
            typeEnum: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['TypeEnum'], stackArgs: [], returnType: transactionTypeType.memberType }],
            },
            xferAsset: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['XferAsset'], stackArgs: [], returnType: assetPType }],
            },
            assetAmount: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['AssetAmount'], stackArgs: [], returnType: uint64PType }],
            },
            assetSender: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['AssetSender'], stackArgs: [], returnType: accountPType }],
            },
            assetReceiver: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['AssetReceiver'], stackArgs: [], returnType: accountPType }],
            },
            assetCloseTo: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['AssetCloseTo'], stackArgs: [], returnType: accountPType }],
            },
            groupIndex: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['GroupIndex'], stackArgs: [], returnType: uint64PType }],
            },
            txId: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['TxID'], stackArgs: [], returnType: bytesPType }],
            },
            applicationId: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ApplicationID'], stackArgs: [], returnType: applicationPType }],
            },
            onCompletion: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['OnCompletion'], stackArgs: [], returnType: onCompleteActionType.memberType }],
            },
            applicationArgs: {
                type: 'op-mapping',
                op: 'itxnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApplicationArgs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numAppArgs: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['NumAppArgs'], stackArgs: [], returnType: uint64PType }],
            },
            accounts: {
                type: 'op-mapping',
                op: 'itxnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Accounts'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            numAccounts: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['NumAccounts'], stackArgs: [], returnType: uint64PType }],
            },
            approvalProgram: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ApprovalProgram'], stackArgs: [], returnType: bytesPType }],
            },
            clearStateProgram: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ClearStateProgram'], stackArgs: [], returnType: bytesPType }],
            },
            rekeyTo: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['RekeyTo'], stackArgs: [], returnType: accountPType }],
            },
            configAsset: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAsset'], stackArgs: [], returnType: assetPType }],
            },
            configAssetTotal: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetTotal'], stackArgs: [], returnType: uint64PType }],
            },
            configAssetDecimals: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetDecimals'], stackArgs: [], returnType: uint64PType }],
            },
            configAssetDefaultFrozen: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetDefaultFrozen'], stackArgs: [], returnType: boolPType }],
            },
            configAssetUnitName: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetUnitName'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetName: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetName'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetUrl: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetURL'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetMetadataHash: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetMetadataHash'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetManager: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetManager'], stackArgs: [], returnType: accountPType }],
            },
            configAssetReserve: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetReserve'], stackArgs: [], returnType: accountPType }],
            },
            configAssetFreeze: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetFreeze'], stackArgs: [], returnType: accountPType }],
            },
            configAssetClawback: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetClawback'], stackArgs: [], returnType: accountPType }],
            },
            freezeAsset: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['FreezeAsset'], stackArgs: [], returnType: assetPType }],
            },
            freezeAssetAccount: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['FreezeAssetAccount'], stackArgs: [], returnType: accountPType }],
            },
            freezeAssetFrozen: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['FreezeAssetFrozen'], stackArgs: [], returnType: boolPType }],
            },
            assets: {
                type: 'op-mapping',
                op: 'itxnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Assets'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: assetPType,
                    },
                ],
            },
            numAssets: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['NumAssets'], stackArgs: [], returnType: uint64PType }],
            },
            applications: {
                type: 'op-mapping',
                op: 'itxnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Applications'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: applicationPType,
                    },
                ],
            },
            numApplications: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['NumApplications'], stackArgs: [], returnType: uint64PType }],
            },
            globalNumUint: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['GlobalNumUint'], stackArgs: [], returnType: uint64PType }],
            },
            globalNumByteSlice: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['GlobalNumByteSlice'], stackArgs: [], returnType: uint64PType }],
            },
            localNumUint: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['LocalNumUint'], stackArgs: [], returnType: uint64PType }],
            },
            localNumByteSlice: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['LocalNumByteSlice'], stackArgs: [], returnType: uint64PType }],
            },
            extraProgramPages: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['ExtraProgramPages'], stackArgs: [], returnType: uint64PType }],
            },
            nonparticipation: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['Nonparticipation'], stackArgs: [], returnType: boolPType }],
            },
            logs: {
                type: 'op-mapping',
                op: 'itxnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Logs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numLogs: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['NumLogs'], stackArgs: [], returnType: uint64PType }],
            },
            createdAssetId: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['CreatedAssetID'], stackArgs: [], returnType: assetPType }],
            },
            createdApplicationId: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['CreatedApplicationID'], stackArgs: [], returnType: applicationPType }],
            },
            lastLog: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['LastLog'], stackArgs: [], returnType: bytesPType }],
            },
            stateProofPk: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['StateProofPK'], stackArgs: [], returnType: bytesPType }],
            },
            approvalProgramPages: {
                type: 'op-mapping',
                op: 'itxnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApprovalProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numApprovalProgramPages: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['NumApprovalProgramPages'], stackArgs: [], returnType: uint64PType }],
            },
            clearStateProgramPages: {
                type: 'op-mapping',
                op: 'itxnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ClearStateProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numClearStateProgramPages: {
                type: 'op-mapping',
                op: 'itxn',
                signatures: [{ argNames: [], immediateArgs: ['NumClearStateProgramPages'], stackArgs: [], returnType: uint64PType }],
            },
        },
    },
    ITxnCreate: {
        type: 'op-grouping',
        name: 'ITxnCreate',
        ops: {
            begin: {
                type: 'op-mapping',
                op: 'itxn_begin',
                signatures: [{ argNames: [], immediateArgs: [], stackArgs: [], returnType: voidPType }],
            },
            setSender: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Sender'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setFee: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Fee'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setNote: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Note'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setReceiver: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Receiver'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setAmount: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Amount'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setCloseRemainderTo: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['CloseRemainderTo'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setVotePk: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VotePK'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setSelectionPk: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['SelectionPK'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setVoteFirst: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoteFirst'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setVoteLast: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoteLast'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setVoteKeyDilution: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoteKeyDilution'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setType: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Type'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setTypeEnum: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['TypeEnum'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setXferAsset: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['XferAsset'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setAssetAmount: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetAmount'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setAssetSender: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetSender'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setAssetReceiver: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetReceiver'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setAssetCloseTo: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['AssetCloseTo'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setApplicationId: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApplicationID'],
                        stackArgs: [{ name: 'a', ptypes: [applicationPType, uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setOnCompletion: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['OnCompletion'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setApplicationArgs: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApplicationArgs'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setAccounts: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Accounts'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setApprovalProgram: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApprovalProgram'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setClearStateProgram: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ClearStateProgram'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setRekeyTo: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['RekeyTo'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAsset: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAsset'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetTotal: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetTotal'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetDecimals: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetDecimals'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetDefaultFrozen: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetDefaultFrozen'],
                        stackArgs: [{ name: 'a', ptypes: [boolPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetUnitName: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetUnitName'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetName: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetName'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetUrl: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetURL'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetMetadataHash: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetMetadataHash'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetManager: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetManager'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetReserve: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetReserve'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetFreeze: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetFreeze'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setConfigAssetClawback: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ConfigAssetClawback'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setFreezeAsset: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FreezeAsset'],
                        stackArgs: [{ name: 'a', ptypes: [assetPType, uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setFreezeAssetAccount: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FreezeAssetAccount'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setFreezeAssetFrozen: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['FreezeAssetFrozen'],
                        stackArgs: [{ name: 'a', ptypes: [boolPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setAssets: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Assets'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setApplications: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Applications'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setGlobalNumUint: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['GlobalNumUint'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setGlobalNumByteSlice: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['GlobalNumByteSlice'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setLocalNumUint: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['LocalNumUint'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setLocalNumByteSlice: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['LocalNumByteSlice'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setExtraProgramPages: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ExtraProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setNonparticipation: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Nonparticipation'],
                        stackArgs: [{ name: 'a', ptypes: [boolPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setStateProofPk: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['StateProofPK'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setApprovalProgramPages: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApprovalProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            setClearStateProgramPages: {
                type: 'op-mapping',
                op: 'itxn_field',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ClearStateProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                        returnType: voidPType,
                    },
                ],
            },
            next: {
                type: 'op-mapping',
                op: 'itxn_next',
                signatures: [{ argNames: [], immediateArgs: [], stackArgs: [], returnType: voidPType }],
            },
            submit: {
                type: 'op-mapping',
                op: 'itxn_submit',
                signatures: [{ argNames: [], immediateArgs: [], stackArgs: [], returnType: voidPType }],
            },
        },
    },
    JsonRef: {
        type: 'op-grouping',
        name: 'JsonRef',
        ops: {
            jsonString: {
                type: 'op-mapping',
                op: 'json_ref',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['JSONString'],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
            jsonUint64: {
                type: 'op-mapping',
                op: 'json_ref',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['JSONUint64'],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: uint64PType,
                    },
                ],
            },
            jsonObject: {
                type: 'op-mapping',
                op: 'json_ref',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: ['JSONObject'],
                        stackArgs: [
                            { name: 'a', ptypes: [bytesPType] },
                            { name: 'b', ptypes: [bytesPType] },
                        ],
                        returnType: bytesPType,
                    },
                ],
            },
        },
    },
    keccak256: {
        type: 'op-mapping',
        op: 'keccak256',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: bytesPType },
        ],
    },
    len: {
        type: 'op-mapping',
        op: 'len',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: uint64PType },
        ],
    },
    Scratch: {
        type: 'op-grouping',
        name: 'Scratch',
        ops: {
            loadBytes: {
                type: 'op-mapping',
                op: 'loads',
                signatures: [
                    { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [uint64PType] }], returnType: bytesPType },
                ],
            },
            loadUint64: {
                type: 'op-mapping',
                op: 'loads',
                signatures: [
                    { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [uint64PType] }], returnType: uint64PType },
                ],
            },
            store: {
                type: 'op-mapping',
                op: 'stores',
                signatures: [
                    {
                        argNames: ['a', 'b'],
                        immediateArgs: [],
                        stackArgs: [
                            { name: 'a', ptypes: [uint64PType] },
                            { name: 'b', ptypes: [uint64PType, bytesPType] },
                        ],
                        returnType: voidPType,
                    },
                ],
            },
        },
    },
    mimc: {
        type: 'op-mapping',
        op: 'mimc',
        signatures: [
            {
                argNames: ['c', 'a'],
                immediateArgs: [{ name: 'c', ptypes: [mimcConfigurationsPType] }],
                stackArgs: [{ name: 'a', ptypes: [bytesPType] }],
                returnType: bytesPType,
            },
        ],
    },
    minBalance: {
        type: 'op-mapping',
        op: 'min_balance',
        signatures: [
            {
                argNames: ['a'],
                immediateArgs: [],
                stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                returnType: uint64PType,
            },
        ],
    },
    mulw: {
        type: 'op-mapping',
        op: 'mulw',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: new TuplePType({ items: [uint64PType, uint64PType] }),
            },
        ],
    },
    onlineStake: {
        type: 'op-mapping',
        op: 'online_stake',
        signatures: [{ argNames: [], immediateArgs: [], stackArgs: [], returnType: uint64PType }],
    },
    replace: {
        type: 'op-mapping',
        op: 'replace3',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [bytesPType] },
                ],
                returnType: bytesPType,
            },
        ],
    },
    setByte: {
        type: 'op-mapping',
        op: 'setbyte',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: bytesPType,
            },
        ],
    },
    sha256: {
        type: 'op-mapping',
        op: 'sha256',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: bytesPType },
        ],
    },
    sha3_256: {
        type: 'op-mapping',
        op: 'sha3_256',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: bytesPType },
        ],
    },
    sha512_256: {
        type: 'op-mapping',
        op: 'sha512_256',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: bytesPType },
        ],
    },
    shl: {
        type: 'op-mapping',
        op: 'shl',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    shr: {
        type: 'op-mapping',
        op: 'shr',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    sqrt: {
        type: 'op-mapping',
        op: 'sqrt',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [uint64PType] }], returnType: uint64PType },
        ],
    },
    substring: {
        type: 'op-mapping',
        op: 'substring3',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: bytesPType,
            },
        ],
    },
    sumhash512: {
        type: 'op-mapping',
        op: 'sumhash512',
        signatures: [
            { argNames: ['a'], immediateArgs: [], stackArgs: [{ name: 'a', ptypes: [bytesPType] }], returnType: bytesPType },
        ],
    },
    Txn: {
        type: 'op-grouping',
        name: 'Txn',
        ops: {
            sender: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Sender'], stackArgs: [], returnType: accountPType }],
            },
            fee: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Fee'], stackArgs: [], returnType: uint64PType }],
            },
            firstValid: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['FirstValid'], stackArgs: [], returnType: uint64PType }],
            },
            firstValidTime: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['FirstValidTime'], stackArgs: [], returnType: uint64PType }],
            },
            lastValid: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['LastValid'], stackArgs: [], returnType: uint64PType }],
            },
            note: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Note'], stackArgs: [], returnType: bytesPType }],
            },
            lease: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Lease'], stackArgs: [], returnType: bytesPType }],
            },
            receiver: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Receiver'], stackArgs: [], returnType: accountPType }],
            },
            amount: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Amount'], stackArgs: [], returnType: uint64PType }],
            },
            closeRemainderTo: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['CloseRemainderTo'], stackArgs: [], returnType: accountPType }],
            },
            votePk: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['VotePK'], stackArgs: [], returnType: bytesPType }],
            },
            selectionPk: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['SelectionPK'], stackArgs: [], returnType: bytesPType }],
            },
            voteFirst: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['VoteFirst'], stackArgs: [], returnType: uint64PType }],
            },
            voteLast: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['VoteLast'], stackArgs: [], returnType: uint64PType }],
            },
            voteKeyDilution: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['VoteKeyDilution'], stackArgs: [], returnType: uint64PType }],
            },
            type: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Type'], stackArgs: [], returnType: bytesPType }],
            },
            typeEnum: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['TypeEnum'], stackArgs: [], returnType: transactionTypeType.memberType }],
            },
            xferAsset: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['XferAsset'], stackArgs: [], returnType: assetPType }],
            },
            assetAmount: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['AssetAmount'], stackArgs: [], returnType: uint64PType }],
            },
            assetSender: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['AssetSender'], stackArgs: [], returnType: accountPType }],
            },
            assetReceiver: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['AssetReceiver'], stackArgs: [], returnType: accountPType }],
            },
            assetCloseTo: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['AssetCloseTo'], stackArgs: [], returnType: accountPType }],
            },
            groupIndex: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['GroupIndex'], stackArgs: [], returnType: uint64PType }],
            },
            txId: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['TxID'], stackArgs: [], returnType: bytesPType }],
            },
            applicationId: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ApplicationID'], stackArgs: [], returnType: applicationPType }],
            },
            onCompletion: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['OnCompletion'], stackArgs: [], returnType: onCompleteActionType.memberType }],
            },
            applicationArgs: {
                type: 'op-mapping',
                op: 'txnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApplicationArgs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numAppArgs: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['NumAppArgs'], stackArgs: [], returnType: uint64PType }],
            },
            accounts: {
                type: 'op-mapping',
                op: 'txnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Accounts'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: accountPType,
                    },
                ],
            },
            numAccounts: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['NumAccounts'], stackArgs: [], returnType: uint64PType }],
            },
            approvalProgram: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ApprovalProgram'], stackArgs: [], returnType: bytesPType }],
            },
            clearStateProgram: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ClearStateProgram'], stackArgs: [], returnType: bytesPType }],
            },
            rekeyTo: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['RekeyTo'], stackArgs: [], returnType: accountPType }],
            },
            configAsset: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAsset'], stackArgs: [], returnType: assetPType }],
            },
            configAssetTotal: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetTotal'], stackArgs: [], returnType: uint64PType }],
            },
            configAssetDecimals: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetDecimals'], stackArgs: [], returnType: uint64PType }],
            },
            configAssetDefaultFrozen: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetDefaultFrozen'], stackArgs: [], returnType: boolPType }],
            },
            configAssetUnitName: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetUnitName'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetName: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetName'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetUrl: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetURL'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetMetadataHash: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetMetadataHash'], stackArgs: [], returnType: bytesPType }],
            },
            configAssetManager: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetManager'], stackArgs: [], returnType: accountPType }],
            },
            configAssetReserve: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetReserve'], stackArgs: [], returnType: accountPType }],
            },
            configAssetFreeze: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetFreeze'], stackArgs: [], returnType: accountPType }],
            },
            configAssetClawback: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ConfigAssetClawback'], stackArgs: [], returnType: accountPType }],
            },
            freezeAsset: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['FreezeAsset'], stackArgs: [], returnType: assetPType }],
            },
            freezeAssetAccount: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['FreezeAssetAccount'], stackArgs: [], returnType: accountPType }],
            },
            freezeAssetFrozen: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['FreezeAssetFrozen'], stackArgs: [], returnType: boolPType }],
            },
            assets: {
                type: 'op-mapping',
                op: 'txnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Assets'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: assetPType,
                    },
                ],
            },
            numAssets: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['NumAssets'], stackArgs: [], returnType: uint64PType }],
            },
            applications: {
                type: 'op-mapping',
                op: 'txnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Applications'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: applicationPType,
                    },
                ],
            },
            numApplications: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['NumApplications'], stackArgs: [], returnType: uint64PType }],
            },
            globalNumUint: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['GlobalNumUint'], stackArgs: [], returnType: uint64PType }],
            },
            globalNumByteSlice: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['GlobalNumByteSlice'], stackArgs: [], returnType: uint64PType }],
            },
            localNumUint: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['LocalNumUint'], stackArgs: [], returnType: uint64PType }],
            },
            localNumByteSlice: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['LocalNumByteSlice'], stackArgs: [], returnType: uint64PType }],
            },
            extraProgramPages: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['ExtraProgramPages'], stackArgs: [], returnType: uint64PType }],
            },
            nonparticipation: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['Nonparticipation'], stackArgs: [], returnType: boolPType }],
            },
            logs: {
                type: 'op-mapping',
                op: 'txnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['Logs'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numLogs: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['NumLogs'], stackArgs: [], returnType: uint64PType }],
            },
            createdAssetId: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['CreatedAssetID'], stackArgs: [], returnType: assetPType }],
            },
            createdApplicationId: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['CreatedApplicationID'], stackArgs: [], returnType: applicationPType }],
            },
            lastLog: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['LastLog'], stackArgs: [], returnType: bytesPType }],
            },
            stateProofPk: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['StateProofPK'], stackArgs: [], returnType: bytesPType }],
            },
            approvalProgramPages: {
                type: 'op-mapping',
                op: 'txnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ApprovalProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numApprovalProgramPages: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['NumApprovalProgramPages'], stackArgs: [], returnType: uint64PType }],
            },
            clearStateProgramPages: {
                type: 'op-mapping',
                op: 'txnas',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['ClearStateProgramPages'],
                        stackArgs: [{ name: 'a', ptypes: [uint64PType] }],
                        returnType: bytesPType,
                    },
                ],
            },
            numClearStateProgramPages: {
                type: 'op-mapping',
                op: 'txn',
                signatures: [{ argNames: [], immediateArgs: ['NumClearStateProgramPages'], stackArgs: [], returnType: uint64PType }],
            },
        },
    },
    VoterParams: {
        type: 'op-grouping',
        name: 'VoterParams',
        ops: {
            voterBalance: {
                type: 'op-mapping',
                op: 'voter_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoterBalance'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [uint64PType, boolPType] }),
                    },
                ],
            },
            voterIncentiveEligible: {
                type: 'op-mapping',
                op: 'voter_params_get',
                signatures: [
                    {
                        argNames: ['a'],
                        immediateArgs: ['VoterIncentiveEligible'],
                        stackArgs: [{ name: 'a', ptypes: [accountPType, uint64PType] }],
                        returnType: new TuplePType({ items: [boolPType, boolPType] }),
                    },
                ],
            },
        },
    },
    vrfVerify: {
        type: 'op-mapping',
        op: 'vrf_verify',
        signatures: [
            {
                argNames: ['s', 'a', 'b', 'c'],
                immediateArgs: [{ name: 's', ptypes: [vrfVerifyPType] }],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [bytesPType] },
                    { name: 'c', ptypes: [bytesPType] },
                ],
                returnType: new TuplePType({ items: [bytesPType, boolPType] }),
            },
        ],
    },
    extract: {
        type: 'op-mapping',
        op: 'extract3',
        signatures: [
            {
                argNames: ['a', 'b'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                ],
                returnType: bytesPType,
            },
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: bytesPType,
            },
        ],
    },
    select: {
        type: 'op-mapping',
        op: 'select',
        signatures: [
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [bytesPType] },
                    { name: 'b', ptypes: [bytesPType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: bytesPType,
            },
            {
                argNames: ['a', 'b', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'a', ptypes: [uint64PType] },
                    { name: 'b', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
    setBit: {
        type: 'op-mapping',
        op: 'setbit',
        signatures: [
            {
                argNames: ['target', 'n', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'target', ptypes: [bytesPType] },
                    { name: 'n', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: bytesPType,
            },
            {
                argNames: ['target', 'n', 'c'],
                immediateArgs: [],
                stackArgs: [
                    { name: 'target', ptypes: [uint64PType] },
                    { name: 'n', ptypes: [uint64PType] },
                    { name: 'c', ptypes: [uint64PType] },
                ],
                returnType: uint64PType,
            },
        ],
    },
};

class IntrinsicOpGroupBuilder extends NodeBuilder {
    opGrouping;
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof IntrinsicFunctionGroupType, 'ptype must be IntrinsicFunctionGroupType');
        this.ptype = ptype;
        const metaData = OP_METADATA[ptype.name];
        invariant(metaData.type === 'op-grouping', 'ptype must map to op-grouping');
        this.opGrouping = metaData;
    }
    hasProperty(name) {
        return Object.hasOwn(this.opGrouping.ops, name);
    }
    memberAccess(name, sourceLocation) {
        if (!Object.hasOwn(this.opGrouping.ops, name)) {
            return super.memberAccess(name, sourceLocation);
        }
        const metaData = this.opGrouping.ops[name];
        if (metaData.signatures.some((s) => s.argNames.length || s.returnType.equals(voidPType))) {
            return new GroupedIntrinsicOpBuilder(sourceLocation, metaData);
        }
        const [sig] = metaData.signatures;
        return typeRegistry.getInstanceEb(nodeFactory.intrinsicCall({
            wtype: sig.returnType.wtypeOrThrow,
            opCode: metaData.op,
            sourceLocation: sourceLocation,
            stackArgs: sig.stackArgs.map((x) => {
                if (x instanceof Expression) {
                    return x;
                }
                throw new InternalError('Intrinsic property expression cannot have unresolved arguments', { sourceLocation });
            }),
            immediates: sig.immediateArgs.map((x) => {
                switch (typeof x) {
                    case 'string':
                    case 'bigint':
                        return x;
                    default:
                        throw new InternalError('Intrinsic property expression cannot have unresolved arguments', { sourceLocation });
                }
            }),
        }), sig.returnType);
    }
}
class IntrinsicOpBuilderBase extends FunctionBuilder {
    opMapping;
    constructor(sourceLocation, opMapping) {
        super(sourceLocation);
        this.opMapping = opMapping;
    }
    /**
     * Extract with 2 args extracts to the end of the sequence, the exact op code depends on if the start index is a constant value or not
     * @param args
     * @param typeArgs
     * @param sourceLocation
     */
    handleExtract(args, typeArgs, sourceLocation) {
        const { args: [target, start, end], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'extract',
            callLocation: sourceLocation,
            argSpec: (a) => [a.required(bytesPType), a.required(uint64PType), a.optional(uint64PType)],
        });
        if (end) {
            const endExpr = end.resolve();
            codeInvariant(!(endExpr instanceof IntegerConstant && endExpr.value === 0n), 'Extract with length=0 will always return an empty byte array. Omit length parameter to extract to the end of the sequence.');
            return instanceEb(nodeFactory.intrinsicCall({
                opCode: 'extract3',
                immediates: [],
                stackArgs: [target.resolve(), start.resolve(), endExpr],
                wtype: bytesPType.wtype,
                sourceLocation,
            }), bytesPType);
        }
        const startExpr = start.resolve();
        if (startExpr instanceof IntegerConstant) {
            // Use immediate version of extract
            return instanceEb(nodeFactory.intrinsicCall({
                opCode: 'extract',
                immediates: [startExpr.value, 0n],
                stackArgs: [target.resolve()],
                wtype: bytesPType.wtype,
                sourceLocation,
            }), bytesPType);
        }
        else {
            const targetExpr = target.singleEvaluation().resolve();
            const startExpr = start.singleEvaluation().resolve();
            return instanceEb(nodeFactory.intrinsicCall({
                opCode: 'extract3',
                immediates: [],
                stackArgs: [
                    targetExpr,
                    startExpr,
                    nodeFactory.uInt64BinaryOperation({
                        op: UInt64BinaryOperator.sub,
                        sourceLocation,
                        left: intrinsicFactory.bytesLen({ value: targetExpr, sourceLocation }),
                        right: startExpr,
                    }),
                ],
                wtype: bytesPType.wtype,
                sourceLocation,
            }), bytesPType);
        }
    }
    call(args, typeArgs, sourceLocation) {
        if (this.opMapping.op === 'extract3') {
            return this.handleExtract(args, typeArgs, sourceLocation);
        }
        signatureLoop: for (const [index, sig] of enumerate(this.opMapping.signatures)) {
            const isLastSig = index + 1 >= this.opMapping.signatures.length;
            if (args.length !== sig.argNames.length) {
                if (isLastSig)
                    throw new CodeError(`Expected ${sig.argNames.length} args`, {
                        sourceLocation,
                    });
                else
                    continue;
            }
            const immediates = [];
            const stackArgs = [];
            stackArgLoop: for (const arg of sig.stackArgs) {
                if (arg instanceof Expression) {
                    stackArgs.push(arg);
                    continue;
                }
                const thisArg = args[sig.argNames.indexOf(arg.name)];
                for (const ptype of arg.ptypes) {
                    const expr = requestExpressionOfType(thisArg, ptype);
                    if (expr) {
                        stackArgs.push(expr);
                        continue stackArgLoop;
                    }
                }
                continue signatureLoop;
            }
            immediateArgLoop: for (const arg of sig.immediateArgs) {
                if (typeof arg === 'string' || typeof arg === 'bigint') {
                    immediates.push(arg);
                    continue;
                }
                const thisArg = args[sig.argNames.indexOf(arg.name)];
                for (const ptype of arg.ptypes) {
                    if (ptype instanceof IntrinsicEnumType) {
                        const enumValue = requestConstantOfType(thisArg, stringPType);
                        if (enumValue) {
                            invariant(enumValue instanceof StringConstant, 'stringPType constant must be StringConstant');
                            immediates.push(enumValue.value);
                            continue immediateArgLoop;
                        }
                    }
                    const constantValue = requestConstantOfType(thisArg, ptype);
                    if (constantValue) {
                        if (constantValue instanceof IntegerConstant || constantValue instanceof StringConstant) {
                            immediates.push(constantValue.value);
                            continue immediateArgLoop;
                        }
                        throw new InternalError(`Constant value ${constantValue} cannot be converted to an immediate argument`, { sourceLocation });
                    }
                }
                continue signatureLoop;
            }
            return typeRegistry.getInstanceEb(nodeFactory.intrinsicCall({
                opCode: this.opMapping.op,
                wtype: sig.returnType.wtypeOrThrow,
                sourceLocation: sourceLocation,
                stackArgs,
                immediates,
            }), sig.returnType);
        }
        throw new CodeError(`Could not map arguments to any known signature`, { sourceLocation });
    }
}
class FreeIntrinsicOpBuilder extends IntrinsicOpBuilderBase {
    ptype;
    constructor(sourceLocation, ptype) {
        invariant(ptype instanceof IntrinsicFunctionType, 'ptype must be IntrinsicFunctionType');
        const metaData = OP_METADATA[ptype.name];
        invariant(metaData.type === 'op-mapping', 'ptype must map to op-grouping');
        super(sourceLocation, metaData);
        this.ptype = ptype;
    }
}
class GroupedIntrinsicOpBuilder extends IntrinsicOpBuilderBase {
    constructor(sourceLocation, opMapping) {
        super(sourceLocation, opMapping);
    }
}
/**
 * Builder for expressions which have the 'type' of an intrinsic function or group but are not the singleton instance
 * imported from @algorandfoundat/algorand-typescript. This is not supported.
 */
class IntrinsicOpGroupOrFunctionTypeBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        super(expr, ptype);
        throw new CodeError('Invalid alias of op function or group type', { sourceLocation: expr.sourceLocation });
    }
}

class ReferenceTypeExpressionBuilder extends InstanceExpressionBuilder {
    options;
    constructor(expr, options) {
        super(expr, options.ptype);
        this.options = options;
    }
    memberAccess(name, sourceLocation) {
        if (name === this.options.backingMember) {
            return instanceEb(nodeFactory.reinterpretCast({
                expr: this.resolve(),
                wtype: this.options.backingType.wtypeOrThrow,
                sourceLocation,
            }), this.options.backingType);
        }
        if (name in this.options.fieldMapping) {
            const [immediate, resultType] = this.options.fieldMapping[name];
            const op = nodeFactory.intrinsicCall({
                opCode: this.options.fieldOpCode,
                immediates: [immediate],
                stackArgs: [this.resolve()],
                wtype: new wtypes.WTuple({ types: [resultType.wtypeOrThrow, wtypes.boolWType], immutable: true }),
                sourceLocation,
            });
            return instanceEb(nodeFactory.checkedMaybe({ expr: op, comment: this.options.fieldBoolComment }), resultType);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class Uint64BackedReferenceTypeExpressionBuilder extends ReferenceTypeExpressionBuilder {
    constructor(expr, options) {
        super(expr, {
            backingType: uint64PType,
            ...options,
        });
    }
    toBytes(sourceLocation) {
        return intrinsicFactory.itob({ value: this.resolve(), sourceLocation });
    }
    boolEval(sourceLocation, negate = false) {
        if (negate) {
            return nodeFactory.not({
                expr: this.resolve(),
                sourceLocation,
            });
        }
        return nodeFactory.reinterpretCast({
            sourceLocation,
            expr: this.resolve(),
            wtype: wtypes.boolWType,
        });
    }
    compare(other, op, sourceLocation) {
        const otherExpr = requireExpressionOfType(other, this.ptype);
        return compareUint64(this.resolve(), otherExpr, op, sourceLocation, this.typeDescription);
    }
}

class AccountFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [addressOrKey], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            funcName: 'Account function',
            genericTypeArgs: 0,
            argSpec: (a) => [a.optional(stringPType, bytesPType)],
        });
        if (!addressOrKey) {
            return new AccountExpressionBuilder(nodeFactory.intrinsicCall({
                opCode: 'global',
                immediates: ['ZeroAddress'],
                stackArgs: [],
                sourceLocation,
                wtype: accountPType.wtype,
            }));
        }
        if (addressOrKey.ptype.equals(stringPType)) {
            const address = requireStringConstant(addressOrKey);
            return new AccountExpressionBuilder(nodeFactory.addressConstant({
                value: address.value,
                sourceLocation: address.sourceLocation,
                wtype: accountPType.wtype,
            }));
        }
        return new AccountExpressionBuilder(nodeFactory.reinterpretCast({
            expr: requireExpressionOfType(addressOrKey, bytesPType),
            wtype: accountPType.wtype,
            sourceLocation,
        }));
    }
}
class AccountExpressionBuilder extends ReferenceTypeExpressionBuilder {
    constructor(expr) {
        super(expr, {
            backingType: bytesPType,
            backingMember: 'bytes',
            fieldMapping: {
                balance: ['AcctBalance', uint64PType],
                minBalance: ['AcctMinBalance', uint64PType],
                authAddress: ['AcctAuthAddr', accountPType],
                totalNumUint: ['AcctTotalNumUint', uint64PType],
                totalNumByteSlice: ['AcctTotalNumByteSlice', uint64PType],
                totalExtraAppPages: ['AcctTotalExtraAppPages', uint64PType],
                totalAppsCreated: ['AcctTotalAppsCreated', uint64PType],
                totalAppsOptedIn: ['AcctTotalAppsOptedIn', uint64PType],
                totalAssetsCreated: ['AcctTotalAssetsCreated', uint64PType],
                totalAssets: ['AcctTotalAssets', uint64PType],
                totalBoxes: ['AcctTotalBoxes', uint64PType],
                totalBoxBytes: ['AcctTotalBoxBytes', uint64PType],
            },
            fieldOpCode: 'acct_params_get',
            ptype: accountPType,
            fieldBoolComment: 'account funded',
        });
    }
    compare(other, op, sourceLocation) {
        return compareBytes(this._expr, requireExpressionOfType(other, accountPType), op, sourceLocation, this.typeDescription);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'isOptedIn':
                return new IsOptedInFunctionBuilder(this._expr, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
    toBytes(sourceLocation) {
        return nodeFactory.reinterpretCast({
            expr: this._expr,
            wtype: wtypes.bytesWType,
            sourceLocation,
        });
    }
}
class IsOptedInFunctionBuilder extends FunctionBuilder {
    expr;
    constructor(expr, sourceLocation) {
        super(sourceLocation);
        this.expr = expr;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [applicationOrAsset], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'isOptedIn',
            argSpec: (a) => [a.required(applicationPType, assetPType)],
        });
        if (applicationOrAsset.ptype.equals(assetPType)) {
            return new BooleanExpressionBuilder(nodeFactory.tupleItemExpression({
                base: nodeFactory.intrinsicCall({
                    opCode: 'asset_holding_get',
                    immediates: ['AssetBalance'],
                    stackArgs: [this.expr, applicationOrAsset.resolve()],
                    wtype: new wtypes.WTuple({ types: [wtypes.uint64WType, wtypes.boolWType], immutable: true }),
                    sourceLocation,
                }),
                index: 1n,
                sourceLocation,
            }));
        }
        else {
            return new BooleanExpressionBuilder(nodeFactory.intrinsicCall({
                opCode: 'app_opted_in',
                stackArgs: [this.expr, applicationOrAsset.resolve()],
                sourceLocation,
                wtype: wtypes.boolWType,
                immediates: [],
            }));
        }
    }
}

class ApplicationFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [applicationId], } = parseFunctionArgs({
            argSpec: (a) => [a.optional(uint64PType)],
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'Application',
            callLocation: sourceLocation,
        });
        return new ApplicationExpressionBuilder(nodeFactory.reinterpretCast({
            expr: applicationId?.resolve() ?? nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
            sourceLocation,
            wtype: applicationPType.wtypeOrThrow,
        }));
    }
}
class ApplicationExpressionBuilder extends Uint64BackedReferenceTypeExpressionBuilder {
    constructor(expr) {
        super(expr, {
            ptype: applicationPType,
            backingMember: 'id',
            fieldOpCode: 'app_params_get',
            fieldMapping: {
                approvalProgram: ['AppApprovalProgram', bytesPType],
                clearStateProgram: ['AppClearStateProgram', bytesPType],
                globalNumUint: ['AppGlobalNumUint', uint64PType],
                globalNumBytes: ['AppGlobalNumByteSlice', uint64PType],
                localNumUint: ['AppLocalNumUint', uint64PType],
                localNumBytes: ['AppLocalNumByteSlice', uint64PType],
                extraProgramPages: ['AppExtraProgramPages', uint64PType],
                creator: ['AppCreator', accountPType],
                address: ['AppAddress', accountPType],
            },
            fieldBoolComment: 'application exists',
        });
    }
}

class AssetFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [assetId], } = parseFunctionArgs({
            argSpec: (a) => [a.optional(uint64PType)],
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'Asset function',
            callLocation: sourceLocation,
        });
        return new AssetExpressionBuilder(nodeFactory.reinterpretCast({
            expr: assetId?.resolve() ?? nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
            sourceLocation,
            wtype: assetPType.wtypeOrThrow,
        }));
    }
}
class AssetHoldingExpressionBuilder extends FunctionBuilder {
    asset;
    holdingField;
    static fieldMapping = {
        balance: ['AssetBalance', uint64PType],
        frozen: ['AssetFrozen', boolPType],
    };
    constructor(asset, holdingField, sourceLocation) {
        super(sourceLocation);
        this.asset = asset;
        this.holdingField = holdingField;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [holder], } = parseFunctionArgs({
            args,
            typeArgs,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            funcName: this.holdingField,
            argSpec: (a) => [a.required(accountPType)],
        });
        const [immediate, resultType] = AssetHoldingExpressionBuilder.fieldMapping[this.holdingField];
        const op = nodeFactory.intrinsicCall({
            opCode: 'asset_holding_get',
            immediates: [immediate],
            stackArgs: [holder.resolve(), this.asset],
            wtype: new wtypes.WTuple({ types: [resultType.wtypeOrThrow, wtypes.boolWType], immutable: true }),
            sourceLocation,
        });
        return instanceEb(nodeFactory.checkedMaybe({ expr: op, comment: `account opted into asset` }), resultType);
    }
}
class AssetExpressionBuilder extends Uint64BackedReferenceTypeExpressionBuilder {
    constructor(expr) {
        super(expr, {
            ptype: assetPType,
            backingMember: 'id',
            fieldOpCode: 'asset_params_get',
            fieldMapping: {
                total: ['AssetTotal', uint64PType],
                decimals: ['AssetDecimals', uint64PType],
                defaultFrozen: ['AssetDefaultFrozen', boolPType],
                unitName: ['AssetUnitName', bytesPType],
                name: ['AssetName', bytesPType],
                url: ['AssetURL', bytesPType],
                metadataHash: ['AssetMetadataHash', bytesPType],
                manager: ['AssetManager', accountPType],
                reserve: ['AssetReserve', accountPType],
                freeze: ['AssetFreeze', accountPType],
                clawback: ['AssetClawback', accountPType],
                creator: ['AssetCreator', accountPType],
            },
            fieldBoolComment: 'asset exists',
        });
    }
    memberAccess(name, sourceLocation) {
        if (name in AssetHoldingExpressionBuilder.fieldMapping) {
            return new AssetHoldingExpressionBuilder(this.resolve(), name, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
}

function extractKey(key, keyWType) {
    if (!key)
        return undefined;
    const keyBytes = key.toBytes(key.sourceLocation);
    if (keyBytes instanceof BytesConstant) {
        return nodeFactory.bytesConstant({
            ...keyBytes,
            wtype: keyWType,
        });
    }
    else {
        return nodeFactory.reinterpretCast({
            expr: keyBytes,
            wtype: keyWType,
            sourceLocation: key.sourceLocation,
        });
    }
}

class AppStorageDeclaration {
    memberName;
    ptype;
    keyOverride;
    sourceLocation;
    definedIn;
    description;
    constructor(props) {
        this.memberName = props.memberName;
        this.ptype = props.ptype;
        this.keyOverride = props.keyOverride;
        this.sourceLocation = props.sourceLocation;
        this.definedIn = props.definedIn;
        this.description = props.description;
    }
    get kind() {
        if (this.ptype instanceof GlobalStateType) {
            return AppStorageKind.appGlobal;
        }
        if (this.ptype instanceof LocalStateType) {
            return AppStorageKind.accountLocal;
        }
        invariant(this.ptype instanceof BoxPType || this.ptype instanceof BoxRefPType || this.ptype instanceof BoxMapPType, 'Must be exhaustive check on ptype');
        return AppStorageKind.box;
    }
    get key() {
        if (this.keyOverride) {
            invariant(this.keyOverride.wtype.equals(this.ptype.wtype), 'Key wtype must match ptype');
            return this.keyOverride;
        }
        else {
            return nodeFactory.bytesConstant({
                value: utf8ToUint8Array(this.memberName),
                sourceLocation: this.sourceLocation,
                encoding: BytesEncoding.utf8,
                wtype: this.ptype.wtype,
            });
        }
    }
    get definition() {
        if (!this.ptype.contentType.wtype || !this.ptype.contentType.wtype.scalarType) {
            throw new CodeError(`${this.ptype.contentType.fullName} is not a valid type for storage`, { sourceLocation: this.sourceLocation });
        }
        return nodeFactory.appStorageDefinition({
            ...this,
            kind: this.kind,
            key: this.key,
            keyWtype: this.ptype instanceof BoxMapPType ? this.ptype.keyType.wtypeOrThrow : null,
            storageWtype: this.ptype.contentType.wtypeOrThrow,
        });
    }
}

class ValueProxy extends InstanceExpressionBuilder {
    get proxied() {
        return typeRegistry.getInstanceEb(this._expr, this.ptype);
    }
    resolve() {
        return this.proxied.resolve();
    }
    resolveLValue() {
        return this.proxied.resolveLValue();
    }
    memberAccess(name, sourceLocation) {
        return this.proxied.memberAccess(name, sourceLocation);
    }
    augmentedAssignment(other, op, sourceLocation) {
        return this.proxied.augmentedAssignment(other, op, sourceLocation);
    }
    iterate(sourceLocation) {
        return this.proxied.iterate(sourceLocation);
    }
    indexAccess(index, sourceLocation) {
        return this.proxied.indexAccess(index, sourceLocation);
    }
    boolEval(sourceLocation, negate = false) {
        return this.proxied.boolEval(sourceLocation, negate);
    }
    binaryOp(other, op, sourceLocation) {
        return this.proxied.binaryOp(other, op, sourceLocation);
    }
    prefixUnaryOp(op, sourceLocation) {
        return this.proxied.prefixUnaryOp(op, sourceLocation);
    }
    postfixUnaryOp(op, sourceLocation) {
        return this.proxied.postfixUnaryOp(op, sourceLocation);
    }
    call(args, typeArgs, sourceLocation) {
        return this.proxied.call(args, typeArgs, sourceLocation);
    }
    compare(other, op, sourceLocation) {
        return this.proxied.compare(other, op, sourceLocation);
    }
    taggedTemplate(head, spans, sourceLocation) {
        return this.proxied.taggedTemplate(head, spans, sourceLocation);
    }
    singleEvaluation() {
        return this.proxied.singleEvaluation();
    }
    hasProperty(_name) {
        return this.proxied.hasProperty(_name);
    }
    toBytes(sourceLocation) {
        return this.proxied.toBytes(sourceLocation);
    }
    resolvableToPType(ptype) {
        return this.proxied.resolvableToPType(ptype);
    }
    resolveToPType(ptype) {
        return this.proxied.resolveToPType(ptype);
    }
}

class BoxProxyExpressionBuilder extends InstanceExpressionBuilder {
    buildStorageDeclaration(memberName, memberLocation, memberDescription, contractType) {
        codeInvariant(this._expr instanceof BytesConstant, `key${this.ptype instanceof BoxMapPType ? ' prefix' : ''} must be a compile time constant value if ${this.typeDescription} is assigned to a contract member`);
        return new AppStorageDeclaration({
            sourceLocation: memberLocation,
            ptype: this.ptype,
            memberName: memberName,
            keyOverride: this._expr ?? null,
            description: memberDescription,
            definedIn: contractType,
        });
    }
    toBytes(sourceLocation) {
        return nodeFactory.reinterpretCast({
            expr: this.resolve(),
            wtype: wtypes.bytesWType,
            sourceLocation,
        });
    }
}
/**
 * Wraps the box value expression and watches for certain expressions which can be optimized.
 *
 * For example box.value.bytes.slice(...) can be optimized to use box_extract directly rather
 * than reading the entire box into memory and then slicing it. All unhandled scenarios are proxied
 * through to the underlying builder for the given type.
 */
class BoxValueExpressionBuilder extends ValueProxy {
    constructor(boxValue, ptype) {
        super(boxValue, ptype);
    }
}
function boxValue({ key, sourceLocation, contentType, }) {
    return nodeFactory.boxValueExpression({
        key,
        sourceLocation,
        wtype: contentType.wtypeOrThrow,
        existsAssertionMessage: 'Box must have value',
    });
}
function boxLength(box, sourceLocation) {
    return instanceEb(nodeFactory.checkedMaybe({
        expr: nodeFactory.intrinsicCall({
            opCode: 'box_len',
            stackArgs: [box.key],
            wtype: new wtypes.WTuple({ types: [wtypes.uint64WType, wtypes.boolWType], immutable: true }),
            immediates: [],
            sourceLocation,
        }),
        comment: box.existsAssertionMessage ?? 'Box exists',
    }), uint64PType);
}
function boxExists(box, sourceLocation) {
    return instanceEb(nodeFactory.stateExists({
        field: box,
        sourceLocation,
        wtype: wtypes.boolWType,
    }), boolPType);
}

/**
 * Verifies contentType is able to be stored in a box.
 * @param contentType The content type of the box
 * @param sourceLocation The source location of the box proxy declaration
 */
function checkBoxType(contentType, sourceLocation) {
    if (contentType instanceof ARC4EncodedType) {
        return;
    }
    else if (contentType.wtype && contentType.wtype.scalarType !== null) {
        return;
    }
    else {
        logger.error(sourceLocation, `Objects of type ${contentType} cannot be stored in a box`);
    }
}
/**
 * Returns the fixed size requirement for a box of a given ptype or null if the contentType is dynamically sized.
 * @param contentType The content type of the box
 */
function getBoxSize(contentType) {
    if (contentType instanceof ARC4EncodedType) {
        return contentType.fixedByteSize;
    }
    else if (contentType.wtype?.scalarType === AVMType.uint64) {
        return 8n;
    }
    else if (contentType.equals(accountPType)) {
        return 32n;
    }
    else {
        return null;
    }
}

class BoxFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { ptypes: [contentPType], args: [{ key }], } = parseFunctionArgs({
            args,
            typeArgs,
            funcName: `Box`,
            callLocation: sourceLocation,
            genericTypeArgs: 1,
            argSpec: (a) => [a.obj({ key: a.required(bytesPType, stringPType) })],
        });
        checkBoxType(contentPType, sourceLocation);
        const ptype = new BoxPType({ content: contentPType });
        return new BoxExpressionBuilder(extractKey(key, wtypes.boxKeyWType), ptype);
    }
}
class BoxExpressionBuilder extends BoxProxyExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof BoxPType, 'BoxExpressionBuilder must be constructed with ptype of BoxPType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        const boxValueExpr = boxValue({
            key: this._expr,
            sourceLocation,
            contentType: this.ptype.contentType,
        });
        switch (name) {
            case 'create':
                return new BoxCreateFunctionBuilder(boxValueExpr, this.ptype.contentType, sourceLocation);
            case 'key':
                return instanceEb(this.toBytes(sourceLocation), bytesPType);
            case 'value':
                return new BoxValueExpressionBuilder(boxValueExpr, this.ptype.contentType);
            case 'exists':
                return boxExists(boxValueExpr, sourceLocation);
            case 'length':
                return boxLength(boxValueExpr, sourceLocation);
            case 'delete':
                return new BoxDeleteFunctionBuilder(boxValueExpr, sourceLocation);
            case 'get':
                return new BoxGetFunctionBuilder(boxValueExpr, this.ptype.contentType, sourceLocation);
            case 'maybe':
                return new BoxMaybeFunctionBuilder(boxValueExpr, this.ptype.contentType, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class BoxCreateFunctionBuilder extends FunctionBuilder {
    boxValue;
    contentType;
    constructor(boxValue, contentType, sourceLocation) {
        super(sourceLocation);
        this.boxValue = boxValue;
        this.contentType = contentType;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [{ size }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'Box.create',
            argSpec: (a) => [a.obj({ size: a.optional(uint64PType) })],
        });
        if (size) {
            return instanceEb(nodeFactory.intrinsicCall({
                opCode: 'box_create',
                stackArgs: [this.boxValue.key, size.resolve()],
                wtype: wtypes.boolWType,
                immediates: [],
                sourceLocation,
            }), boolPType);
        }
        const boxSize = getBoxSize(this.contentType);
        if (boxSize === null) {
            logger.error(sourceLocation, `${this.contentType} does not have a fixed byte size. Please specify a size argument.`);
        }
        return instanceEb(nodeFactory.intrinsicCall({
            opCode: 'box_create',
            stackArgs: [this.boxValue.key, nodeFactory.uInt64Constant({ value: boxSize ?? 0n, sourceLocation })],
            wtype: wtypes.boolWType,
            immediates: [],
            sourceLocation,
        }), boolPType);
    }
}
class BoxDeleteFunctionBuilder extends ParameterlessFunctionBuilder {
    constructor(boxValue, sourceLocation) {
        super(boxValue, (expr) => instanceEb(nodeFactory.stateDelete({
            sourceLocation,
            field: boxValue,
            wtype: wtypes.boolWType,
        }), boolPType));
    }
}
class BoxGetFunctionBuilder extends FunctionBuilder {
    boxValue;
    contentType;
    constructor(boxValue, contentType, sourceLocation) {
        super(sourceLocation);
        this.boxValue = boxValue;
        this.contentType = contentType;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [{ default: defaultValue }], } = parseFunctionArgs({
            args,
            typeArgs,
            funcName: 'Box.get',
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: (a) => [a.obj({ default: a.optional(this.contentType) })],
        });
        if (defaultValue) {
            return instanceEb(nodeFactory.stateGet({
                sourceLocation,
                default: defaultValue.resolve(),
                wtype: this.contentType.wtypeOrThrow,
                field: this.boxValue,
            }), this.contentType);
        }
        else {
            return new BoxValueExpressionBuilder(this.boxValue, this.contentType);
        }
    }
}
class BoxMaybeFunctionBuilder extends FunctionBuilder {
    boxValue;
    contentType;
    constructor(boxValue, contentType, sourceLocation) {
        super(sourceLocation);
        this.boxValue = boxValue;
        this.contentType = contentType;
    }
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({
            args,
            typeArgs,
            funcName: 'Box.maybe',
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: () => [],
        });
        const type = new TuplePType({ items: [this.contentType, boolPType] });
        return instanceEb(nodeFactory.stateGetEx({
            sourceLocation,
            wtype: type.wtype,
            field: this.boxValue,
        }), type);
    }
}

class BoxMapFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { ptypes: [keySuffixType, contentPType], args: [{ keyPrefix }], } = parseFunctionArgs({
            args,
            typeArgs,
            funcName: `BoxMap`,
            callLocation: sourceLocation,
            genericTypeArgs: 2,
            argSpec: (a) => [a.obj({ keyPrefix: a.required(bytesPType, stringPType) })],
        });
        checkBoxType(contentPType, sourceLocation);
        const ptype = new BoxMapPType({ content: contentPType, keyType: keySuffixType });
        return new BoxMapExpressionBuilder(extractKey(keyPrefix, wtypes.boxKeyWType), ptype);
    }
}
class BoxMapExpressionBuilder extends BoxProxyExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof BoxMapPType, 'BoxMapExpressionBuilder must be constructed with ptype of BoxMapPType');
        super(expr, ptype);
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [key], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            argSpec: (a) => [a.required(this.ptype.keyType)],
            funcName: 'BoxMap',
        });
        return new BoxExpressionBuilder(intrinsicFactory.bytesConcat({
            left: this._expr,
            right: key.toBytes(sourceLocation),
            sourceLocation: this.sourceLocation,
        }), new BoxPType({
            content: this.ptype.contentType,
        }));
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'keyPrefix':
                return instanceEb(this.toBytes(sourceLocation), bytesPType);
        }
        return super.memberAccess(name, sourceLocation);
    }
}

class BoxRefFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [{ key }], } = parseFunctionArgs({
            args,
            typeArgs,
            funcName: `BoxRef`,
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: (a) => [a.obj({ key: a.required(bytesPType, stringPType) })],
        });
        return new BoxRefExpressionBuilder(extractKey(key, wtypes.boxKeyWType), boxRefType);
    }
}
class BoxRefExpressionBuilder extends BoxProxyExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof BoxRefPType, 'BoxRefExpressionBuilder must be constructed with ptype of BoxRefPType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        const boxValueExpr = boxValue({
            key: this._expr,
            sourceLocation,
            contentType: this.ptype.contentType,
        });
        switch (name) {
            case 'key':
                return instanceEb(this.toBytes(sourceLocation), bytesPType);
            case 'get':
                return new BoxRefGetFunctionBuilder(boxValueExpr);
            case 'delete':
                return new BoxRefDeleteFunctionBuilder(boxValueExpr);
            case 'put':
                return new BoxRefPutFunctionBuilder(boxValueExpr);
            case 'splice':
                return new BoxRefSpliceFunctionBuilder(boxValueExpr);
            case 'create':
                return new BoxRefCreateFunctionBuilder(boxValueExpr);
            case 'resize':
                return new BoxRefResizeFunctionBuilder(boxValueExpr);
            case 'extract':
                return new BoxRefExtractFunctionBuilder(boxValueExpr);
            case 'replace':
                return new BoxRefReplaceFunctionBuilder(boxValueExpr);
            case 'exists':
                return boxExists(boxValueExpr, sourceLocation);
            case 'maybe':
                return new BoxRefMaybeFunctionBuilder(boxValueExpr);
            case 'length':
                return boxLength(boxValueExpr, sourceLocation);
            case 'value':
                return new BoxValueExpressionBuilder(boxValueExpr, this.ptype.contentType);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class BoxRefBaseFunctionBuilder extends FunctionBuilder {
    boxValue;
    constructor(boxValue) {
        super(boxValue.sourceLocation);
        this.boxValue = boxValue;
    }
}
class BoxRefCreateFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [{ size }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'BoxRef.create',
            callLocation: sourceLocation,
            argSpec: (a) => [a.obj({ size: a.required(uint64PType) })],
        });
        return instanceEb(nodeFactory.intrinsicCall({
            opCode: 'box_create',
            stackArgs: [this.boxValue.key, size.resolve()],
            wtype: wtypes.boolWType,
            immediates: [],
            sourceLocation,
        }), boolPType);
    }
}
class BoxRefResizeFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [size], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'BoxRef.resize',
            callLocation: sourceLocation,
            argSpec: (a) => [a.required(uint64PType)],
        });
        return instanceEb(nodeFactory.intrinsicCall({
            opCode: 'box_resize',
            stackArgs: [this.boxValue.key, size.resolve()],
            wtype: wtypes.voidWType,
            immediates: [],
            sourceLocation,
        }), voidPType);
    }
}
class BoxRefExtractFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [start, length], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'BoxRef.extract',
            callLocation: sourceLocation,
            argSpec: (a) => [a.required(uint64PType), a.required(uint64PType)],
        });
        return instanceEb(nodeFactory.intrinsicCall({
            opCode: 'box_extract',
            stackArgs: [this.boxValue.key, start.resolve(), length.resolve()],
            wtype: wtypes.bytesWType,
            immediates: [],
            sourceLocation,
        }), bytesPType);
    }
}
class BoxRefReplaceFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [start, value], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'BoxRef.replace',
            callLocation: sourceLocation,
            argSpec: (a) => [a.required(uint64PType), a.required(bytesPType)],
        });
        return instanceEb(nodeFactory.intrinsicCall({
            opCode: 'box_replace',
            stackArgs: [this.boxValue.key, start.resolve(), value.resolve()],
            wtype: wtypes.voidWType,
            immediates: [],
            sourceLocation,
        }), voidPType);
    }
}
class BoxRefGetFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [{ default: defaultValue }], } = parseFunctionArgs({
            args,
            typeArgs,
            funcName: 'BoxRef.get',
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: (a) => [a.obj({ default: a.optional(bytesPType) })],
        });
        if (defaultValue) {
            return instanceEb(nodeFactory.stateGet({
                sourceLocation,
                default: defaultValue.resolve(),
                wtype: wtypes.bytesWType,
                field: this.boxValue,
            }), bytesPType);
        }
        else {
            return new BoxValueExpressionBuilder(this.boxValue, bytesPType);
        }
    }
}
class BoxRefPutFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [value], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'BoxRef.put',
            callLocation: sourceLocation,
            argSpec: (a) => [a.required(bytesPType)],
        });
        return instanceEb(nodeFactory.intrinsicCall({
            opCode: 'box_put',
            stackArgs: [this.boxValue.key, value.resolve()],
            wtype: wtypes.voidWType,
            immediates: [],
            sourceLocation,
        }), voidPType);
    }
}
class BoxRefSpliceFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: [start, stop, value], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            funcName: 'BoxRef.splice',
            callLocation: sourceLocation,
            argSpec: (a) => [a.required(uint64PType), a.required(uint64PType), a.required(bytesPType)],
        });
        return instanceEb(nodeFactory.intrinsicCall({
            opCode: 'box_splice',
            stackArgs: [this.boxValue.key, start.resolve(), stop.resolve(), value.resolve()],
            wtype: wtypes.voidWType,
            immediates: [],
            sourceLocation,
        }), voidPType);
    }
}
class BoxRefMaybeFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({
            args,
            typeArgs,
            funcName: 'BoxRef.maybe',
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: () => [],
        });
        const type = new TuplePType({ items: [bytesPType, boolPType] });
        return instanceEb(nodeFactory.stateGetEx({
            sourceLocation,
            wtype: type.wtype,
            field: this.boxValue,
        }), type);
    }
}
class BoxRefDeleteFunctionBuilder extends BoxRefBaseFunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({
            args,
            typeArgs,
            funcName: 'BoxRef.delete',
            callLocation: sourceLocation,
            genericTypeArgs: 0,
            argSpec: () => [],
        });
        return instanceEb(nodeFactory.stateDelete({
            field: this.boxValue,
            sourceLocation,
            wtype: wtypes.boolWType,
        }), boolPType);
    }
}

class GlobalStateFunctionBuilder extends FunctionBuilder {
    constructor(sourceLocation) {
        super(sourceLocation);
    }
    call(args, typeArgs, sourceLocation) {
        const [contentPType] = typeArgs;
        const { args: [{ initialValue, key }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            argSpec: (a) => [
                a.obj({
                    initialValue: a.optional(contentPType),
                    key: a.optional(stringPType, bytesPType),
                }),
            ],
            funcName: this.typeDescription,
            callLocation: sourceLocation,
        });
        const ptype = new GlobalStateType({ content: contentPType });
        return new GlobalStateFunctionResultBuilder(extractKey(key, wtypes.stateKeyWType), ptype, {
            initialValue: initialValue?.resolve(),
            sourceLocation,
        });
    }
}
class GlobalStateDeleteFunctionBuilder extends FunctionBuilder {
    key;
    constructor(key, sourceLocation) {
        super(sourceLocation);
        this.key = key;
    }
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'GlobalState.delete',
            argSpec: () => [],
        });
        return new VoidExpressionBuilder(nodeFactory.stateDelete({
            field: this.key,
            sourceLocation,
            wtype: wtypes.voidWType,
        }));
    }
}
class GlobalStateExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof GlobalStateType, 'ptype must be instance of GlobalStateType');
        super(expr, ptype);
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'delete':
                return new GlobalStateDeleteFunctionBuilder(this.buildField(), sourceLocation);
            case 'value':
                return typeRegistry.getInstanceEb(this.buildField(), this.ptype.contentType);
            case 'hasValue':
                return new BooleanExpressionBuilder(nodeFactory.stateExists({
                    field: this.buildField(),
                    wtype: boolPType.wtype,
                    sourceLocation,
                }));
        }
        return super.memberAccess(name, sourceLocation);
    }
    buildField() {
        return nodeFactory.appStateExpression({
            key: this._expr,
            wtype: this.ptype.contentType.wtypeOrThrow,
            existsAssertionMessage: 'check GlobalState exists',
            sourceLocation: this.sourceLocation,
        });
    }
}
class GlobalStateFunctionResultBuilder extends GlobalStateExpressionBuilder {
    resolve() {
        codeInvariant(this._keyExpr, 'Global state must have explicit key provided if not being assigned to a contract property', this.sourceLocation);
        codeInvariant(!this.initialValue, 'Global state can only have an initial value specified if being assigned to a contract property');
        return this._expr;
    }
    initialValue;
    _keyExpr;
    constructor(expr, ptype, config) {
        const sourceLocation = expr?.sourceLocation ?? config?.sourceLocation;
        invariant(sourceLocation, 'Must have expression or config');
        super(expr ?? nodeFactory.voidConstant({ sourceLocation }), ptype);
        this.initialValue = config.initialValue;
        this._keyExpr = expr;
    }
    buildField() {
        codeInvariant(this._keyExpr, 'Global state must have explicit key provided if not being assigned to a contract property', this.sourceLocation);
        return super.buildField();
    }
    buildStorageDeclaration(memberName, memberLocation, memberDescription, contractType) {
        if (this._keyExpr)
            codeInvariant(this._keyExpr instanceof BytesConstant, `key must be a compile time constant value if ${this.typeDescription} is assigned to a contract member`);
        return new AppStorageDeclaration({
            sourceLocation: memberLocation,
            ptype: this.ptype,
            memberName: memberName,
            keyOverride: this._keyExpr ?? null,
            description: memberDescription,
            definedIn: contractType,
        });
    }
}

class LocalStateFunctionBuilder extends FunctionBuilder {
    constructor(sourceLocation) {
        super(sourceLocation);
    }
    call(args, typeArgs, sourceLocation) {
        const [contentPType] = typeArgs;
        const { args: [{ key }], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            argSpec: (a) => [
                a.obj({
                    key: a.optional(stringPType, bytesPType),
                }),
            ],
            funcName: this.typeDescription,
            callLocation: sourceLocation,
        });
        const ptype = new LocalStateType({ content: contentPType });
        return new LocalStateFunctionResultBuilder(extractKey(key, wtypes.stateKeyWType), ptype, { sourceLocation });
    }
}
class LocalStateExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof LocalStateType, 'ptype must be instance of LocalStateType');
        super(expr, ptype);
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [account], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'LocalState',
            argSpec: (a) => [a.required(accountPType)],
        });
        return new LocalStateForAccountExpressionBuilder(this.buildField(account.resolve(), sourceLocation), this.ptype.contentType);
    }
    buildField(account, sourceLocation) {
        return nodeFactory.appAccountStateExpression({
            key: this._expr,
            account,
            wtype: this.ptype.contentType.wtypeOrThrow,
            existsAssertionMessage: 'check LocalState exists',
            sourceLocation,
        });
    }
}
class LocalStateForAccountExpressionBuilder extends NodeBuilder {
    key;
    contentType;
    ptype;
    constructor(key, contentType) {
        super(key.sourceLocation);
        this.key = key;
        this.contentType = contentType;
    }
    memberAccess(name, sourceLocation) {
        switch (name) {
            case 'value':
                return instanceEb(nodeFactory.appAccountStateExpression({
                    ...this.key,
                    sourceLocation,
                }), this.contentType);
            case 'hasValue':
                return instanceEb(nodeFactory.stateExists({
                    field: this.key,
                    sourceLocation,
                    wtype: wtypes.boolWType,
                }), boolPType);
            case 'delete':
                return new LocalStateDeleteFunctionBuilder(this.key, sourceLocation);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class LocalStateDeleteFunctionBuilder extends FunctionBuilder {
    key;
    constructor(key, sourceLocation) {
        super(sourceLocation);
        this.key = key;
    }
    call(args, typeArgs, sourceLocation) {
        parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'LocalState.delete',
            argSpec: () => [],
        });
        return new VoidExpressionBuilder(nodeFactory.stateDelete({
            field: this.key,
            sourceLocation,
            wtype: wtypes.voidWType,
        }));
    }
}
class LocalStateFunctionResultBuilder extends InstanceBuilder {
    resolve() {
        codeInvariant(this._expr, 'Local state must have explicit key provided if not being assigned to a contract property', this.sourceLocation);
        return this._expr;
    }
    resolveLValue() {
        throw CodeError.invalidAssignmentTarget({ name: this.typeDescription, sourceLocation: this.sourceLocation });
    }
    _expr;
    constructor(expr, ptype, config) {
        const sourceLocation = expr?.sourceLocation ?? config?.sourceLocation;
        invariant(sourceLocation, 'Must have expression or config');
        super(sourceLocation);
        invariant(ptype instanceof LocalStateType, 'ptype must be LocalStateType');
        this._expr = expr;
        this.ptype = ptype;
    }
    ptype;
    buildStorageDeclaration(memberName, memberLocation, memberDescription, contractType) {
        if (this._expr)
            codeInvariant(this._expr instanceof BytesConstant, `key is must be a compile time constant value if ${this.typeDescription} is assigned to a contract member`);
        return new AppStorageDeclaration({
            sourceLocation: memberLocation,
            ptype: this.ptype,
            memberName: memberName,
            keyOverride: this._expr ?? null,
            description: memberDescription,
            definedIn: contractType,
        });
    }
}

const TemplateVarNameRegex = /^[A-Z\d_]+/;
const templateVarName = A.regex(TemplateVarNameRegex);
const hexBytes = A.sequenceOf([A.str('0x'), A.regex(/^([A-F0-9]{2})*/)]).map(([prefix, chars]) => hexToUint8Array(chars));
const integer = A.regex(/^\d+/).map((x) => BigInt(x));
const string = A.regex(/^.*/).map(utf8ToUint8Array);
const templateVarValue = A.choice([hexBytes, integer, string]);
const templateVar = A.coroutine((parse) => {
    const name = parse(templateVarName);
    parse(A.char('='));
    const value = parse(templateVarValue);
    parse(A.endOfInput);
    return [name, value];
});
const parseCliTemplateVar = (text) => {
    const result = templateVar.run(text);
    if (result.isError) {
        throw new Error('Cannot parse cli template var. Make sure it is in the form VAR_NAME={value}', { cause: result.error });
    }
    else {
        return result.result;
    }
};

class TemplateVarFunctionBuilder extends FunctionBuilder {
    ptype = TemplateVarFunction;
    call(args, typeArgs, sourceLocation) {
        const { args: [name, prefix], ptypes: [varType], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 1,
            callLocation: sourceLocation,
            funcName: this.typeDescription,
            argSpec: (a) => [a.required(stringPType), a.optional(stringPType)],
        });
        const nameStr = requireStringConstant(name).value;
        const validName = TemplateVarNameRegex.exec(nameStr);
        if (validName?.[0] !== nameStr) {
            logger.error(name.sourceLocation, 'Invalid name. Template variable names must only contain capital letters A-Z, numbers 0-9, and underscores');
        }
        const prefixStr = prefix ? requireStringConstant(prefix).value : 'TMPL_';
        return instanceEb(nodeFactory.templateVar({
            name: `${prefixStr}${nameStr}`,
            wtype: varType.wtypeOrThrow,
            sourceLocation,
        }), varType);
    }
}

class GroupTransactionExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof GroupTransactionPType, 'ptype must be GroupTransactionPType');
        super(expr, ptype);
    }
    hasProperty(name) {
        const txnKind = this.ptype.kind;
        const fields = txnKind === undefined ? anyTxnFields : txnKindToFields[txnKind];
        return name in fields;
    }
    memberAccess(name, sourceLocation) {
        const txnKind = this.ptype.kind;
        const fields = txnKind === undefined ? anyTxnFields : txnKindToFields[txnKind];
        if (name in fields) {
            const { field, ptype: returnType } = fields[name];
            const data = TxnFields[field];
            if (data.numValues === 1) {
                return instanceEb(nodeFactory.intrinsicCall({
                    sourceLocation,
                    stackArgs: [this._expr],
                    immediates: [data.immediate],
                    wtype: data.wtype,
                    opCode: 'gtxns',
                }), returnType);
            }
            else {
                return new IndexedTransactionFieldFunctionBuilder(this._expr, {
                    txnData: data,
                    returnType,
                    memberName: name,
                });
            }
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class GroupTransactionFunctionBuilder extends FunctionBuilder {
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof TransactionFunctionType, 'ptype must be instance of TransactionFunctionType');
        this.ptype = ptype;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [groupIndexBuilder], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: this.ptype.name,
            argSpec: (a) => [a.required(uint64PType)],
        });
        const txnPType = getGroupTransactionType(this.ptype.kind);
        const groupIndex = groupIndexBuilder.resolve();
        if (groupIndex instanceof IntegerConstant && groupIndex.value >= Constants.algo.maxTransactionGroupSize) {
            logger.error(groupIndex.sourceLocation, `transaction group index should be less than ${Constants.algo.maxTransactionGroupSize}`);
        }
        return new GroupTransactionExpressionBuilder(nodeFactory.groupTransactionReference({
            index: groupIndex,
            wtype: txnPType.wtype,
            sourceLocation,
        }), txnPType);
    }
}
class IndexedTransactionFieldFunctionBuilder extends FunctionBuilder {
    gtxn;
    config;
    constructor(gtxn, config) {
        super(gtxn.sourceLocation);
        this.gtxn = gtxn;
        this.config = config;
    }
    call(args, typeArgs, sourceLocation) {
        const { args: [index], } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: this.config.memberName,
            argSpec: (a) => [a.required(uint64PType)],
        });
        return instanceEb(nodeFactory.intrinsicCall({
            sourceLocation,
            stackArgs: [this.gtxn, index.resolve()],
            immediates: [this.config.txnData.immediate],
            wtype: this.config.txnData.wtype,
            opCode: 'gtxnsas',
        }), this.config.returnType);
    }
}

class Uint64EnumTypeBuilder extends NodeBuilder {
    ptype;
    constructor(sourceLocation, ptype) {
        super(sourceLocation);
        invariant(ptype instanceof Uint64EnumType, 'ptype must be Uint64EnumType');
        this.ptype = ptype;
    }
    memberAccess(name, sourceLocation) {
        if (name in this.ptype.members) {
            return new Uint64EnumMemberExpressionBuilder(nodeFactory.uInt64Constant({
                value: this.ptype.members[name],
                sourceLocation,
            }), this.ptype.memberType);
        }
        return super.memberAccess(name, sourceLocation);
    }
}
class Uint64EnumMemberExpressionBuilder extends InstanceExpressionBuilder {
    constructor(expr, ptype) {
        invariant(ptype instanceof Uint64EnumMemberType, 'ptype must be Uint64EnumType');
        super(expr, ptype);
    }
    compare(other, op, sourceLocation) {
        const otherExpr = requireExpressionOfType(other, uint64PType);
        return compareUint64(this._expr, otherExpr, op, sourceLocation, this.typeDescription);
    }
    resolvableToPType(ptype) {
        return ptype.equals(this.ptype) || ptype.equals(uint64PType);
    }
    resolveToPType(ptype) {
        if (ptype.equals(uint64PType)) {
            return instanceEb(nodeFactory.reinterpretCast({
                expr: this._expr,
                wtype: wtypes.uint64WType,
                sourceLocation: this.sourceLocation,
            }), uint64PType);
        }
        return super.resolveToPType(ptype);
    }
}

class UnresolvableExpressionBuilder extends InstanceExpressionBuilder {
    resolve() {
        throw new CodeError(`Cannot resolve expression of type ${this.typeDescription}`, { sourceLocation: this.sourceLocation });
    }
    resolveLValue() {
        throw new CodeError(`Expression of type ${this.typeDescription} is not a valid assignment target`, {
            sourceLocation: this.sourceLocation,
        });
    }
}

class UrangeFunctionBuilder extends FunctionBuilder {
    call(args, typeArgs, sourceLocation) {
        const { args: uArgs } = parseFunctionArgs({
            args,
            typeArgs,
            genericTypeArgs: 0,
            callLocation: sourceLocation,
            funcName: 'urange',
            argSpec: (a) => [a.required(uint64PType), ...args.slice(1, 3).map((_) => a.required(uint64PType))],
        });
        let expr;
        if (uArgs.length === 1) {
            expr = nodeFactory.range({
                start: nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
                stop: uArgs[0].resolve(),
                step: nodeFactory.uInt64Constant({ value: 1n, sourceLocation }),
                sourceLocation,
                wtype: wtypes.uint64RangeWType,
            });
        }
        else if (uArgs.length === 2) {
            expr = nodeFactory.range({
                start: uArgs[0].resolve(),
                stop: uArgs[1].resolve(),
                step: nodeFactory.uInt64Constant({ value: 1n, sourceLocation }),
                sourceLocation,
                wtype: wtypes.uint64RangeWType,
            });
        }
        else {
            expr = nodeFactory.range({
                start: uArgs[0].resolve(),
                stop: uArgs[1].resolve(),
                step: uArgs[2].resolve(),
                sourceLocation,
                wtype: wtypes.uint64RangeWType,
            });
        }
        return new IterableIteratorExpressionBuilder(expr, IterableIteratorGeneric.parameterise([uint64PType]));
    }
}

function registerPTypes(typeRegistry) {
    if (typeRegistry.hasRegistrations) {
        return;
    }
    // Primitives
    typeRegistry.register({ ptype: neverPType, instanceEb: NeverExpressionBuilder });
    typeRegistry.register({ ptype: boolPType, instanceEb: BooleanExpressionBuilder });
    typeRegistry.register({ ptype: BooleanFunction, singletonEb: BooleanFunctionBuilder });
    typeRegistry.register({ ptype: uint64PType, instanceEb: UInt64ExpressionBuilder });
    typeRegistry.register({ ptype: Uint64Function, singletonEb: UInt64FunctionBuilder });
    typeRegistry.register({ ptype: biguintPType, instanceEb: BigUintExpressionBuilder });
    typeRegistry.register({ ptype: BigUintFunction, singletonEb: BigUintFunctionBuilder });
    typeRegistry.register({ ptype: bytesPType, instanceEb: BytesExpressionBuilder });
    typeRegistry.register({ ptype: BytesFunction, singletonEb: BytesFunctionBuilder });
    typeRegistry.register({ ptype: stringPType, instanceEb: StringExpressionBuilder });
    typeRegistry.register({ ptype: voidPType, instanceEb: VoidExpressionBuilder });
    typeRegistry.register({ ptype: StringFunction, singletonEb: StringFunctionBuilder });
    // Compound
    typeRegistry.register({ ptype: ArrayPType, instanceEb: NativeArrayExpressionBuilder });
    typeRegistry.register({ ptype: TuplePType, instanceEb: TupleExpressionBuilder });
    typeRegistry.register({ ptype: ObjectPType, instanceEb: ObjectExpressionBuilder });
    typeRegistry.register({ ptype: MutableArrayConstructor, singletonEb: MutableArrayClassBuilder });
    typeRegistry.registerGeneric({ generic: MutableArrayGeneric, ptype: MutableArrayType, instanceEb: MutableArrayExpressionBuilder });
    // Unresolvable
    typeRegistry.registerGeneric({ ptype: GeneratorType, generic: GeneratorGeneric, instanceEb: UnresolvableExpressionBuilder });
    typeRegistry.registerGeneric({ ptype: PromiseType, generic: PromiseGeneric, instanceEb: UnresolvableExpressionBuilder });
    typeRegistry.register({ ptype: ClassMethodDecoratorContext, instanceEb: UnresolvableExpressionBuilder });
    typeRegistry.registerGeneric({
        ptype: SuperPrototypeSelector,
        generic: SuperPrototypeSelectorGeneric,
        instanceEb: UnresolvableExpressionBuilder,
    });
    typeRegistry.register({ ptype: PolytypeClassMethodHelper, instanceEb: UnresolvableExpressionBuilder });
    // Lib functions
    typeRegistry.register({ ptype: logFunction, singletonEb: LogFunctionBuilder });
    typeRegistry.register({ ptype: assertFunction, singletonEb: AssertFunctionBuilder });
    typeRegistry.register({ ptype: errFunction, singletonEb: ErrFunctionBuilder });
    typeRegistry.register({ ptype: matchFunction, singletonEb: MatchFunctionBuilder });
    typeRegistry.register({ ptype: assertMatchFunction, singletonEb: AssertMatchFunctionBuilder });
    typeRegistry.register({ ptype: ensureBudgetFunction, singletonEb: EnsureBudgetFunctionBuilder });
    typeRegistry.register({ ptype: urangeFunction, singletonEb: UrangeFunctionBuilder });
    typeRegistry.register({ ptype: TemplateVarFunction, singletonEb: TemplateVarFunctionBuilder });
    typeRegistry.register({ ptype: compileFunctionType, singletonEb: CompileFunctionBuilder });
    typeRegistry.register({ ptype: arc28EmitFunction, singletonEb: Arc28EmitFunctionBuilder });
    typeRegistry.register({ ptype: ContractClassPType, singletonEb: ContractClassBuilder });
    typeRegistry.register({ ptype: contractOptionsDecorator, singletonEb: ContractOptionsDecoratorBuilder });
    typeRegistry.register({ ptype: LogicSigPType, singletonEb: LogicSigClassBuilder });
    typeRegistry.register({ ptype: logicSigOptionsDecorator, singletonEb: LogicSigOptionsDecoratorBuilder });
    for (const enumType of [opUpFeeSourceType, onCompleteActionType, transactionTypeType]) {
        typeRegistry.register({ ptype: enumType, singletonEb: Uint64EnumTypeBuilder });
        typeRegistry.register({ ptype: enumType.memberType, instanceEb: Uint64EnumMemberExpressionBuilder });
    }
    typeRegistry.register({ ptype: Uint64EnumMemberType, instanceEb: Uint64EnumMemberExpressionBuilder });
    typeRegistry.registerGeneric({
        generic: IterableIteratorGeneric,
        ptype: IterableIteratorType,
        instanceEb: IterableIteratorExpressionBuilder,
    });
    typeRegistry.register({ ptype: FunctionPType, singletonEb: FreeSubroutineExpressionBuilder });
    // Op types
    typeRegistry.register({ ptype: NamespacePType, singletonEb: NamespaceBuilder });
    for (const enumPType of ALL_OP_ENUMS) {
        typeRegistry.register({ ptype: enumPType, singletonEb: IntrinsicEnumBuilder });
    }
    for (const [name, metadata] of Object.entries(OP_METADATA)) {
        if (metadata.type === 'op-grouping') {
            typeRegistry.register({
                ptype: new IntrinsicFunctionGroupType({
                    name,
                }),
                singletonEb: IntrinsicOpGroupBuilder,
            });
            typeRegistry.register({
                ptype: new IntrinsicFunctionGroupTypeType({
                    name: `${name}Type`,
                }),
                instanceEb: IntrinsicOpGroupOrFunctionTypeBuilder,
            });
        }
        else {
            typeRegistry.register({
                ptype: new IntrinsicFunctionType({
                    name,
                }),
                singletonEb: FreeIntrinsicOpBuilder,
            });
            typeRegistry.register({
                ptype: new IntrinsicFunctionTypeType({
                    name: `${name}Type`,
                }),
                instanceEb: IntrinsicOpGroupOrFunctionTypeBuilder,
            });
        }
    }
    // State
    typeRegistry.register({ ptype: GlobalStateFunction, singletonEb: GlobalStateFunctionBuilder });
    typeRegistry.registerGeneric({ generic: GlobalStateGeneric, ptype: GlobalStateType, instanceEb: GlobalStateExpressionBuilder });
    typeRegistry.register({ ptype: LocalStateFunction, singletonEb: LocalStateFunctionBuilder });
    typeRegistry.registerGeneric({ generic: LocalStateGeneric, ptype: LocalStateType, instanceEb: LocalStateExpressionBuilder });
    typeRegistry.register({ ptype: BoxFunction, singletonEb: BoxFunctionBuilder });
    typeRegistry.registerGeneric({ generic: BoxGeneric, ptype: BoxPType, instanceEb: BoxExpressionBuilder });
    typeRegistry.register({ ptype: BoxMapFunction, singletonEb: BoxMapFunctionBuilder });
    typeRegistry.registerGeneric({ generic: BoxMapGeneric, ptype: BoxMapPType, instanceEb: BoxMapExpressionBuilder });
    typeRegistry.register({ ptype: BoxRefFunction, singletonEb: BoxRefFunctionBuilder });
    typeRegistry.register({ ptype: boxRefType, instanceEb: BoxRefExpressionBuilder });
    // Reference types
    typeRegistry.register({ ptype: ApplicationFunctionType, singletonEb: ApplicationFunctionBuilder });
    typeRegistry.register({ ptype: applicationPType, instanceEb: ApplicationExpressionBuilder });
    typeRegistry.register({ ptype: AccountFunction, singletonEb: AccountFunctionBuilder });
    typeRegistry.register({ ptype: accountPType, instanceEb: AccountExpressionBuilder });
    typeRegistry.register({ ptype: AssetFunction, singletonEb: AssetFunctionBuilder });
    typeRegistry.register({ ptype: assetPType, instanceEb: AssetExpressionBuilder });
    // ARC4 encoded
    typeRegistry.register({ ptype: UintNClass, singletonEb: UintNClassBuilder });
    typeRegistry.register({ ptype: arc4AbiMethodDecorator, singletonEb: Arc4AbiMethodDecoratorBuilder });
    typeRegistry.register({ ptype: arc4BareMethodDecorator, singletonEb: Arc4BareMethodDecoratorBuilder });
    typeRegistry.register({ ptype: ByteClass, singletonEb: classBuilderForUintNAlias(ByteClass, arc4ByteAlias) });
    typeRegistry.register({ ptype: UintN8Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 8n })) });
    typeRegistry.register({ ptype: UintN16Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 16n })) });
    typeRegistry.register({ ptype: UintN32Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 32n })) });
    typeRegistry.register({ ptype: UintN64Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 64n })) });
    typeRegistry.register({ ptype: UintN128Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 128n })) });
    typeRegistry.register({ ptype: UintN256Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 256n })) });
    typeRegistry.registerGeneric({ generic: UintNGeneric, ptype: UintNType, instanceEb: UintNExpressionBuilder });
    typeRegistry.register({ ptype: UFixedNxMClass, singletonEb: UFixedNxMClassBuilder });
    typeRegistry.registerGeneric({ generic: UFixedNxMGeneric, ptype: UFixedNxMType, instanceEb: UFixedNxMExpressionBuilder });
    typeRegistry.register({ ptype: arc4ByteAlias, instanceEb: UintNExpressionBuilder });
    // More specific types need to be registered before their base types
    // This ensures the specific type is selected during type resolution
    // For example, StaticBytesExpressionBuilder should be selected over general StaticArrayExpressionBuilder for StaticBytesType
    typeRegistry.register({ ptype: DynamicBytesConstructor, singletonEb: DynamicBytesClassBuilder });
    typeRegistry.register({ ptype: StaticBytesConstructor, singletonEb: StaticBytesClassBuilder });
    typeRegistry.register({ ptype: DynamicBytesType, instanceEb: DynamicBytesExpressionBuilder });
    typeRegistry.registerGeneric({ generic: StaticBytesGeneric, ptype: StaticBytesType, instanceEb: StaticBytesExpressionBuilder });
    typeRegistry.register({ ptype: DynamicArrayConstructor, singletonEb: DynamicArrayClassBuilder });
    typeRegistry.registerGeneric({ generic: DynamicArrayGeneric, ptype: DynamicArrayType, instanceEb: DynamicArrayExpressionBuilder });
    typeRegistry.register({ ptype: StaticArrayConstructor, singletonEb: StaticArrayClassBuilder });
    typeRegistry.registerGeneric({ generic: StaticArrayGeneric, ptype: StaticArrayType, instanceEb: StaticArrayExpressionBuilder });
    typeRegistry.register({ ptype: arc4AddressAlias, instanceEb: AddressExpressionBuilder });
    typeRegistry.register({ ptype: AddressClass, singletonEb: AddressClassBuilder });
    typeRegistry.register({ ptype: ARC4BoolClass, singletonEb: BoolClassBuilder });
    typeRegistry.register({ ptype: arc4BooleanType, instanceEb: BoolExpressionBuilder });
    typeRegistry.register({ ptype: arc4StringType, instanceEb: StrExpressionBuilder });
    typeRegistry.register({ ptype: ARC4StrClass, singletonEb: StrClassBuilder });
    typeRegistry.register({ ptype: Arc4TupleClass, singletonEb: Arc4TupleClassBuilder });
    typeRegistry.registerGeneric({ generic: Arc4TupleGeneric, ptype: ARC4TupleType, instanceEb: Arc4TupleExpressionBuilder });
    typeRegistry.register({ ptype: ARC4StructType, instanceEb: StructExpressionBuilder });
    typeRegistry.register({ ptype: ARC4StructClass, singletonEb: StructClassBuilder });
    // ARC4 lib
    typeRegistry.register({ ptype: interpretAsArc4Function, singletonEb: InterpretAsArc4FunctionBuilder });
    typeRegistry.register({ ptype: encodeArc4Function, singletonEb: EncodeArc4FunctionBuilder });
    typeRegistry.register({ ptype: decodeArc4Function, singletonEb: DecodeArc4FunctionBuilder });
    typeRegistry.register({ ptype: methodSelectorFunction, singletonEb: MethodSelectorFunctionBuilder });
    typeRegistry.register({ ptype: arc4EncodedLengthFunction, singletonEb: Arc4EncodedLengthFunctionBuilder });
    typeRegistry.register({ ptype: compileArc4Function, singletonEb: CompileArc4FunctionBuilder });
    typeRegistry.register({ ptype: abiCallFunction, singletonEb: AbiCallFunctionBuilder });
    typeRegistry.registerGeneric({ ptype: ContractProxyType, generic: ContractProxyGeneric, instanceEb: ContractProxyExpressionBuilder });
    // GTXN types
    typeRegistry.register({ ptype: paymentGtxnType, instanceEb: GroupTransactionExpressionBuilder });
    typeRegistry.register({ ptype: PaymentTxnFunction, singletonEb: GroupTransactionFunctionBuilder });
    typeRegistry.register({ ptype: keyRegistrationGtxnType, instanceEb: GroupTransactionExpressionBuilder });
    typeRegistry.register({ ptype: KeyRegistrationTxnFunction, singletonEb: GroupTransactionFunctionBuilder });
    typeRegistry.register({ ptype: assetConfigGtxnType, instanceEb: GroupTransactionExpressionBuilder });
    typeRegistry.register({ ptype: AssetConfigTxnFunction, singletonEb: GroupTransactionFunctionBuilder });
    typeRegistry.register({ ptype: assetTransferGtxnType, instanceEb: GroupTransactionExpressionBuilder });
    typeRegistry.register({ ptype: AssetTransferTxnFunction, singletonEb: GroupTransactionFunctionBuilder });
    typeRegistry.register({ ptype: assetFreezeGtxnType, instanceEb: GroupTransactionExpressionBuilder });
    typeRegistry.register({ ptype: AssetFreezeTxnFunction, singletonEb: GroupTransactionFunctionBuilder });
    typeRegistry.register({ ptype: applicationCallGtxnType, instanceEb: GroupTransactionExpressionBuilder });
    typeRegistry.register({ ptype: ApplicationTxnFunction, singletonEb: GroupTransactionFunctionBuilder });
    typeRegistry.register({ ptype: anyGtxnType, instanceEb: GroupTransactionExpressionBuilder });
    typeRegistry.register({ ptype: TransactionFunction, singletonEb: GroupTransactionFunctionBuilder });
    // ITXN Types
    typeRegistry.register({ ptype: paymentItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder });
    typeRegistry.register({ ptype: keyRegistrationItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder });
    typeRegistry.register({ ptype: assetConfigItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder });
    typeRegistry.register({ ptype: assetTransferItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder });
    typeRegistry.register({ ptype: assetFreezeItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder });
    typeRegistry.register({ ptype: applicationCallItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder });
    typeRegistry.register({ ptype: submitGroupItxnFunction, singletonEb: SubmitItxnGroupFunctionBuilder });
    typeRegistry.register({ ptype: paymentItxnType, instanceEb: InnerTransactionExpressionBuilder });
    typeRegistry.register({ ptype: keyRegistrationItxnType, instanceEb: InnerTransactionExpressionBuilder });
    typeRegistry.register({ ptype: assetConfigItxnType, instanceEb: InnerTransactionExpressionBuilder });
    typeRegistry.register({ ptype: assetTransferItxnType, instanceEb: InnerTransactionExpressionBuilder });
    typeRegistry.register({ ptype: assetFreezeItxnType, instanceEb: InnerTransactionExpressionBuilder });
    typeRegistry.register({ ptype: applicationItxnType, instanceEb: InnerTransactionExpressionBuilder });
    typeRegistry.register({ ptype: paymentItxnParamsType, instanceEb: ItxnParamsExpressionBuilder });
    typeRegistry.register({ ptype: keyRegistrationItxnParamsType, instanceEb: ItxnParamsExpressionBuilder });
    typeRegistry.register({ ptype: assetConfigItxnParamsType, instanceEb: ItxnParamsExpressionBuilder });
    typeRegistry.register({ ptype: assetTransferItxnParamsType, instanceEb: ItxnParamsExpressionBuilder });
    typeRegistry.register({ ptype: assetFreezeItxnParamsType, instanceEb: ItxnParamsExpressionBuilder });
    typeRegistry.register({ ptype: applicationCallItxnParamsType, instanceEb: ItxnParamsExpressionBuilder });
}

class FunctionTraverser {
    visitExpressionStatement(statement) {
        statement.expr.accept(this);
    }
    visitBlock(statement) {
        for (const s of statement.body) {
            s.accept(this);
        }
    }
    visitArrayLength(expression) {
        expression.array.accept(this);
    }
    visitArrayReplace(expression) {
        expression.base.accept(this);
        expression.index.accept(this);
        expression.value.accept(this);
    }
    visitGoto(statement) { }
    visitIfElse(statement) {
        statement.condition.accept(this);
        statement.ifBranch.accept(this);
        statement.elseBranch?.accept(this);
    }
    visitSwitch(statement) {
        statement.value.accept(this);
        for (const [cv, cb] of statement.cases.entries()) {
            cv.accept(this);
            cb.accept(this);
        }
        statement.defaultCase?.accept(this);
    }
    visitWhileLoop(statement) {
        statement.condition.accept(this);
        statement.loopBody.accept(this);
    }
    visitLoopExit(statement) { }
    visitLoopContinue(statement) { }
    visitReturnStatement(statement) {
        statement.value?.accept(this);
    }
    visitAssignmentStatement(statement) {
        statement.target.accept(this);
        statement.value.accept(this);
    }
    visitUInt64AugmentedAssignment(statement) {
        statement.target.accept(this);
        statement.value.accept(this);
    }
    visitBigUIntAugmentedAssignment(statement) {
        statement.target.accept(this);
        statement.value.accept(this);
    }
    visitBytesAugmentedAssignment(statement) {
        statement.target.accept(this);
        statement.value.accept(this);
    }
    visitForInLoop(statement) {
        statement.items.accept(this);
        statement.sequence.accept(this);
        statement.loopBody.accept(this);
    }
    visitAssertExpression(expression) {
        expression.condition?.accept(this);
    }
    visitIntegerConstant(expression) { }
    visitDecimalConstant(expression) { }
    visitBoolConstant(expression) { }
    visitBytesConstant(expression) { }
    visitStringConstant(expression) { }
    visitVoidConstant(expression) { }
    visitTemplateVar(expression) { }
    visitMethodConstant(expression) { }
    visitAddressConstant(expression) { }
    visitARC4Encode(expression) {
        expression.value.accept(this);
    }
    visitCopy(expression) {
        expression.value.accept(this);
    }
    visitArrayConcat(expression) {
        expression.left.accept(this);
        expression.right.accept(this);
    }
    visitArrayPop(expression) {
        expression.base.accept(this);
    }
    visitArrayExtend(expression) {
        expression.base.accept(this);
        expression.other.accept(this);
    }
    visitARC4Decode(expression) {
        expression.value.accept(this);
    }
    visitIntrinsicCall(expression) {
        for (const a of expression.stackArgs) {
            a.accept(this);
        }
    }
    visitCreateInnerTransaction(expression) {
        for (const v of expression.fields.values()) {
            v.accept(this);
        }
    }
    visitUpdateInnerTransaction(expression) {
        for (const v of expression.fields.values()) {
            v.accept(this);
        }
    }
    visitGroupTransactionReference(expression) {
        expression.index.accept(this);
    }
    visitCheckedMaybe(expression) {
        expression.expr.accept(this);
    }
    visitTupleExpression(expression) {
        for (const v of expression.items) {
            v.accept(this);
        }
    }
    visitTupleItemExpression(expression) {
        expression.base.accept(this);
    }
    visitVarExpression(expression) { }
    visitInnerTransactionField(expression) {
        expression.itxn.accept(this);
        expression.arrayIndex?.accept(this);
    }
    visitSubmitInnerTransaction(expression) {
        for (const itxn of expression.itxns) {
            itxn.accept(this);
        }
    }
    visitFieldExpression(expression) {
        expression.base.accept(this);
    }
    visitIndexExpression(expression) {
        expression.base.accept(this);
        expression.index.accept(this);
    }
    visitSliceExpression(expression) {
        expression.base.accept(this);
        expression.beginIndex?.accept(this);
        expression.endIndex?.accept(this);
    }
    visitIntersectionSliceExpression(expression) {
        expression.base.accept(this);
        expression.beginIndex instanceof Expression && expression.beginIndex.accept(this);
        expression.endIndex instanceof Expression && expression.endIndex.accept(this);
    }
    visitAppStateExpression(expression) {
        expression.key.accept(this);
    }
    visitAppAccountStateExpression(expression) {
        expression.key.accept(this);
        expression.account.accept(this);
    }
    visitBoxValueExpression(expression) {
        expression.key.accept(this);
    }
    visitSingleEvaluation(expression) {
        expression.source.accept(this);
    }
    visitReinterpretCast(expression) {
        expression.expr.accept(this);
    }
    visitNewArray(expression) {
        for (const v of expression.values) {
            v.accept(this);
        }
    }
    visitConditionalExpression(expression) {
        expression.condition.accept(this);
        expression.trueExpr.accept(this);
        expression.falseExpr.accept(this);
    }
    visitAssignmentExpression(expression) {
        expression.target.accept(this);
        expression.value.accept(this);
    }
    visitNumericComparisonExpression(expression) {
        expression.lhs.accept(this);
        expression.rhs.accept(this);
    }
    visitBytesComparisonExpression(expression) {
        expression.lhs.accept(this);
        expression.rhs.accept(this);
    }
    visitSubroutineCallExpression(expression) {
        for (const a of expression.args) {
            a.value.accept(this);
        }
    }
    visitPuyaLibCall(expression) {
        for (const a of expression.args) {
            a.value.accept(this);
        }
    }
    visitUInt64UnaryOperation(expression) {
        expression.expr.accept(this);
    }
    visitUInt64PostfixUnaryOperation(expression) {
        expression.target.accept(this);
    }
    visitBigUIntPostfixUnaryOperation(expression) {
        expression.target.accept(this);
    }
    visitBytesUnaryOperation(expression) {
        expression.expr.accept(this);
    }
    visitUInt64BinaryOperation(expression) {
        expression.left.accept(this);
        expression.right.accept(this);
    }
    visitBigUIntBinaryOperation(expression) {
        expression.left.accept(this);
        expression.right.accept(this);
    }
    visitBytesBinaryOperation(expression) {
        expression.left.accept(this);
        expression.right.accept(this);
    }
    visitBooleanBinaryOperation(expression) {
        expression.left.accept(this);
        expression.right.accept(this);
    }
    visitNot(expression) {
        expression.expr.accept(this);
    }
    visitEmit(expression) {
        expression.value.accept(this);
    }
    visitRange(expression) {
        expression.start.accept(this);
        expression.stop.accept(this);
        expression.step.accept(this);
    }
    visitEnumeration(expression) {
        expression.expr.accept(this);
    }
    visitReversed(expression) {
        expression.expr.accept(this);
    }
    visitStateGet(expression) {
        expression.default.accept(this);
        expression.field.accept(this);
    }
    visitStateGetEx(expression) {
        expression.field.accept(this);
    }
    visitStateExists(expression) {
        expression.field.accept(this);
    }
    visitStateDelete(expression) {
        expression.field.accept(this);
    }
    visitNewStruct(expression) {
        for (const v of expression.values.values()) {
            v.accept(this);
        }
    }
    visitCompiledContract(expression) {
        for (const v of expression.templateVariables.values()) {
            v.accept(this);
        }
        for (const v of expression.allocationOverrides.values()) {
            v.accept(this);
        }
    }
    visitCompiledLogicSig(expression) {
        for (const v of expression.templateVariables.values()) {
            v.accept(this);
        }
    }
    visitARC4Router(expression) { }
}

class Arc4ApprovalCallsRouter extends FunctionTraverser {
    static validate(awst) {
        for (const item of awst) {
            if (item instanceof Contract) {
                if (item.methods.some((m) => m.arc4MethodConfig)) {
                    const validator = new Arc4ApprovalCallsRouter();
                    validator.validate(item.approvalProgram);
                }
            }
        }
    }
    #superCalled = false;
    #routerCalled = false;
    validate(approvalProgram) {
        approvalProgram.body.accept(this);
        if (!this.#superCalled && !this.#routerCalled) {
            logger.warn(approvalProgram.sourceLocation, 'Contract overrides approval program method but does not appear to call super.approvalProgram(). ARC4 routing may not work as expected');
        }
    }
    visitSubroutineCallExpression(expression) {
        if (expression.target instanceof InstanceSuperMethodTarget &&
            expression.target.memberName === Constants.symbolNames.approvalProgramMethodName) {
            this.#superCalled = true;
        }
        super.visitSubroutineCallExpression(expression);
    }
    visitARC4Router(expression) {
        this.#routerCalled = true;
        super.visitARC4Router(expression);
    }
}

const validators = [Arc4ApprovalCallsRouter];
function validateAwst(awst) {
    for (const validator of validators) {
        validator.validate(awst);
    }
}

function positiveMod(x, m) {
    return ((x % m) + m) % m;
}
function repeat(c, n) {
    return new Array(n).fill(c);
}
function* batchBytesToUintN(bytes, n) {
    const numberBytes = n / 8;
    for (let i = 0; i < bytes.length / numberBytes; i += 1) {
        yield new Array(numberBytes).fill(null).reduce((acc, _, index) => {
            const offset = index + i * numberBytes;
            if (offset >= bytes.length) {
                throw new Error('Needs padding');
            }
            return (acc << 8n) + BigInt(bytes[offset]);
        }, 0n);
    }
}
/**
 * This implementation of base85 encoding matches python's base64.b85encode(...) function which is based on the character set of rfc1924
 * but supports arbitrary sized input.
 *
 * It IS NOT an ascii85 implementation
 */
function buildBase85Encoder() {
    const b85Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~';
    const b85Chars = b85Alphabet.split('');
    const b85DoubleChars = b85Chars.flatMap((c) => b85Chars.map((c2) => c + c2));
    function encode(b, chars, doubleChars) {
        const padding = positiveMod(-b.length, 4);
        if (padding) {
            b = new Uint8Array([...b, ...repeat(0, padding)]);
        }
        let result = '';
        for (const word of batchBytesToUintN(b, 4 * 8)) {
            result += doubleChars[Number(word / 85n ** 3n)];
            result += doubleChars[Number((word / 85n) % 85n ** 2n)];
            result += chars[Number(word % 85n)];
        }
        return result.slice(0, result.length - padding);
    }
    return {
        encode(b) {
            return encode(b, b85Chars, b85DoubleChars);
        },
        encodeUtf8(s) {
            const b = new TextEncoder().encode(s);
            return this.encode(b);
        },
    };
}

function serializeBigInt(value) {
    const jsonWithRaw = JSON;
    if (jsonWithRaw.rawJSON) {
        return jsonWithRaw.rawJSON(`${value}`);
    }
    if (value < 0n) {
        if (value < Number.MIN_SAFE_INTEGER) {
            throw new InternalError(`Cannot safely serialize ${value} to JSON`);
        }
        return Number(value);
    }
    else {
        if (value > Number.MAX_SAFE_INTEGER) {
            return `${value}`;
        }
        return Number(value);
    }
}
class SnakeCaseSerializer {
    spaces;
    constructor(spaces = 2) {
        this.spaces = spaces;
    }
    serialize(obj) {
        return JSON.stringify(obj, (k, v) => this.serializerFunction(k, v), this.spaces);
    }
    b85 = buildBase85Encoder();
    serializerFunction(key, value) {
        if (typeof value === 'bigint') {
            return serializeBigInt(value);
        }
        if (value instanceof Uint8Array) {
            return this.b85.encode(value);
        }
        if (value instanceof Object && value.constructor.name !== 'Date' && value.constructor.name !== 'Object') {
            return {
                ...Object.fromEntries(Object.entries(value).map(([key, value]) => [snakeCase(key), value])),
            };
        }
        return value;
    }
}
class AwstSerializer extends SnakeCaseSerializer {
    options;
    constructor(options) {
        super();
        this.options = options;
    }
    #singleEvals = new SymbolToNumber();
    serializerFunction(key, value) {
        if (value instanceof Set) {
            return Array.from(value.keys());
        }
        if (value instanceof Array) {
            return value;
        }
        if (value instanceof Map) {
            if (value.size === 0)
                return {};
            const keyType = typeof value.keys().next().value;
            if (keyType === 'string' || keyType === 'number') {
                return Object.fromEntries(value.entries());
            }
            if (keyType === 'bigint') {
                return Object.fromEntries(Array.from(value.entries()).map(([k, v]) => [`${k}`, v]));
            }
            return Array.from(value.entries());
        }
        if (value instanceof Uint8Array) {
            return super.serializerFunction(key, value);
        }
        if (value instanceof ContractReference || value instanceof LogicSigReference) {
            return value.toString();
        }
        if (value instanceof IntrinsicCall) {
            // Convert bigint immediates to number so they serialize without quotes and can be disambiguated from string immediates
            return {
                _type: IntrinsicCall.name,
                ...super.serializerFunction(key, value),
                immediates: value.immediates.map((i) => {
                    if (typeof i === 'bigint') {
                        return serializeBigInt(i);
                    }
                    return i;
                }),
            };
        }
        if (value instanceof SourceLocation && value.file) {
            let filePath = value.file;
            if (this.options?.sourcePaths === 'absolute' && !path.isAbsolute(value.file)) {
                invariant(this.options.programDirectory, 'Program directory must be supplied for absolute paths');
                if (value.file.startsWith(Constants.algoTsPackage)) {
                    filePath = path.join(this.options.programDirectory, 'node_modules', value.file);
                }
                else {
                    filePath = path.join(this.options.programDirectory, value.file);
                }
            }
            return {
                ...super.serializerFunction(key, value),
                scope: undefined,
                file: filePath,
            };
        }
        if (value instanceof SingleEvaluation) {
            return {
                _type: SingleEvaluation.name,
                ...super.serializerFunction(key, value),
                _id: String(this.#singleEvals.forSymbol(value.id)[0]),
            };
        }
        if (value instanceof Object && value.constructor.name !== 'Object') {
            return {
                _type: value.constructor.name,
                ...super.serializerFunction(key, value),
            };
        }
        return super.serializerFunction(key, value);
    }
}
function jsonSerializeAwst(awst) {
    return new AwstSerializer().serialize(awst);
}

function printBytes(value, encoding) {
    switch (encoding) {
        case BytesEncoding.utf8:
            return `"${uint8ArrayToUtf8(value)}"`;
        case BytesEncoding.base64:
            return `b64<${Buffer.from(value).toString('base64')}>`;
        case BytesEncoding.base32:
            return `b32<${uint8ArrayToBase32(value)}>`;
        default:
            return `0x${Buffer.from(value).toString('hex')}`;
    }
}
class ToCodeVisitor {
    visitRange(expression) {
        return `urange(${expression.start.accept(this)}, ${expression.stop.accept(this)}, ${expression.step.accept(this)})`;
    }
    visitVoidConstant(expression) {
        return `void`;
    }
    visitGroupTransactionReference(expression) {
        return `group_transaction(index=${expression.index.accept(this)}, type=${expression.wtype})`;
    }
    visitPuyaLibCall(expression) {
        return `${expression.func}(${expression.args.map((a) => a.value.accept(this)).join(', ')})`;
    }
    visitARC4Router(expression) {
        return `arc4Router()`;
    }
    visitAppStorageDefinition(contractMemberNode) {
        throw new Error('Method not implemented.');
    }
    #singleEval = new SymbolToNumber();
    visitUInt64PostfixUnaryOperation(expression) {
        return `${expression.target.accept(this)}${expression.op}`;
    }
    visitBigUIntPostfixUnaryOperation(expression) {
        return `${expression.target.accept(this)}${expression.op}`;
    }
    visitCompiledContract(expression) {
        let overrides = Array.from(expression.allocationOverrides.entries())
            .map(([f, v]) => `${f}=${v.accept(this)}`)
            .join(', ');
        if (overrides) {
            overrides = `, ${overrides}`;
        }
        let templateVars = Array.from(expression.templateVariables.entries())
            .map(([n, v]) => `${n}=${v.accept(this)}`)
            .join(', ');
        if (templateVars) {
            templateVars = `, ${templateVars}`;
        }
        const prefix = expression.prefix ? `, prefix=${expression.prefix}` : '';
        return `compile(${expression.contract.id}${overrides}${prefix}${templateVars}`;
    }
    visitCompiledLogicSig(expression) {
        let templateVars = Array.from(expression.templateVariables.entries())
            .map(([n, v]) => `${n}=${v.accept(this)}`)
            .join(', ');
        if (templateVars) {
            templateVars = `, ${templateVars}`;
        }
        const prefix = expression.prefix ? `, prefix=${expression.prefix}` : '';
        return `compile(${expression.logicSig.id}${prefix}${templateVars}`;
    }
    visitLoopExit(statement) {
        return ['break'];
    }
    visitLoopContinue(statement) {
        return ['continue'];
    }
    visitGoto(statement) {
        return [`goto ${statement.target}`];
    }
    visitIntersectionSliceExpression(expression) {
        const args = [expression.beginIndex, expression.endIndex]
            .flatMap((f) => (typeof f === 'bigint' ? f : (f?.accept(this) ?? [])))
            .join(', ');
        return `${expression.base.accept(this)}.slice(${args})`;
    }
    visitBoxValueExpression(expression) {
        return `Box[${expression.key.accept(this)}].value`;
    }
    visitIntegerConstant(expression) {
        if (expression.tealAlias)
            return expression.tealAlias;
        return `${expression.value}`;
    }
    visitDecimalConstant(expression) {
        return `${expression.value}m`;
    }
    visitBoolConstant(expression) {
        return expression.value ? 'True' : 'False';
    }
    visitBytesConstant(expression) {
        return printBytes(expression.value, expression.encoding);
    }
    visitStringConstant(expression) {
        return `"${expression.value}"`;
    }
    visitTemplateVar(expression) {
        return `TemplateVar[${expression.wtype}](${expression.name})`;
    }
    visitMethodConstant(expression) {
        return `Method("${expression.value}")`;
    }
    visitAddressConstant(expression) {
        return `Address("${expression.value}")`;
    }
    visitARC4Encode(expression) {
        return `ARC4_ENCODE(${expression.value.accept(this)}, wtype=${expression.wtype})`;
    }
    visitCopy(expression) {
        return `copy(${expression.value.accept(this)})`;
    }
    visitArrayConcat(expression) {
        return `${expression.left.accept(this)}.concat(${expression.right.accept(this)})`;
    }
    visitArrayPop(expression) {
        return `${expression.base.accept(this)}.pop()`;
    }
    visitArrayExtend(expression) {
        return `${expression.base.accept(this)}.push(...${expression.other.accept(this)}`;
    }
    visitArrayLength(expression) {
        return `${expression.array.accept(this)}.length`;
    }
    visitArrayReplace(expression) {
        return `${expression.base.accept(this)}.with(${expression.index.accept(this)}, ${expression.value.accept(this)})`;
    }
    visitARC4Decode(expression) {
        return `ARC4_DECODE(${expression.value.accept(this)})`;
    }
    visitIntrinsicCall(expression) {
        const immediates = expression.immediates.length ? `<${expression.immediates.map((i) => i).join(', ')}>` : '';
        const stack = expression.stackArgs.map((a) => a.accept(this)).join(', ');
        return `${expression.opCode}${immediates}(${stack})`;
    }
    visitCreateInnerTransaction(expression) {
        const fields = Array.from(expression.fields.entries())
            .map(([f, v]) => `${f}=${v.accept(this)}`)
            .join(', ');
        return `create_inner_transaction(${fields})`;
    }
    visitUpdateInnerTransaction(expression) {
        const fields = Array.from(expression.fields.entries())
            .map(([f, v]) => `${f}=${v.accept(this)}`)
            .join(', ');
        return `update_inner_transaction(${expression.itxn.accept(this)}, ${fields})`;
    }
    visitCheckedMaybe(expression) {
        return `checked_maybe(${expression.expr.accept(this)}, comment=${expression.comment})`;
    }
    visitTupleExpression(expression) {
        const names = expression.wtype.names;
        if (names) {
            return `{ ${expression.items.map((item, i) => `${names[i]}: ${item.accept(this)}`).join(', ')} }`;
        }
        return `<tuple>[${expression.items.map((i) => i.accept(this)).join(', ')}]`;
    }
    visitTupleItemExpression(expression) {
        return `${expression.base.accept(this)}.${expression.index}`;
    }
    visitVarExpression(expression) {
        return expression.name;
    }
    visitInnerTransactionField(expression) {
        const indexAccess = expression.arrayIndex ? `[${expression.arrayIndex.accept(this)}]` : '';
        return `${expression.itxn.accept(this)}.${expression.field}${indexAccess}`;
    }
    visitSubmitInnerTransaction(expression) {
        return `submit_txn(${expression.itxns.map((i) => i.accept(this)).join(', ')})`;
    }
    visitFieldExpression(expression) {
        return `${expression.base.accept(this)}.${expression.name}`;
    }
    visitIndexExpression(expression) {
        return `${expression.base.accept(this)}[${expression.index.accept(this)}]`;
    }
    visitSliceExpression(expression) {
        return `${expression.base.accept(this)}[${expression.beginIndex?.accept(this) ?? ''}:${expression.endIndex?.accept(this) ?? ''}]`;
    }
    visitAppStateExpression(expression) {
        return `GlobalState[${expression.key.accept(this)}]`;
    }
    visitAppAccountStateExpression(expression) {
        return `LocalState[${expression.account.accept(this)}][${expression.key.accept(this)}]`;
    }
    visitSingleEvaluation(expression) {
        const [id, isNew] = this.#singleEval.forSymbol(expression.id);
        if (!isNew) {
            return `#${id}`;
        }
        return `(#${id} = ${expression.source.accept(this)})`;
    }
    visitReinterpretCast(expression) {
        const target = expression.expr.accept(this);
        if (expression.wtype.equals(wtypes.boolWType)) {
            return `Boolean(${target})`;
        }
        return `reinterpret_cast<${expression.wtype}>(${target})`;
    }
    visitNewArray(expression) {
        return `new ${expression.wtype.name}(${expression.values.map((v) => v.accept(this)).join(', ')})`;
    }
    visitConditionalExpression(expression) {
        return `(${expression.condition.accept(this)} ? ${expression.trueExpr.accept(this)} : ${expression.falseExpr.accept(this)})`;
    }
    visitAssignmentExpression(expression) {
        const rvalue = expression.value instanceof AssignmentExpression ? `(${expression.value.accept(this)})` : expression.value.accept(this);
        return `(${expression.target.accept(this)} = ${rvalue})`;
    }
    visitNumericComparisonExpression(expression) {
        return `${expression.lhs.accept(this)} ${expression.operator} ${expression.rhs.accept(this)}`;
    }
    visitBytesComparisonExpression(expression) {
        return `${expression.lhs.accept(this)} ${expression.operator} ${expression.rhs.accept(this)}`;
    }
    visitSubroutineCallExpression(expression) {
        const target = this.visitCallTarget(expression.target);
        return `${target}(${expression.args.map((a) => a.value.accept(this)).join(', ')})`;
    }
    visitCallTarget(target) {
        if (target instanceof SubroutineID)
            return target.target;
        if (target instanceof ContractMethodTarget)
            return `${target.cref}.${target.memberName}`;
        if (target instanceof InstanceMethodTarget)
            return `this.${target.memberName}`;
        if (target instanceof InstanceSuperMethodTarget)
            return `super.${target.memberName}`;
        throw new InternalError(`Unhandled target: ${target}`);
    }
    visitUInt64UnaryOperation(expression) {
        return `${expression.op}${expression.expr.accept(this)}`;
    }
    visitBytesUnaryOperation(expression) {
        return `${expression.op}${expression.expr.accept(this)}`;
    }
    visitUInt64BinaryOperation(expression) {
        return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`;
    }
    visitBigUIntBinaryOperation(expression) {
        return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`;
    }
    visitBytesBinaryOperation(expression) {
        return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`;
    }
    visitBooleanBinaryOperation(expression) {
        return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`;
    }
    visitNot(expression) {
        return `!${expression.expr.accept(this)}`;
    }
    visitEnumeration(expression) {
        return `enumerate(${expression.expr.accept(this)})`;
    }
    visitReversed(expression) {
        return `reversed(${expression.expr.accept(this)})`;
    }
    visitStateGet(expression) {
        return `STATE_GET(${expression.field.accept(this)}, default=${expression.default.accept(this)})`;
    }
    visitStateDelete(expression) {
        return `STATE_DELETE(${expression.field.accept(this)})`;
    }
    visitStateGetEx(expression) {
        return `STATE_GET_EX(${expression.field.accept(this)})`;
    }
    visitStateExists(expression) {
        return `STATE_EXISTS(${expression.field.accept(this)})`;
    }
    visitNewStruct(expression) {
        const props = Array.from(expression.values)
            .map(([k, v]) => `${k}=${v.accept(this)}`)
            .join(', ');
        return `new ${expression.wtype.name}(${props})`;
    }
    visitExpressionStatement(statement) {
        return [statement.expr.accept(this)];
    }
    visitBlock(statement) {
        return [...(statement.label ? [`${statement.label}:`] : []), ...statement.body.flatMap((b) => b.accept(this))];
    }
    visitIfElse(statement) {
        return [
            `if (${statement.condition.accept(this)}) {`,
            ...indent(statement.ifBranch.accept(this)),
            ...(statement.elseBranch ? ['} else {', ...indent(statement.elseBranch.accept(this)), '}'] : ['}']),
        ];
    }
    visitSwitch(statement) {
        return [
            `switch (${statement.value.accept(this)}) {`,
            ...indent(Array.from(statement.cases.entries()).flatMap(([clause, block]) => [`case ${clause.accept(this)}:`, ...indent(block.accept(this))])),
            ...(statement.defaultCase ? indent(['default:', ...indent(statement.defaultCase.accept(this))]) : []),
            '}',
        ];
    }
    visitWhileLoop(statement) {
        return [`while (${statement.condition.accept(this)}) {`, ...indent(statement.loopBody.accept(this)), '}'];
    }
    visitReturnStatement(statement) {
        return [`return ${statement.value?.accept(this) ?? ''}`];
    }
    visitAssignmentStatement(statement) {
        return [`${statement.target.accept(this)}: ${statement.target.wtype} = ${statement.value.accept(this)}`];
    }
    visitUInt64AugmentedAssignment(statement) {
        return [`${statement.target.accept(this)} = ${statement.target.accept(this)} ${statement.op} ${statement.value.accept(this)}`];
    }
    visitBigUIntAugmentedAssignment(statement) {
        return [`${statement.target.accept(this)} = ${statement.target.accept(this)} ${statement.op} ${statement.value.accept(this)}`];
    }
    visitBytesAugmentedAssignment(statement) {
        return [`${statement.target.accept(this)} = ${statement.target.accept(this)} ${statement.op} ${statement.value.accept(this)}`];
    }
    visitForInLoop(statement) {
        return [
            `for (${statement.items.accept(this)} in ${statement.sequence.accept(this)}) {`,
            ...indent(statement.loopBody.accept(this)),
            '}',
        ];
    }
    visitSubroutine(moduleStatement) {
        const args = moduleStatement.args.map((a) => `${a.name}: ${a.wtype}`).join(', ');
        return [
            `subroutine ${moduleStatement.name}(${args}): ${moduleStatement.returnType}`,
            '{',
            ...indent(moduleStatement.body.accept(this)),
            '}',
        ];
    }
    visitEmit(expression) {
        return `emit("${expression.signature}", ${expression.value.accept(this)})`;
    }
    visitContractMethod(statement) {
        const args = statement.args.map((a) => `${a.name}: ${a.wtype}`).join(', ');
        const prefix = statement.cref.id === this.currentContract.at(-1)?.id ? '' : `${statement.cref.className}::`;
        return [`${prefix}${statement.memberName}(${args}): ${statement.returnType}`, '{', ...indent(statement.body.accept(this)), '}', ''];
    }
    visitLogicSignature(moduleStatement) {
        return ['', `logicsig ${moduleStatement.id} {`, ...indent(moduleStatement.program.body.accept(this)), '}'];
    }
    visitAssertExpression(expression) {
        return [
            expression.condition ? 'assert(' : 'err(',
            expression.condition?.accept(this) ?? '',
            expression.errorMessage ? `, comment=${expression.errorMessage}` : '',
            ')',
        ].join('');
    }
    currentContract = [];
    visitContract(c) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            this.currentContract.push(c.id);
            const _ = __addDisposableResource(env_1, {
                [Symbol.dispose]: () => {
                    this.currentContract.pop();
                },
            }, false);
            const body = [];
            if (c.appState.length) {
                const storageByKind = Array.from(c.appState.values()).reduce((acc, cur) => acc.set(cur.kind, [...(acc.get(cur.kind) ?? []), cur]), new Map());
                for (const [name, kind] of [
                    ['globals', AppStorageKind.appGlobal],
                    ['locals', AppStorageKind.accountLocal],
                    ['boxes', AppStorageKind.box],
                ]) {
                    const items = storageByKind.get(kind);
                    if (items?.length) {
                        body.push(`${name} {`, ...indent(items.map((g) => g.keyWtype ? `[${g.key.accept(this)}]: ${g.keyWtype} => ${g.storageWtype}` : `[${g.key.accept(this)}]: ${g.storageWtype}`)), '}');
                    }
                }
            }
            if (c.reservedScratchSpace.size) {
                body.push(`reservedScratchSpace: [${Array.from(c.reservedScratchSpace).join(', ')}]`);
            }
            if (c.approvalProgram) {
                body.push(...this.visitSpecialMethod(c.approvalProgram, 'approvalProgram'));
            }
            if (c.clearProgram) {
                body.push(...this.visitSpecialMethod(c.clearProgram, 'clearProgram'));
            }
            for (const method of c.methods) {
                body.push(...method.accept(this));
            }
            const header = ['contract', c.name];
            return [header.join(' '), '{', ...indent(body), '}'];
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    }
    visitSpecialMethod(statement, name) {
        return [`${name}(): ${statement.returnType}`, '{', ...indent(statement.body.accept(this)), '}', ''];
    }
}
function indent(lines, indentSize = '  ') {
    return lines.map((l) => `${indentSize}${l}`);
}

var ArtifactKind;
(function (ArtifactKind) {
    ArtifactKind[ArtifactKind["Awst"] = 0] = "Awst";
    ArtifactKind[ArtifactKind["AwstJson"] = 1] = "AwstJson";
})(ArtifactKind || (ArtifactKind = {}));
function writeArtifact({ sourceFile, outDir, kind, obj, buildArtifact, }) {
    let outFilePath;
    switch (kind) {
        case ArtifactKind.Awst:
            outFilePath = upath.join(outDir, `${upath.basename(sourceFile, '.algo.ts')}.awst`);
            break;
        case ArtifactKind.AwstJson:
            outFilePath = upath.join(outDir, `${upath.basename(sourceFile, '.algo.ts')}.awst.json`);
            break;
    }
    const content = buildArtifact(obj);
    logger.info(undefined, `Writing ${outFilePath}`);
    mkDirIfNotExists(upath.dirname(outFilePath));
    fs.writeFileSync(outFilePath, content, 'utf-8');
}

const accept = (visitor, node) => {
    const sourceLocation = visitor.context.getSourceLocation(node);
    if (node.kind in SyntaxKindName) {
        const nodeName = getNodeName(node);
        const visitFunction = `visit${nodeName}`;
        if (visitFunction in Object.getPrototypeOf(visitor)) {
            return patchErrorLocation(() => Object.getPrototypeOf(visitor)[visitFunction].call(visitor, node), sourceLocation)();
        }
        else {
            throw new CodeError(`Unsupported syntax visitor ${nodeName}`, { sourceLocation });
        }
    }
    else {
        throw new CodeError(`Unknown syntax kind ${node.kind}`, { sourceLocation });
    }
};

class ConditionalExpressionBuilder extends LiteralExpressionBuilder {
    _ptype;
    whenTrue;
    whenFalse;
    condition;
    get ptype() {
        return this._ptype;
    }
    boolEval(sourceLocation, negate = false) {
        return nodeFactory.conditionalExpression({
            sourceLocation: this.sourceLocation,
            falseExpr: this.whenFalse.boolEval(sourceLocation, negate),
            trueExpr: this.whenTrue.boolEval(sourceLocation, negate),
            condition: this.condition,
            wtype: wtypes.boolWType,
        });
    }
    constructor({ condition, ptype, whenFalse, whenTrue, sourceLocation, }) {
        super(sourceLocation);
        this._ptype = ptype;
        this.whenTrue = whenTrue;
        this.whenFalse = whenFalse;
        this.condition = condition;
    }
    resolvableToPType(ptype) {
        return resolvableToType(this.whenTrue, ptype) && resolvableToType(this.whenFalse, ptype);
    }
    resolveToPType(ptype) {
        const falseBuilder = requireBuilderOfType(this.whenFalse, ptype);
        const trueBuilder = requireBuilderOfType(this.whenTrue, ptype);
        return typeRegistry.getInstanceEb(nodeFactory.conditionalExpression({
            sourceLocation: this.sourceLocation,
            falseExpr: falseBuilder.resolve(),
            trueExpr: trueBuilder.resolve(),
            condition: this.condition,
            wtype: falseBuilder.ptype.wtypeOrThrow,
        }), falseBuilder.ptype);
    }
}

class OmittedExpressionBuilder extends InstanceBuilder {
    get ptype() {
        return anyPType;
    }
    resolve() {
        throw new CodeError('Omitted expression cannot be resolved', { sourceLocation: this.sourceLocation });
    }
    resolveLValue() {
        throw new InternalError('Omitted expression cannot be resolved to an lvalue', { sourceLocation: this.sourceLocation });
    }
    resolvableToPType(ptype) {
        throw new InternalError('Omitted expression cannot be resolved to any type', { sourceLocation: this.sourceLocation });
    }
}

class SpreadExpressionBuilder extends NodeBuilder {
    baseExpression;
    ptype = undefined;
    constructor(baseExpression, sourceLocation) {
        super(sourceLocation);
        this.baseExpression = baseExpression;
    }
    getSpreadItems() {
        if (isStaticallyIterable(this.baseExpression)) {
            return this.baseExpression[StaticIterator]();
        }
        throw new CodeError(`Spread operator is not supported on ${this.baseExpression.typeDescription}`, {
            sourceLocation: this.sourceLocation,
        });
    }
}

class TextVisitor {
    get context() {
        return AwstBuildContext.current;
    }
    visitBigIntLiteral(node) {
        return node.text;
    }
    visitTemplateHead(node) {
        return node.text;
    }
    visitTemplateMiddle(node) {
        return node.text;
    }
    visitTemplateTail(node) {
        return node.text;
    }
    accept = (node) => accept(this, node);
    visitIdentifier(node) {
        return node.text;
    }
    visitNoSubstitutionTemplateLiteral(node) {
        return node.text;
    }
    visitNumericLiteral(node) {
        return node.text;
    }
    visitComputedPropertyName(node) {
        throw new NotSupported('Computed property names', {
            sourceLocation: this.context.getSourceLocation(node),
        });
    }
    visitPrivateIdentifier(node) {
        return node.text;
    }
    visitStringLiteral(node) {
        return node.text;
    }
}

class BaseVisitor {
    baseAccept = (node) => accept(this, node);
    textVisitor;
    get context() {
        return AwstBuildContext.current;
    }
    constructor() {
        this.textVisitor = new TextVisitor();
    }
    logNotSupported(node, message) {
        if (!node)
            return;
        logger.error(new NotSupported(message, { sourceLocation: this.sourceLocation(node) }));
    }
    throwNotSupported(node, message) {
        throw new NotSupported(message, { sourceLocation: this.sourceLocation(node) });
    }
    visitBigIntLiteral(node) {
        const literalValue = BigInt(node.text.slice(0, -1));
        const ptype = this.context.getPTypeForNode(node);
        invariant(ptype instanceof TransientType, 'Literals should resolve to transient PTypes');
        return new BigIntLiteralExpressionBuilder(literalValue, ptype, this.sourceLocation(node));
    }
    visitRegularExpressionLiteral(node) {
        this.throwNotSupported(node, 'Regular expressions');
    }
    visitFalseKeyword(node) {
        return new BooleanExpressionBuilder(nodeFactory.boolConstant({ value: false, sourceLocation: this.sourceLocation(node) }));
    }
    visitTrueKeyword(node) {
        return new BooleanExpressionBuilder(nodeFactory.boolConstant({ value: true, sourceLocation: this.sourceLocation(node) }));
    }
    sourceLocation(node) {
        return this.context.getSourceLocation(node);
    }
    visitStringLiteral(node) {
        return new StringExpressionBuilder(nodeFactory.stringConstant({ value: node.text, sourceLocation: this.sourceLocation(node) }));
    }
    visitNoSubstitutionTemplateLiteral(node) {
        return new StringExpressionBuilder(nodeFactory.stringConstant({ value: node.text, sourceLocation: this.sourceLocation(node) }));
    }
    visitNumericLiteral(node) {
        const sourceLocation = this.sourceLocation(node);
        codeInvariant(!node.text.includes('.'), 'Literals with decimal points are not supported. Use a string literal to capture decimal values', sourceLocation);
        const literalValue = BigInt(node.text);
        if (literalValue > Number.MAX_SAFE_INTEGER || literalValue < Number.MIN_SAFE_INTEGER) {
            logger.error(sourceLocation, `This number will lose precision at runtime. Use the Uint64 constructor with a bigint or string literal for very large integers.`);
        }
        const ptype = this.context.getPTypeForNode(node);
        invariant(ptype instanceof TransientType, 'Literals should resolve to transient PTypes');
        return new BigIntLiteralExpressionBuilder(literalValue, ptype, this.sourceLocation(node));
    }
    visitIdentifier(node) {
        return this.context.getBuilderForNode(node);
    }
    visitImportKeyword(node) {
        this.throwNotSupported(node, 'Dynamic imports');
    }
    visitNullKeyword(node) {
        this.throwNotSupported(node, 'Null values');
    }
    visitPrivateIdentifier(node) {
        // Private identifiers will be wrapped in a property access expression which makes use of the TextVisitor
        throw InternalError.shouldBeUnreachable();
    }
    visitSuperKeyword(node) {
        this.throwNotSupported(node, `'super' keyword outside of a contract type`);
    }
    visitThisKeyword(node) {
        this.throwNotSupported(node, `'this' keyword outside of a contract type`);
    }
    visitFunctionExpression(node) {
        this.throwNotSupported(node, 'function expressions. Use a named function instead eg. `function myFunction(...) {...}`');
    }
    visitClassExpression(node) {
        this.throwNotSupported(node, 'class expressions');
    }
    visitObjectLiteralExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const parts = node.properties.flatMap((p) => {
            const propertySourceLocation = this.sourceLocation(p);
            switch (p.kind) {
                case ts.SyntaxKind.PropertyAssignment:
                    return [
                        {
                            type: 'properties',
                            properties: {
                                [this.textVisitor.accept(p.name)]: requireInstanceBuilder(this.baseAccept(p.initializer)),
                            },
                        },
                    ];
                case ts.SyntaxKind.ShorthandPropertyAssignment:
                    codeInvariant(!p.objectAssignmentInitializer, 'Object assignment initializer not supported', propertySourceLocation);
                    this.logNotSupported(p.equalsToken, 'The equals token is not valid here');
                    return [
                        {
                            type: 'properties',
                            properties: { [this.textVisitor.accept(p.name)]: requireInstanceBuilder(this.baseAccept(p.name)) },
                        },
                    ];
                case ts.SyntaxKind.SpreadAssignment:
                    return [
                        {
                            type: 'spread-object',
                            obj: requireInstanceBuilder(this.baseAccept(p.expression)),
                        },
                    ];
                default:
                    logger.error(propertySourceLocation, `Unsupported object literal property kind ${getNodeName(p)}`);
                    return [];
            }
        });
        const ptype = this.context.getPTypeForNode(node);
        invariant(ptype instanceof ObjectPType, 'Object literal ptype should resolve to ObjectPType');
        return new ObjectLiteralExpressionBuilder(sourceLocation, ptype, parts);
    }
    visitArrayLiteralExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        if (node.elements.length === 0) {
            return new ArrayLiteralExpressionBuilder(sourceLocation, []);
        }
        const toConcat = [];
        let itemBuffer = [];
        for (const element of node.elements) {
            if (ts.isSpreadElement(element)) {
                const spreadExpr = requireInstanceBuilder(this.baseAccept(element.expression));
                if (itemBuffer.length !== 0) {
                    toConcat.push(itemBuffer);
                    itemBuffer = [];
                }
                toConcat.push(spreadExpr);
            }
            else {
                itemBuffer.push(requireInstanceBuilder(this.baseAccept(element)));
            }
        }
        if (itemBuffer.length !== 0) {
            toConcat.push(itemBuffer);
        }
        return toConcat
            .map((i) => Array.isArray(i) ? new ArrayLiteralExpressionBuilder(SourceLocation.fromLocations(...i.map((li) => li.sourceLocation)), i) : i)
            .reduce((acc, cur) => concatArrays(acc, cur, sourceLocation));
    }
    visitSpreadElement(node) {
        const base = requireInstanceBuilder(this.baseAccept(node.expression));
        return new SpreadExpressionBuilder(base, this.sourceLocation(node));
    }
    visitPropertyAccessExpression(node) {
        this.logNotSupported(node.questionDotToken, 'The optional chaining (?.) operator is not supported');
        const target = this.baseAccept(node.expression);
        if (target instanceof NamespaceBuilder) {
            codeInvariant(!ts.isPrivateIdentifier(node.name), 'Private identifiers are not supported here', this.sourceLocation(node.name));
            return this.context.getBuilderForNode(node.name);
        }
        const property = this.textVisitor.accept(node.name);
        return target.memberAccess(property, this.sourceLocation(node.name));
    }
    visitElementAccessExpression(node) {
        this.logNotSupported(node.questionDotToken, 'The optional chaining (?.) operator is not supported');
        const sourceLocation = this.sourceLocation(node);
        const target = this.baseAccept(node.expression);
        const argument = this.baseAccept(node.argumentExpression);
        return target.indexAccess(requireInstanceBuilder(argument), sourceLocation);
    }
    visitCallExpression(node) {
        this.logNotSupported(node.questionDotToken, 'The optional chaining (?.) operator is not supported');
        const sourceLocation = this.sourceLocation(node);
        const eb = this.baseAccept(node.expression);
        const args = node.arguments
            .map((a) => this.baseAccept(a))
            .flatMap((a) => (a instanceof SpreadExpressionBuilder ? a.getSpreadItems() : a));
        const typeArgs = this.context.getTypeParameters(node);
        return eb.call(args, typeArgs, sourceLocation);
    }
    visitNewExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const eb = this.baseAccept(node.expression);
        const args = node.arguments?.map((a) => this.baseAccept(a)).flatMap((a) => (a instanceof SpreadExpressionBuilder ? a.getSpreadItems() : a)) ?? [];
        const typeArgs = this.context.getTypeParameters(node);
        return eb.newCall(args, typeArgs, sourceLocation);
    }
    visitTaggedTemplateExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const target = this.baseAccept(node.tag);
        if (ts.isNoSubstitutionTemplateLiteral(node.template)) {
            return target.taggedTemplate(this.textVisitor.accept(node.template), [], sourceLocation);
        }
        else {
            const head = this.textVisitor.accept(node.template.head);
            const spans = node.template.templateSpans.map((s) => [requireInstanceBuilder(this.baseAccept(s.expression)), this.textVisitor.accept(s.literal)]);
            return target.taggedTemplate(head, spans, sourceLocation);
        }
    }
    visitTypeAssertionExpression(node) {
        // Unsure what code this node represents - it may have been superseded by the AsExpression
        this.throwNotSupported(node, 'Type assertions');
    }
    visitParenthesizedExpression(node) {
        return this.baseAccept(node.expression);
    }
    /**
     * `delete obj.prop`
     *
     * Not supported currently as typescript requires 'prop' to be optional and we don't support optional values
     */
    visitDeleteExpression(node) {
        this.throwNotSupported(node, 'Delete expressions');
    }
    visitTypeOfExpression(node) {
        this.throwNotSupported(node, 'typeof expressions are only supported in type expressions');
    }
    visitVoidExpression(node) {
        this.throwNotSupported(node, 'void expression');
    }
    visitAwaitExpression(node) {
        this.throwNotSupported(node, 'await keyword');
    }
    visitPrefixUnaryExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const target = requireInstanceBuilder(this.baseAccept(node.operand));
        if (node.operator === ts.SyntaxKind.ExclamationToken) {
            return new BooleanExpressionBuilder(target.boolEval(sourceLocation, true));
        }
        const op = UnaryExpressionUnaryOps[node.operator];
        return target.prefixUnaryOp(op, sourceLocation);
    }
    visitPostfixUnaryExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const target = requireInstanceBuilder(this.baseAccept(node.operand));
        const op = UnaryExpressionUnaryOps[node.operator];
        return target.postfixUnaryOp(op, sourceLocation);
    }
    evaluateCondition(nodeOrBuilder, negate = false) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const _ = __addDisposableResource(env_1, this.context.evaluationCtx.enterBooleanContext(), false);
            if (nodeOrBuilder instanceof NodeBuilder) {
                return requireInstanceBuilder(nodeOrBuilder).boolEval(nodeOrBuilder.sourceLocation, negate);
            }
            else {
                const sourceLocation = this.sourceLocation(nodeOrBuilder);
                return requireInstanceBuilder(this.baseAccept(nodeOrBuilder)).boolEval(sourceLocation, negate);
            }
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    }
    getBinaryOpKind(token) {
        const sourceLocation = this.sourceLocation(token);
        switch (token.kind) {
            case ts.SyntaxKind.EqualsEqualsToken:
                logger.error(sourceLocation, `Loose equality operator '==' is not supported. Please use strict equality operator '==='`);
                return ts.SyntaxKind.EqualsEqualsEqualsToken;
            case ts.SyntaxKind.ExclamationEqualsToken:
                logger.error(sourceLocation, `Loose inequality operator '!=' is not supported. Please use strict inequality operator '!=='`);
                return ts.SyntaxKind.ExclamationEqualsEqualsToken;
            default:
                return token.kind;
        }
    }
    visitBinaryExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const binaryOpKind = this.getBinaryOpKind(node.operatorToken);
        if (isKeyOf(binaryOpKind, BinaryOpSyntaxes)) {
            const left = requireInstanceBuilder(this.baseAccept(node.left));
            const right = requireInstanceBuilder(this.baseAccept(node.right));
            return left.binaryOp(right, BinaryOpSyntaxes[binaryOpKind], sourceLocation);
        }
        else if (isKeyOf(binaryOpKind, AugmentedAssignmentBinaryOp)) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
                const _ = __addDisposableResource(env_2, this.context.evaluationCtx.leaveBooleanContext(), false);
                const left = requireInstanceBuilder(this.baseAccept(node.left));
                const right = requireInstanceBuilder(this.baseAccept(node.right));
                return left.augmentedAssignment(right, AugmentedAssignmentBinaryOp[binaryOpKind], sourceLocation);
            }
            catch (e_2) {
                env_2.error = e_2;
                env_2.hasError = true;
            }
            finally {
                __disposeResources(env_2);
            }
        }
        else if (binaryOpKind === ts.SyntaxKind.EqualsToken) {
            const env_3 = { stack: [], error: void 0, hasError: false };
            try {
                const _ = __addDisposableResource(env_3, this.context.evaluationCtx.leaveBooleanContext(), false);
                const left = requireInstanceBuilder(this.baseAccept(node.left));
                const right = requireInstanceBuilder(this.baseAccept(node.right));
                return this.handleAssignment(left, right, sourceLocation);
            }
            catch (e_3) {
                env_3.error = e_3;
                env_3.hasError = true;
            }
            finally {
                __disposeResources(env_3);
            }
        }
        else if (isKeyOf(binaryOpKind, ComparisonOpSyntaxes)) {
            const left = requireInstanceBuilder(this.baseAccept(node.left));
            const right = requireInstanceBuilder(this.baseAccept(node.right));
            return left.compare(right, ComparisonOpSyntaxes[binaryOpKind], sourceLocation);
        }
        else if (isKeyOf(binaryOpKind, LogicalOpSyntaxes)) {
            const ptype = this.context.getPTypeForNode(node);
            if (ptype.equals(boolPType)) {
                const left = requireInstanceBuilder(this.baseAccept(node.left));
                const right = requireInstanceBuilder(this.baseAccept(node.right));
                return new BooleanExpressionBuilder(nodeFactory.booleanBinaryOperation({
                    left: requireExpressionOfType(left, boolPType),
                    right: requireExpressionOfType(right, boolPType),
                    sourceLocation,
                    op: LogicalOpSyntaxes[binaryOpKind],
                }));
            }
            else if (this.context.evaluationCtx.isBoolean) {
                const left = requireInstanceBuilder(this.baseAccept(node.left));
                const right = requireInstanceBuilder(this.baseAccept(node.right));
                return new BooleanExpressionBuilder(nodeFactory.booleanBinaryOperation({
                    left: left.boolEval(sourceLocation),
                    right: right.boolEval(sourceLocation),
                    sourceLocation,
                    op: LogicalOpSyntaxes[binaryOpKind],
                }));
            }
            else {
                const left = requireInstanceBuilder(this.baseAccept(node.left));
                const right = requireInstanceBuilder(this.baseAccept(node.right));
                const leftSingle = left.singleEvaluation();
                const isOr = binaryOpKind === ts.SyntaxKind.BarBarToken;
                return this.createConditionalExpression({
                    sourceLocation,
                    condition: this.evaluateCondition(leftSingle),
                    whenTrue: isOr ? leftSingle : right,
                    whenFalse: isOr ? right : leftSingle,
                    ptype: ptype,
                });
            }
        }
        else if (isKeyOf(binaryOpKind, AugmentedAssignmentLogicalOpSyntaxes)) {
            const env_4 = { stack: [], error: void 0, hasError: false };
            try {
                const _ = __addDisposableResource(env_4, this.context.evaluationCtx.leaveBooleanContext(), false);
                const left = requireInstanceBuilder(this.baseAccept(node.left));
                const right = requireInstanceBuilder(this.baseAccept(node.right));
                const expr = new BooleanExpressionBuilder(nodeFactory.booleanBinaryOperation({
                    left: requireExpressionOfType(left, boolPType),
                    right: requireExpressionOfType(right, boolPType),
                    sourceLocation,
                    op: AugmentedAssignmentLogicalOpSyntaxes[binaryOpKind],
                }));
                return this.handleAssignment(left, expr, sourceLocation);
            }
            catch (e_4) {
                env_4.error = e_4;
                env_4.hasError = true;
            }
            finally {
                __disposeResources(env_4);
            }
        }
        throw new NotSupported(`Binary expression with op ${getSyntaxName(binaryOpKind)}`);
    }
    visitConditionalExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const condition = this.evaluateCondition(node.condition);
        const whenTrue = requireInstanceBuilder(this.baseAccept(node.whenTrue));
        const whenFalse = requireInstanceBuilder(this.baseAccept(node.whenFalse));
        const ptype = this.context.getPTypeForNode(node);
        return this.createConditionalExpression({
            condition,
            sourceLocation,
            whenFalse,
            whenTrue,
            ptype,
        });
    }
    createConditionalExpression({ condition, ptype, whenFalse, whenTrue, sourceLocation, }) {
        // If the expression has a wtype, we can resolve it immediately - if not, we defer the resolution until we have more context
        // (eg. the type of the assignment target)
        if (!(ptype instanceof TransientType) && ptype.wtype) {
            return typeRegistry.getInstanceEb(nodeFactory.conditionalExpression({
                sourceLocation: sourceLocation,
                falseExpr: requireExpressionOfType(whenFalse, ptype),
                trueExpr: requireExpressionOfType(whenTrue, ptype),
                condition: condition,
                wtype: ptype.wtypeOrThrow,
            }), ptype);
        }
        return new ConditionalExpressionBuilder({ sourceLocation, condition, whenTrue, whenFalse, ptype });
    }
    visitTemplateExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const target = new StringFunctionBuilder(sourceLocation);
        const head = this.textVisitor.accept(node.head);
        const spans = node.templateSpans.map((s) => [requireInstanceBuilder(this.baseAccept(s.expression)), this.textVisitor.accept(s.literal)]);
        return target.taggedTemplate(head, spans, sourceLocation);
    }
    visitYieldExpression(node) {
        this.throwNotSupported(node, 'yield expressions');
    }
    visitOmittedExpression(node) {
        return new OmittedExpressionBuilder(this.context.getSourceLocation(node));
    }
    visitExpressionWithTypeArguments(node) {
        // Should be fine to ignore the type parameters as these can be inferred by the type checker
        return this.baseAccept(node.expression);
    }
    visitAsExpression(node) {
        const sourceLocation = this.sourceLocation(node);
        const outerType = this.context.getPTypeForNode(node);
        if (outerType instanceof TransientType) {
            throw new CodeError(outerType.typeMessage, { sourceLocation });
        }
        const innerExpr = this.baseAccept(node.expression);
        codeInvariant(innerExpr instanceof InstanceBuilder, `${innerExpr.typeDescription} is not a valid target for an as expression'`, sourceLocation);
        codeInvariant(innerExpr.resolvableToPType(outerType), `${innerExpr.typeDescription} cannot be resolved to type ${outerType}`, sourceLocation);
        return innerExpr.resolveToPType(outerType);
    }
    visitNonNullExpression(node) {
        this.throwNotSupported(node, 'non null assertions');
    }
    visitSatisfiesExpression(node) {
        return this.baseAccept(node.expression);
    }
    handleAssignmentStatement(target, source, sourceLocation) {
        return nodeFactory.expressionStatement({ expr: this.handleAssignment(target, source, sourceLocation).resolve() });
    }
    handleAssignment(target, source, sourceLocation) {
        const assignmentType = this.buildAssignmentExpressionType(target.ptype, source.ptype, sourceLocation);
        return instanceEb(nodeFactory.assignmentExpression({
            target: this.buildLValue(target, assignmentType, sourceLocation),
            sourceLocation,
            value: source.resolveToPType(assignmentType).resolve(),
        }), assignmentType);
    }
    /**
     * Given a target and source type, produce a type that represents the result of an assignment expression.
     *
     * This will largely represent the sourceType verbatim with the exception of numeric literal types which need
     * to be narrowed using the targetType.
     *
     * Eg. a `number` on the rhs should be narrowed to whatever the lhs is for example uint64.
     * @param targetType The type of the assignment target
     * @param sourceType The type of the assignment source
     * @param sourceLocation
     * @private
     */
    buildAssignmentExpressionType(targetType, sourceType, sourceLocation) {
        if (targetType instanceof ArrayLiteralPType)
            // Puya does not support assigning to array targets, but we can treat array literals as tuples
            return this.buildAssignmentExpressionType(targetType.getTupleType(), sourceType, sourceLocation);
        const errorMessage = `Value of type ${sourceType.name} cannot be assigned to target of type ${targetType.name}`;
        if (sourceType.equals(targetType)) {
            return targetType;
        }
        if (sourceType instanceof NumericLiteralPType ||
            sourceType.equals(numberPType) ||
            (sourceType instanceof UnionPType &&
                sourceType.types.every((t) => t.equals(uint64PType) || t instanceof NumericLiteralPType || sourceType.equals(numberPType)))) {
            // Narrow `uint64 | number` or `number` to target type
            return targetType;
        }
        if (sourceType.equals(bigIntPType) ||
            sourceType instanceof BigIntLiteralPType ||
            (sourceType instanceof UnionPType &&
                sourceType.types.every((t) => t.equals(biguintPType) || t instanceof BigIntLiteralPType || t.equals(bigIntPType)))) {
            // Narrow `biguint | bigint` or `bigint` to target type
            return targetType;
        }
        if (sourceType instanceof ArrayLiteralPType) {
            if (targetType instanceof TuplePType) {
                // Narrow array literal types to tuple item types
                codeInvariant(targetType.items.length <= sourceType.items.length, errorMessage, sourceLocation);
                return new TuplePType({
                    items: sourceType.items.map((item, index) => index < targetType.items.length ? this.buildAssignmentExpressionType(targetType.items[index], item, sourceLocation) : item),
                });
            }
            else if (targetType instanceof ArrayPType) {
                // Narrow array literal types to array type
                codeInvariant(sourceType.items.every((i) => this.buildAssignmentExpressionType(targetType.elementType, i, sourceLocation).equals(targetType.elementType)), errorMessage, sourceLocation);
                return targetType;
            }
        }
        if (sourceType instanceof ObjectPType) {
            // Recursively narrow object properties
            codeInvariant(targetType instanceof ObjectPType, errorMessage);
            const targetPropertyOrder = targetType
                .orderedProperties()
                .reduce((acc, [prop], index) => acc.set(prop, index), new Map());
            return new ObjectPType({
                alias: targetType.alias,
                description: targetType.description,
                properties: Object.fromEntries(sourceType
                    .orderedProperties()
                    .map(([prop, propType]) => [
                    prop,
                    prop in targetType.properties
                        ? this.buildAssignmentExpressionType(targetType.getPropertyType(prop), propType, sourceLocation)
                        : propType,
                ])
                    .toSorted(sortBy(([prop]) => targetPropertyOrder.get(prop) ?? Number.MAX_SAFE_INTEGER))),
            });
        }
        // Array<never> can be assigned to any target array type
        if (sourceType instanceof ArrayPType && sourceType.elementType.equals(neverPType)) {
            codeInvariant(targetType instanceof ArrayPType, errorMessage);
            return targetType;
        }
        return sourceType;
    }
    buildLValue(target, assignmentType, sourceLocation) {
        if (target instanceof ArrayLiteralExpressionBuilder) {
            if (assignmentType instanceof TuplePType) {
                const targetItems = target[StaticIterator]();
                const targets = [];
                for (const [index, sourceItemType] of enumerate(assignmentType.items)) {
                    const targetItem = targetItems[index];
                    if (targetItem && !(targetItem instanceof OmittedExpressionBuilder)) {
                        targets.push(this.buildLValue(targetItem, sourceItemType, sourceLocation));
                    }
                    else {
                        targets.push(nodeFactory.varExpression({
                            name: this.context.generateDiscardedVarName(),
                            sourceLocation,
                            wtype: sourceItemType.wtypeOrThrow,
                        }));
                    }
                }
                return nodeFactory.tupleExpression({ items: targets, sourceLocation });
            }
        }
        if (target instanceof ObjectLiteralExpressionBuilder) {
            if (assignmentType instanceof ObjectPType) {
                const targets = [];
                for (const [propName, propType] of assignmentType.orderedProperties()) {
                    if (target.hasProperty(propName)) {
                        targets.push(this.buildLValue(requireInstanceBuilder(target.memberAccess(propName, sourceLocation)), propType, sourceLocation));
                    }
                    else {
                        targets.push(nodeFactory.varExpression({
                            name: this.context.generateDiscardedVarName(),
                            sourceLocation,
                            wtype: propType.wtypeOrThrow,
                        }));
                    }
                }
                return nodeFactory.tupleExpression({ items: targets, sourceLocation, wtype: assignmentType.wtype });
            }
        }
        if (target.ptype.equals(assignmentType)) {
            return target.resolveLValue();
        }
        throw new CodeError(`The target of an assignment must have the same type as the source. Target: ${target.ptype}, Source: ${assignmentType}`, {
            sourceLocation,
        });
    }
    parseMemberModifiers(node) {
        let isPublic = true;
        let isStatic = false;
        if (node.modifiers)
            for (const m of node.modifiers) {
                switch (m.kind) {
                    case ts.SyntaxKind.StaticKeyword:
                        isStatic = true;
                        continue;
                    case ts.SyntaxKind.PublicKeyword:
                        isPublic = true;
                        continue;
                    case ts.SyntaxKind.ProtectedKeyword:
                        isPublic = false;
                        continue;
                    case ts.SyntaxKind.PrivateKeyword:
                        isPublic = false;
                        continue;
                    case ts.SyntaxKind.AbstractKeyword:
                        continue;
                    case ts.SyntaxKind.AccessorKeyword:
                        logger.error(this.sourceLocation(m), 'properties are not supported');
                        continue;
                    case ts.SyntaxKind.AsyncKeyword:
                        logger.error(this.sourceLocation(m), 'async keyword is not supported');
                        continue;
                    case ts.SyntaxKind.DeclareKeyword:
                        logger.error(this.sourceLocation(m), 'declare keyword is not supported');
                        continue;
                    case ts.SyntaxKind.ExportKeyword:
                    case ts.SyntaxKind.ConstKeyword:
                    case ts.SyntaxKind.DefaultKeyword:
                    case ts.SyntaxKind.ReadonlyKeyword:
                    case ts.SyntaxKind.OverrideKeyword:
                    case ts.SyntaxKind.InKeyword:
                    case ts.SyntaxKind.OutKeyword:
                    case ts.SyntaxKind.Decorator:
                        // Ignore for now
                        continue;
                }
            }
        return {
            isStatic,
            isPublic,
        };
    }
    getNodeDescription(node) {
        const docs = ts.getJSDocCommentsAndTags(node);
        for (const doc of docs) {
            if (ts.isJSDoc(doc)) {
                return ts.getTextOfJSDocComment(doc.comment) ?? null;
            }
        }
        return null;
    }
    getMethodDocumentation(node) {
        const docs = Array.from(ts.getJSDocCommentsAndTags(node));
        let description = null;
        const args = new Map();
        let returns = null;
        for (const doc of docs) {
            if (ts.isJSDoc(doc)) {
                description = ts.getTextOfJSDocComment(doc.comment) ?? null;
                if (doc.tags)
                    docs.push(...doc.tags);
            }
            else if (ts.isJSDocParameterTag(doc)) {
                const paramName = this.textVisitor.accept(doc.name);
                const paramComment = ts.getTextOfJSDocComment(doc.comment);
                args.set(paramName, paramComment ?? '');
            }
            else if (ts.isJSDocReturnTag(doc)) {
                returns = ts.getTextOfJSDocComment(doc.comment) ?? null;
            }
        }
        return nodeFactory.methodDocumentation({
            description,
            args,
            returns,
        });
    }
}

class DecoratorVisitor extends BaseVisitor {
    accept = (node) => accept(this, node);
    result;
    constructor(node) {
        super();
        const expr = this.accept(node.expression);
        invariant(expr instanceof DecoratorDataBuilder, 'expr must be DecoratorDataBuilder');
        this.result = expr.resolveDecoratorData();
    }
    static buildDecoratorData(node) {
        return (node.modifiers?.flatMap((modifier) => {
            if (!ts.isDecorator(modifier))
                return [];
            try {
                return AwstBuildContext.current.runInChildContext(() => new DecoratorVisitor(modifier).result);
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
                return [];
            }
        }) ?? []);
    }
    static buildContractData(target) {
        const data = DecoratorVisitor.buildDecoratorData(target);
        return DecoratorVisitor.filterDecoratorData(data, ['contract'], (t) => `${t} is not supported on contracts`, 'Only one decorator is allowed per contract.');
    }
    static buildLogicSigData(target) {
        const data = DecoratorVisitor.buildDecoratorData(target);
        return DecoratorVisitor.filterDecoratorData(data, ['logicsig'], (t) => `${t} is not supported on logic signatures`, 'Only one decorator is allowed per logic signature.');
    }
    static buildContractMethodData(target) {
        const data = DecoratorVisitor.buildDecoratorData(target);
        return DecoratorVisitor.filterDecoratorData(data, ['arc4.abimethod', 'arc4.baremethod'], (t) => `${t} is not supported on contract methods`, 'Only one decorator is allowed per method. Multiple on complete actions can be provided in a single decorator');
    }
    static filterDecoratorData(decoratorData, types, notSupportedMessage, duplicateMessage) {
        let data;
        for (const d of decoratorData) {
            if (isIn(d.type, types)) {
                if (data === undefined) {
                    data = d;
                }
                else {
                    logger.error(d.sourceLocation, duplicateMessage);
                }
            }
            else {
                logger.error(d.sourceLocation, notSupportedMessage(d.type));
            }
        }
        return data;
    }
}

const getSequenceItemType = (sequence, sequenceLocation) => {
    if (sequence instanceof IterableIteratorType)
        return sequence.itemType;
    if (sequence instanceof ArrayPType)
        return sequence.elementType;
    if (sequence instanceof MutableArrayType)
        return sequence.elementType;
    if (sequence instanceof TuplePType) {
        codeInvariant(sequence.items.every((i) => i.equals(sequence.items[0])), `Tuples are only iterable if all item types are the same type. Item type is ${UnionPType.fromTypes(sequence.items)}`, sequenceLocation);
        return sequence.items[0];
    }
    if (sequence instanceof DynamicArrayType || sequence instanceof StaticArrayType) {
        return sequence.elementType;
    }
    throw new CodeError(`Target is not iterable: ${sequence}`, { sourceLocation: sequenceLocation });
};
const ptypeIn = (target, ...ptypes) => {
    return ptypes.some((t) => t.equals(target));
};

function maybeNodes(condition, ...nodes) {
    return condition ? nodes : [];
}
function visitInChildContext(Visitor, ...args) {
    return AwstBuildContext.current.runInChildContext((deferred) => {
        const visitor = new Visitor(...args);
        return deferred(() => visitor.result);
    });
}

// noinspection JSUnusedGlobalSymbols
class FunctionVisitor extends BaseVisitor {
    node;
    accept = (node) => accept(this, node);
    _functionType;
    constructor(node) {
        super();
        this.node = node;
        const type = this.context.getPTypeForNode(node);
        invariant(type instanceof FunctionPType, 'type of function must be FunctionPType');
        this._functionType = type;
    }
    buildFunctionAwst() {
        const node = this.node;
        const sourceLocation = this.sourceLocation(node);
        const args = node.parameters.map((p) => this.accept(p));
        const assignDestructuredParams = this.evaluateParameterBindingExpressions(node.parameters, sourceLocation);
        codeInvariant(node.body, 'Functions must have a body');
        const body = assignDestructuredParams.length
            ? nodeFactory.block({ sourceLocation }, assignDestructuredParams, this.accept(node.body))
            : this.accept(node.body);
        return {
            args,
            body,
            documentation: this.getMethodDocumentation(node),
        };
    }
    visitBindingName(bindingName, sourceLocation) {
        switch (bindingName.kind) {
            case ts.SyntaxKind.ObjectBindingPattern: {
                const props = Array();
                for (const element of bindingName.elements) {
                    const sourceLocation = this.sourceLocation(element);
                    const propertyNameIdentifier = element.propertyName ?? element.name;
                    invariant(ts.isIdentifier(propertyNameIdentifier), 'propertyName must be an identifier');
                    const propertyName = this.textVisitor.accept(propertyNameIdentifier);
                    codeInvariant(!element.dotDotDotToken, 'Spread operator is not supported', sourceLocation);
                    codeInvariant(!element.initializer, 'Initializer on object binding pattern is not supported', sourceLocation);
                    props.push([propertyName, this.visitBindingName(element.name, sourceLocation)]);
                }
                const ptype = ObjectPType.anonymous(props.map(([name, builder]) => [name, builder.ptype]));
                return new ObjectLiteralExpressionBuilder(sourceLocation, ptype, [{ type: 'properties', properties: Object.fromEntries(props) }]);
            }
            case ts.SyntaxKind.ArrayBindingPattern: {
                const items = [];
                for (const element of bindingName.elements) {
                    const sourceLocation = this.context.getSourceLocation(element);
                    if (ts.isOmittedExpression(element)) {
                        items.push(new OmittedExpressionBuilder(sourceLocation));
                    }
                    else {
                        codeInvariant(!element.initializer, 'Initializer on array binding expression is not supported', sourceLocation);
                        codeInvariant(!element.propertyName, 'Property name on array binding expression is not supported', sourceLocation);
                        if (element.dotDotDotToken) {
                            const spreadResult = this.visitBindingName(element.name, sourceLocation);
                            if (spreadResult instanceof NativeArrayExpressionBuilder) {
                                throw new CodeError('Spread operator is not supported in assignment expressions where the resulting type is a variadic array', { sourceLocation });
                            }
                            else if (spreadResult instanceof TupleExpressionBuilder) {
                                throw new CodeError('Spread operator is not currently supported with tuple expressions', { sourceLocation });
                            }
                            else {
                                throw InternalError.shouldBeUnreachable();
                            }
                        }
                        else {
                            items.push(this.visitBindingName(element.name, sourceLocation));
                        }
                    }
                }
                return new ArrayLiteralExpressionBuilder(sourceLocation, items);
            }
            case ts.SyntaxKind.Identifier: {
                return requireInstanceBuilder(this.accept(bindingName));
            }
            default:
                throw new InternalError('Unhandled binding name', { sourceLocation });
        }
    }
    evaluateParameterBindingExpressions(parameters, sourceLocation) {
        const assignments = [];
        for (const p of parameters) {
            const sourceLocation = this.sourceLocation(p);
            if (!ts.isIdentifier(p.name)) {
                const paramPType = this.context.getPTypeForNode(p);
                const paramName = this.context.resolveDestructuredParamName(p);
                const paramBuilder = typeRegistry.getInstanceEb(nodeFactory.varExpression({
                    name: paramName,
                    sourceLocation,
                    wtype: paramPType.wtypeOrThrow,
                }), paramPType);
                assignments.push(this.handleAssignmentStatement(this.visitBindingName(p.name, sourceLocation), paramBuilder, sourceLocation));
            }
        }
        if (assignments.length === 0)
            return [];
        return [
            nodeFactory.block({
                sourceLocation,
                comment: 'Destructured params',
            }, ...assignments),
        ];
    }
    visitTypeAliasDeclaration(node) {
        return [];
    }
    visitClassDeclaration(node) {
        throw new NotSupported('Nested classes', {
            sourceLocation: this.sourceLocation(node),
        });
    }
    visitVariableDeclarationList(node) {
        const isConstDeclaration = hasFlags(node.flags, ts.NodeFlags.Const);
        return node.declarations.flatMap((d) => {
            const sourceLocation = this.sourceLocation(d);
            if (!d.initializer) {
                // Typescript will already error if a destructuring expression is used without an initializer
                if (ts.isIdentifier(d.name)) {
                    const ptype = this.context.getPTypeForNode(d.name);
                    codeInvariant(ptype.wtype, `${ptype.fullName} is not a valid variable type`);
                }
                return [];
            }
            const source = requireInstanceBuilder(this.accept(d.initializer));
            /*
             If we encounter a simple const VAR = %VALUE% declaration, and the value is a compile time constant
             store this value as a constant in the context instead of processing the assignment.
      
             visitIdentifier will then resolve this constant instead of a VarExpression then the constant is referenced.
      
             NOTE: This only handles basic expressions for now. Constant values which are destructured from more complex expressions
             are not currently handled. eg. const [myConst] = ["constant value"]
             */
            storeConst: if (isConstDeclaration && ts.isIdentifier(d.name)) {
                const targetType = this.context.getPTypeForNode(d.name);
                if (!targetType.wtype)
                    break storeConst;
                const expr = source.resolveToPType(targetType).resolve();
                if (!isConstant(expr))
                    break storeConst;
                this.context.addConstant(d.name, expr);
                return [];
            }
            return this.handleAssignmentStatement(this.visitBindingName(d.name, sourceLocation), source, sourceLocation);
        });
    }
    visitVariableStatement(node) {
        return this.accept(node.declarationList);
    }
    visitForStatement(node) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const sourceLocation = this.sourceLocation(node);
            let init = [];
            if (node.initializer) {
                if (ts.isExpression(node.initializer)) {
                    init = [
                        nodeFactory.expressionStatement({
                            expr: requireInstanceBuilder(this.accept(node.initializer)).resolve(),
                        }),
                    ];
                }
                else {
                    init = this.accept(node.initializer);
                }
            }
            let incrementor = [];
            if (node.incrementor) {
                incrementor = [
                    nodeFactory.expressionStatement({
                        expr: requireInstanceBuilder(this.accept(node.incrementor)).resolve(),
                    }),
                ];
            }
            const ctx = __addDisposableResource(env_1, this.context.switchLoopCtx.enterLoop(node, sourceLocation), false);
            return [
                ...init,
                nodeFactory.whileLoop({
                    sourceLocation,
                    condition: node.condition ? this.evaluateCondition(node.condition) : nodeFactory.boolConstant({ value: true, sourceLocation }),
                    loopBody: nodeFactory.block({
                        sourceLocation,
                    }, this.accept(node.statement), ...maybeNodes(ctx.hasContinues, ctx.continueTarget), incrementor),
                }),
                ...maybeNodes(ctx.hasBreaks, ctx.breakTarget),
            ];
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    }
    visitForOfStatement(node) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const sourceLocation = this.sourceLocation(node);
            const sequenceLocation = this.sourceLocation(node.expression);
            const initializerLocation = this.sourceLocation(node.initializer);
            const sequenceType = this.context.getPTypeForNode(node.expression);
            const itemType = getSequenceItemType(sequenceType, sequenceLocation);
            let items;
            if (ts.isExpression(node.initializer)) {
                items = requireInstanceBuilder(this.accept(node.initializer)).resolveLValue();
            }
            else {
                codeInvariant(node.initializer.declarations.length === 1, 'For of loops can only declare a single loop variable', initializerLocation);
                const [declaration] = node.initializer.declarations;
                items = this.buildLValue(this.visitBindingName(declaration.name, initializerLocation), itemType, initializerLocation);
            }
            const ctx = __addDisposableResource(env_2, this.context.switchLoopCtx.enterLoop(node, sourceLocation), false);
            return nodeFactory.block({ sourceLocation }, nodeFactory.forInLoop({
                sourceLocation,
                sequence: requireInstanceBuilder(this.accept(node.expression)).iterate(sourceLocation),
                items,
                loopBody: nodeFactory.block({ sourceLocation }, this.accept(node.statement), ...maybeNodes(ctx.hasContinues, ctx.continueTarget)),
            }), ...maybeNodes(ctx.hasBreaks, ctx.breakTarget));
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            __disposeResources(env_2);
        }
    }
    visitForInStatement(node) {
        throw new NotSupported('For in statements', {
            sourceLocation: this.sourceLocation(node),
        });
    }
    visitTryStatement(node) {
        throw new NotSupported('Try statements', {
            sourceLocation: this.sourceLocation(node),
        });
    }
    visitEmptyStatement(node) {
        return nodeFactory.block({ sourceLocation: this.sourceLocation(node), comment: 'Empty statement' });
    }
    visitExpressionStatement(node) {
        const expr = requireInstanceBuilder(this.accept(node.expression)).resolve();
        if (expr instanceof AssignmentExpression) {
            return nodeFactory.assignmentStatement({
                ...expr,
            });
        }
        return nodeFactory.expressionStatement({
            expr,
        });
    }
    visitIfStatement(node) {
        const sourceLocation = this.sourceLocation(node);
        const condition = this.evaluateCondition(node.expression);
        const ifBranch = nodeFactory.block({ sourceLocation: this.sourceLocation(node.thenStatement) }, this.accept(node.thenStatement));
        const elseBranch = node.elseStatement && nodeFactory.block({ sourceLocation: this.sourceLocation(node.elseStatement) }, this.accept(node.elseStatement));
        return nodeFactory.ifElse({
            condition,
            ifBranch,
            elseBranch: elseBranch ?? null,
            sourceLocation,
        });
    }
    visitDoStatement(node) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
            const sourceLocation = this.sourceLocation(node);
            const ctx = __addDisposableResource(env_3, this.context.switchLoopCtx.enterLoop(node, sourceLocation), false);
            invariant(ctx.breakTarget.label, 'Break target must have a label');
            return nodeFactory.block({ sourceLocation }, nodeFactory.whileLoop({
                sourceLocation,
                condition: nodeFactory.boolConstant({ value: true, sourceLocation }),
                loopBody: nodeFactory.block({ sourceLocation }, this.accept(node.statement), ...maybeNodes(ctx.hasContinues, ctx.continueTarget), nodeFactory.ifElse({
                    condition: this.evaluateCondition(node.expression, true),
                    sourceLocation,
                    ifBranch: nodeFactory.block({ sourceLocation }, nodeFactory.goto({ sourceLocation, target: this.context.switchLoopCtx.getBreakTarget(undefined, sourceLocation) })),
                    elseBranch: null,
                })),
            }), ...maybeNodes(ctx.hasBreaks, ctx.breakTarget));
        }
        catch (e_3) {
            env_3.error = e_3;
            env_3.hasError = true;
        }
        finally {
            __disposeResources(env_3);
        }
    }
    visitWhileStatement(node) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
            const sourceLocation = this.sourceLocation(node);
            const ctx = __addDisposableResource(env_4, this.context.switchLoopCtx.enterLoop(node, sourceLocation), false);
            return nodeFactory.block({ sourceLocation }, nodeFactory.whileLoop({
                sourceLocation,
                condition: this.evaluateCondition(node.expression),
                loopBody: nodeFactory.block({ sourceLocation }, this.accept(node.statement), ...maybeNodes(ctx.hasContinues, ctx.continueTarget)),
            }), ...maybeNodes(ctx.hasBreaks, ctx.breakTarget));
        }
        catch (e_4) {
            env_4.error = e_4;
            env_4.hasError = true;
        }
        finally {
            __disposeResources(env_4);
        }
    }
    visitContinueStatement(node) {
        const sourceLocation = this.sourceLocation(node);
        return nodeFactory.goto({
            sourceLocation,
            target: this.context.switchLoopCtx.getContinueTarget(node.label, sourceLocation),
        });
    }
    visitBreakStatement(node) {
        const sourceLocation = this.sourceLocation(node);
        return nodeFactory.goto({
            sourceLocation,
            target: this.context.switchLoopCtx.getBreakTarget(node.label, sourceLocation),
        });
    }
    visitReturnStatement(node) {
        const sourceLocation = this.sourceLocation(node);
        if (!node.expression) {
            return nodeFactory.returnStatement({
                sourceLocation: sourceLocation,
                value: null,
            });
        }
        const returnValue = this.accept(node.expression);
        return nodeFactory.returnStatement({
            sourceLocation: sourceLocation,
            value: requireExpressionOfType(returnValue, this._functionType.returnType),
        });
    }
    visitWithStatement(node) {
        throw new NotSupported('with statements', { sourceLocation: this.sourceLocation(node) });
    }
    visitSwitchStatement(node) {
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
            const sourceLocation = this.sourceLocation(node);
            const ctx = __addDisposableResource(env_5, this.context.switchLoopCtx.enterSwitch(node, sourceLocation), false);
            const subject = requireInstanceBuilder(this.accept(node.expression)).singleEvaluation();
            let defaultCase = null;
            const clauses = [];
            for (const [index, clause] of enumerate(node.caseBlock.clauses)) {
                const sourceLocation = this.sourceLocation(clause);
                const statements = clause.statements.flatMap((s) => this.accept(s));
                const isNotLastCase = index + 1 < node.caseBlock.clauses.length;
                const isObviouslyTerminated = instanceOfAny(statements.at(-1), Goto, ReturnStatement);
                const caseBlock = nodeFactory.block({
                    sourceLocation,
                }, ctx.caseTarget(index, sourceLocation), statements, ...(isNotLastCase && !isObviouslyTerminated ? [ctx.gotoCase(index + 1, sourceLocation)] : []));
                if (clause.kind === ts.SyntaxKind.DefaultClause) {
                    defaultCase = caseBlock;
                }
                else {
                    const clauseExpr = requireInstanceBuilder(this.accept(clause.expression));
                    clauses.push(nodeFactory.ifElse({
                        condition: subject.compare(clauseExpr, BuilderComparisonOp.eq, clauseExpr.sourceLocation).boolEval(clauseExpr.sourceLocation),
                        ifBranch: caseBlock,
                        elseBranch: null,
                        sourceLocation,
                    }));
                }
            }
            if (defaultCase !== null)
                clauses.push(defaultCase);
            return nodeFactory.block({
                sourceLocation,
            }, ...clauses, ...maybeNodes(ctx.hasBreaks, ctx.breakTarget));
        }
        catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
        }
        finally {
            __disposeResources(env_5);
        }
    }
    visitLabeledStatement(node) {
        return this.accept(node.statement);
    }
    visitThrowStatement(node) {
        throw new NotSupported('Throw statements', {
            sourceLocation: this.sourceLocation(node),
        });
    }
    visitDebuggerStatement(node) {
        logger.warn(this.sourceLocation(node), 'Ignoring debugger statement');
        return [];
    }
    visitImportDeclaration(node) {
        throw new NotSupported('Non-top-level import declarations');
    }
    visitBlock(node) {
        return nodeFactory.block({
            sourceLocation: this.sourceLocation(node),
        }, node.statements.flatMap((s) => {
            try {
                return this.accept(s);
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
                return [];
            }
        }));
    }
    visitParameter(node) {
        const sourceLocation = this.sourceLocation(node);
        codeInvariant(node.type, 'Parameters must have type annotation', sourceLocation);
        codeInvariant(!node.dotDotDotToken, 'Rest parameters are not supported', sourceLocation);
        codeInvariant(!node.questionToken, 'Optional parameters are not supported', sourceLocation);
        if (node.initializer) {
            logger.warn(sourceLocation, 'TODO: Default parameter values');
        }
        const paramPType = this.context.getPTypeForNode(node.type);
        if (ts.isIdentifier(node.name)) {
            return nodeFactory.subroutineArgument({
                sourceLocation: sourceLocation,
                name: this.context.resolveVariableName(node.name),
                wtype: paramPType.wtypeOrThrow,
            });
        }
        else if (ts.isObjectBindingPattern(node.name)) {
            codeInvariant(paramPType instanceof ObjectPType, 'Param type must be object if it is being destructured', sourceLocation);
            return nodeFactory.subroutineArgument({
                sourceLocation,
                name: this.context.resolveDestructuredParamName(node),
                wtype: paramPType.wtype,
            });
        }
        else {
            throw new CodeError(`Unsupported parameter declaration type ${getNodeName(node)}`, { sourceLocation });
        }
    }
}

class ContractMethodBaseVisitor extends FunctionVisitor {
    _contractType;
    constructor(node, contractType) {
        super(node);
        this._contractType = contractType;
    }
    visitSuperKeyword(node) {
        const sourceLocation = this.sourceLocation(node);
        // Only the polytype clustered class should have more than one base type, and it shouldn't have
        // any user code with super calls
        invariant(this._contractType.baseTypes.length === 1, 'Super keyword only valid if contract has a single base type');
        return new ContractSuperBuilder(this._contractType.baseTypes[0], sourceLocation);
    }
    visitThisKeyword(node) {
        const sourceLocation = this.sourceLocation(node);
        return new ContractThisBuilder(this._contractType, sourceLocation);
    }
}
class ContractMethodVisitor extends ContractMethodBaseVisitor {
    metaData;
    constructor(node, contractType) {
        super(node, contractType);
        const sourceLocation = this.sourceLocation(node);
        const decorator = DecoratorVisitor.buildContractMethodData(node);
        const cref = ContractReference.fromPType(this._contractType);
        const modifiers = this.parseMemberModifiers(node);
        const arc4MethodConfig = this.buildArc4Config({
            functionType: this._functionType,
            decorator,
            modifiers,
            methodLocation: sourceLocation,
        });
        if (arc4MethodConfig)
            this.context.addArc4Config({
                contractReference: cref,
                sourceLocation,
                arc4MethodConfig,
                memberName: this._functionType.name,
            });
        this.metaData = {
            arc4MethodConfig,
            cref,
            sourceLocation,
        };
    }
    get result() {
        const { args, body, documentation } = this.buildFunctionAwst();
        return new ContractMethod({
            arc4MethodConfig: this.metaData.arc4MethodConfig,
            memberName: this._functionType.name,
            sourceLocation: this.metaData.sourceLocation,
            args,
            returnType: this._functionType.returnType.wtypeOrThrow,
            body,
            cref: this.metaData.cref,
            documentation,
            inline: null,
        });
    }
    static buildContractMethod(node, contractType) {
        return visitInChildContext(this, node, contractType);
    }
    buildArc4Config({ functionType, decorator, modifiers: { isPublic, isStatic }, methodLocation, }) {
        const isProgramMethod = isIn(functionType.name, [
            Constants.symbolNames.approvalProgramMethodName,
            Constants.symbolNames.clearStateProgramMethodName,
        ]);
        if (decorator && isIn(decorator.type, [Constants.symbolNames.arc4BareDecoratorName, Constants.symbolNames.arc4AbiDecoratorName])) {
            if (!isPublic) {
                logger.error(methodLocation, 'Private or protected methods cannot be exposed as an abi method');
                return null;
            }
            if (isStatic) {
                logger.error(methodLocation, 'Static methods cannot be exposed as an abi method');
                return null;
            }
            if (isProgramMethod) {
                logger.error(methodLocation, `${functionType.name} is reserved for program implementations and cannot be used as an abi method`);
                return null;
            }
        }
        if (isProgramMethod || !isPublic || isStatic)
            return null;
        const conventionalDefaults = this.getConventionalRoutingConfig(functionType.name);
        this.validateDecoratorRoutingData(functionType, decorator, conventionalDefaults);
        // Default routing properties used when these values aren't specified explicitly.
        const unspecifiedDefaults = {
            allowedCompletionTypes: [OnCompletionAction.NoOp],
            create: ARC4CreateOption.disallow,
        };
        if (decorator?.type === 'arc4.baremethod') {
            this.checkBareMethodTypes(functionType, methodLocation);
            return new ARC4BareMethodConfig({
                sourceLocation: decorator.sourceLocation,
                allowedCompletionTypes: decorator.allowedCompletionTypes ?? conventionalDefaults?.allowedCompletionTypes ?? unspecifiedDefaults.allowedCompletionTypes,
                create: decorator.create ?? conventionalDefaults?.create ?? unspecifiedDefaults.create,
            });
        }
        if (decorator?.type === 'arc4.abimethod') {
            this.checkABIMethodTypes(functionType, methodLocation);
            return new ARC4ABIMethodConfig({
                readonly: decorator.readonly,
                sourceLocation: decorator.sourceLocation,
                allowedCompletionTypes: decorator.allowedCompletionTypes ?? conventionalDefaults?.allowedCompletionTypes ?? unspecifiedDefaults.allowedCompletionTypes,
                create: decorator.create ?? conventionalDefaults?.create ?? unspecifiedDefaults.create,
                name: decorator.nameOverride ?? functionType.name,
                defaultArgs: new Map(Object.entries(decorator.defaultArguments).map(([parameterName, argConfig]) => [
                    parameterName,
                    this.buildDefaultArgument({
                        methodName: functionType.name,
                        parameterName,
                        config: argConfig,
                        decoratorLocation: decorator.sourceLocation,
                    }),
                ])),
            });
        }
        else if (isPublic && this._contractType.isARC4) {
            this.checkABIMethodTypes(functionType, methodLocation);
            return new ARC4ABIMethodConfig({
                allowedCompletionTypes: conventionalDefaults?.allowedCompletionTypes ?? unspecifiedDefaults.allowedCompletionTypes,
                create: conventionalDefaults?.create ?? unspecifiedDefaults.create,
                sourceLocation: methodLocation,
                name: functionType.name,
                readonly: false,
                defaultArgs: new Map(),
            });
        }
        return null;
    }
    validateDecoratorRoutingData(functionType, decorator, impliedByConvention) {
        if (!decorator || !impliedByConvention)
            return;
        if (decorator.allowedCompletionTypes !== undefined &&
            impliedByConvention.allowedCompletionTypes !== undefined &&
            !sameSets(decorator.allowedCompletionTypes, impliedByConvention.allowedCompletionTypes)) {
            const impliedOcaNames = impliedByConvention.allowedCompletionTypes.map((oca) => OnCompletionAction[oca]).join(', ');
            logger.error(decorator.allowedCompletionTypesLocation ?? decorator.sourceLocation, `allowActions for conventional routing method '${functionType.name}' must be: ${impliedOcaNames}`);
        }
        if (decorator.create !== undefined && impliedByConvention.create !== undefined && decorator.create !== impliedByConvention.create) {
            const impliedCreateAction = ARC4CreateOption[impliedByConvention.create];
            logger.error(decorator.createLocation ?? decorator.sourceLocation, `onCreate for conventional routing method '${functionType.name}' must be: ${impliedCreateAction}`);
        }
    }
    /**
     * Get routing properties inferred by conventional naming
     * @param methodName The name of the method
     * @private
     */
    getConventionalRoutingConfig(methodName) {
        switch (methodName) {
            case Constants.symbolNames.conventionalRouting.closeOutOfApplicationMethodName:
                return {
                    allowedCompletionTypes: [OnCompletionAction.CloseOut],
                    create: ARC4CreateOption.disallow,
                };
            case Constants.symbolNames.conventionalRouting.createApplicationMethodName:
                return {
                    create: ARC4CreateOption.require,
                };
            case Constants.symbolNames.conventionalRouting.deleteApplicationMethodName:
                return {
                    allowedCompletionTypes: [OnCompletionAction.DeleteApplication],
                };
            case Constants.symbolNames.conventionalRouting.optInToApplicationMethodName:
                return {
                    allowedCompletionTypes: [OnCompletionAction.OptIn],
                };
            case Constants.symbolNames.conventionalRouting.updateApplicationMethodName:
                return {
                    allowedCompletionTypes: [OnCompletionAction.UpdateApplication],
                    create: ARC4CreateOption.disallow,
                };
            default:
                return undefined;
        }
    }
    checkABIMethodTypes(functionType, sourceLocation) {
        for (const [, paramType] of functionType.parameters) {
            codeInvariant(ptypeToAbiPType(paramType, 'in', sourceLocation), 'ABI method parameter types must have an ARC4 equivalent', sourceLocation);
        }
        codeInvariant(ptypeToAbiPType(functionType.returnType, 'out', sourceLocation), 'ABI method return type must have an ARC4 equivalent', sourceLocation);
    }
    checkBareMethodTypes(functionType, sourceLocation) {
        codeInvariant(functionType.parameters.length === 0, 'Bare methods cannot have any parameters', sourceLocation);
        codeInvariant(functionType.returnType.equals(voidPType), 'Bare method return type must be void', sourceLocation);
    }
    buildDefaultArgument({ methodName, parameterName, config, decoratorLocation, }) {
        const [, paramType] = this._contractType.methods[methodName].parameters.find(([p]) => p === parameterName) ?? [undefined, undefined];
        codeInvariant(paramType, `Default argument specification '${parameterName}' does not match any parameters on the target method`, decoratorLocation);
        if (config.type === 'constant') {
            return nodeFactory.aBIMethodArgConstantDefault({
                value: requireExpressionOfType(config.value, paramType),
            });
        }
        const methodType = this._contractType.methods[config.name];
        if (methodType) {
            codeInvariant(methodType.returnType.equals(paramType), `Default argument specification for '${parameterName}' does not match parameter type`, decoratorLocation);
            return nodeFactory.aBIMethodArgMemberDefault({
                name: config.name,
            });
        }
        const propertyType = this._contractType.properties[config.name];
        if (propertyType instanceof GlobalStateType || propertyType instanceof LocalStateType) {
            codeInvariant(propertyType.contentType.equals(paramType), `Default argument specification for '${parameterName}' does not match parameter type`, decoratorLocation);
            return nodeFactory.aBIMethodArgMemberDefault({
                name: config.name,
            });
        }
        throw new CodeError('Unsupported default argument config', { sourceLocation: decoratorLocation });
    }
}

class ConstructorVisitor extends ContractMethodBaseVisitor {
    contractInfo;
    _foundSuperCall = false;
    constructor(node, contractType, contractInfo) {
        super(node, contractType);
        this.contractInfo = contractInfo;
    }
    get result() {
        const sourceLocation = this.sourceLocation(this.node);
        const { args, body, documentation } = this.buildFunctionAwst();
        return new ContractMethod({
            arc4MethodConfig: null,
            memberName: this._functionType.name,
            sourceLocation,
            args,
            returnType: voidPType.wtype,
            body,
            cref: this.contractInfo.cref,
            documentation,
            inline: null,
        });
    }
    static buildConstructor(node, contractType, constructorMethodInfo) {
        return visitInChildContext(this, node, contractType, constructorMethodInfo);
    }
    visitBlock(node) {
        return nodeFactory.block({
            sourceLocation: this.sourceLocation(node),
        }, node.statements.flatMap((s) => {
            try {
                const statement = this.accept(s);
                if (isSuperCall(s)) {
                    // Property initializer statements should be injected immediately after the super() call
                    codeInvariant(!this._foundSuperCall, 'A constructor can only contain one call to super()');
                    this._foundSuperCall = true;
                    return nodeFactory.block({
                        sourceLocation: this.sourceLocation(s),
                    }, ...(Array.isArray(statement) ? statement : [statement]), ...this.contractInfo.propertyInitializerStatements);
                }
                return statement;
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
                return [];
            }
        }));
    }
}
function isSuperCall(node) {
    return (ts.isExpressionStatement(node) && ts.isCallExpression(node.expression) && node.expression.expression.kind === ts.SyntaxKind.SuperKeyword);
}

class ContractVisitor extends BaseVisitor {
    _ctor;
    _methods = [];
    _contractPType;
    _propertyInitialization = [];
    accept = (node) => accept(this, node);
    metaData;
    constructor(classDec, ptype) {
        super();
        const sourceLocation = this.context.getSourceLocation(classDec);
        codeInvariant(classDec.name, 'Anonymous classes are not supported for contracts', sourceLocation);
        this._contractPType = ptype;
        const contractOptions = DecoratorVisitor.buildContractData(classDec);
        const isAbstract = Boolean(classDec.modifiers?.some((m) => m.kind === ts.SyntaxKind.AbstractKeyword));
        for (const property of classDec.members.filter(ts.isPropertyDeclaration)) {
            this.acceptAndIgnoreBuildErrors(property);
        }
        const ctor = classDec.members.find(ts.isConstructorDeclaration);
        if (ctor)
            this.acceptAndIgnoreBuildErrors(ctor);
        for (const member of classDec.members) {
            if (!ts.isConstructorDeclaration(member) && !ts.isPropertyDeclaration(member)) {
                this.acceptAndIgnoreBuildErrors(member);
            }
        }
        this.metaData = {
            isAbstract,
            sourceLocation,
            contractOptions,
            description: this.getNodeDescription(classDec),
        };
    }
    get result() {
        const { isAbstract, sourceLocation, contractOptions, description } = this.metaData;
        let approvalProgram = null;
        let clearProgram = null;
        const methods = [];
        const ctor = this._ctor?.() ?? this.makeDefaultConstructor(sourceLocation);
        for (const deferredMethod of this._methods) {
            const contractMethod = deferredMethod();
            switch (contractMethod.memberName) {
                case Constants.symbolNames.approvalProgramMethodName:
                    approvalProgram = contractMethod;
                    break;
                case Constants.symbolNames.clearStateProgramMethodName:
                    clearProgram = contractMethod;
                    break;
                default:
                    methods.push(contractMethod);
            }
        }
        const contract = new ContractClassModel({
            type: this._contractPType,
            propertyInitialization: this._propertyInitialization,
            isAbstract: isAbstract,
            appState: this.context.getStorageDefinitionsForContract(this._contractPType),
            ctor,
            methods,
            description,
            approvalProgram,
            clearProgram,
            options: contractOptions,
            sourceLocation: sourceLocation,
        });
        this.context.addToCompilationSet(contract.id, contract);
        const contractClass = this.context.compilationSet.getContractClass(ContractReference.fromPType(this._contractPType));
        if (!contractClass.isAbstract) {
            return [contractClass.buildContract(this.context.compilationSet)];
        }
        return [];
    }
    acceptAndIgnoreBuildErrors(node) {
        try {
            this.accept(node);
        }
        catch (e) {
            invariant(e instanceof Error, 'Only errors should be thrown');
            logger.error(e);
        }
    }
    makeDefaultConstructor(sourceLocation) {
        // If there is no property initialization, we don't need an implicit constructor
        if (this._propertyInitialization.length === 0)
            return null;
        invariant(this._contractPType.baseTypes.length === 1, 'Only single base type supported for now');
        return nodeFactory.contractMethod({
            memberName: Constants.symbolNames.constructorMethodName,
            cref: ContractReference.fromPType(this._contractPType),
            args: [],
            arc4MethodConfig: null,
            sourceLocation,
            returnType: wtypes.voidWType,
            documentation: nodeFactory.methodDocumentation(),
            body: nodeFactory.block({ sourceLocation }, nodeFactory.expressionStatement({
                expr: requireInstanceBuilder(new ContractSuperBuilder(this._contractPType.baseTypes[0], sourceLocation).call([], [], sourceLocation)).resolve(),
            }), ...this._propertyInitialization),
            inline: null,
        });
    }
    visitClassStaticBlockDeclaration(node) {
        this.throwNotSupported(node, 'class static blocks');
    }
    visitConstructor(node) {
        this._ctor = ConstructorVisitor.buildConstructor(node, this._contractPType, {
            cref: ContractReference.fromPType(this._contractPType),
            propertyInitializerStatements: this._propertyInitialization,
        });
    }
    visitGetAccessor(node) {
        this.throwNotSupported(node, 'get accessors');
    }
    visitIndexSignature(node) {
        this.throwNotSupported(node, 'index signatures');
    }
    visitMethodDeclaration(node) {
        this._methods.push(ContractMethodVisitor.buildContractMethod(node, this._contractPType));
    }
    visitPropertyDeclaration(node) {
        const sourceLocation = this.sourceLocation(node);
        codeInvariant(!node.questionToken, 'Optional properties are not supported', sourceLocation);
        codeInvariant(!node.exclamationToken, 'Non-null assertion operators on properties are not supported', sourceLocation);
        codeInvariant(!node.modifiers?.some((m) => m.kind === ts.SyntaxKind.StaticKeyword), 'Static properties are not supported');
        const propertyName = this.textVisitor.accept(node.name);
        codeInvariant(node.initializer, 'Properties must have an initializer', sourceLocation);
        if (node.type) {
            logger.info(sourceLocation, 'Type annotations are not required on initialized properties');
        }
        const initializer = this.accept(node.initializer);
        if (initializer instanceof GlobalStateFunctionResultBuilder) {
            const storageDeclaration = initializer.buildStorageDeclaration(propertyName, this.sourceLocation(node.name), this.getNodeDescription(node), this._contractPType);
            this.context.addStorageDeclaration(storageDeclaration);
            if (initializer.initialValue) {
                this._propertyInitialization.push(nodeFactory.assignmentStatement({
                    target: nodeFactory.appStateExpression({
                        key: storageDeclaration.key,
                        wtype: storageDeclaration.ptype.contentType.wtypeOrThrow,
                        sourceLocation: storageDeclaration.sourceLocation,
                        existsAssertionMessage: null,
                    }),
                    value: initializer.initialValue,
                    sourceLocation,
                }));
            }
        }
        else if (initializer instanceof BoxProxyExpressionBuilder || initializer instanceof LocalStateFunctionResultBuilder) {
            this.context.addStorageDeclaration(initializer.buildStorageDeclaration(propertyName, this.sourceLocation(node.name), this.getNodeDescription(node), this._contractPType));
        }
        else {
            logger.error(initializer.sourceLocation, `Unsupported property type ${initializer.typeDescription}. Only GlobalState, LocalState, and Box proxies can be stored on a contract.`);
        }
    }
    visitSemicolonClassElement(node) {
        // Ignore
    }
    visitSetAccessor(node) {
        this.throwNotSupported(node, 'set accessors');
    }
    static buildContract(classDec, ptype) {
        return visitInChildContext(this, classDec, ptype);
    }
}

class LogicSigProgramVisitor extends FunctionVisitor {
    constructor(node) {
        super(node);
    }
    get result() {
        const sourceLocation = this.sourceLocation(this.node);
        const { args, body, documentation } = this.buildFunctionAwst();
        return new Subroutine({
            id: this._functionType.fullName,
            name: this._functionType.name,
            sourceLocation,
            args,
            returnType: this._functionType.returnType.wtypeOrThrow,
            body,
            documentation,
            inline: null,
        });
    }
    static buildLogicSigProgram(node) {
        return visitInChildContext(LogicSigProgramVisitor, node);
    }
}

class LogicSigVisitor extends BaseVisitor {
    _logicSigPType;
    accept = (node) => accept(this, node);
    static buildLogicSig(classDec, ptype) {
        return visitInChildContext(this, classDec, ptype);
    }
    program;
    metaData;
    constructor(classDec, _logicSigPType) {
        super();
        this._logicSigPType = _logicSigPType;
        const sourceLocation = this.sourceLocation(classDec);
        const options = DecoratorVisitor.buildLogicSigData(classDec);
        for (const member of classDec.members) {
            try {
                this.accept(member);
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
            }
        }
        this.metaData = {
            options,
            sourceLocation,
            description: this.getNodeDescription(classDec),
        };
    }
    get result() {
        const { sourceLocation, options, description } = this.metaData;
        codeInvariant(this.program, 'Logic signature class must implement a valid program method', sourceLocation);
        const logicSig = new LogicSigClassModel({
            bases: [],
            sourceLocation,
            program: this.program(),
            type: this._logicSigPType,
            description,
            options,
        });
        this.context.addToCompilationSet(logicSig.id, logicSig);
        return logicSig.buildLogicSignature();
    }
    throwLogicSigNotSupported(node, desc) {
        throw new CodeError(`${desc} are not supported in logic signature definitions`, {
            sourceLocation: this.sourceLocation(node),
        });
    }
    visitClassStaticBlockDeclaration(node) {
        this.throwLogicSigNotSupported(node, 'Class static block declarations');
    }
    visitConstructor(node) {
        this.throwLogicSigNotSupported(node, 'Constructor declarations');
    }
    visitGetAccessor(node) {
        this.throwLogicSigNotSupported(node, 'Property declarations');
    }
    visitIndexSignature(node) {
        this.throwLogicSigNotSupported(node, 'Index signature declarations');
    }
    visitMethodDeclaration(node) {
        const sourceLocation = this.sourceLocation(node);
        const methodType = this.context.getPTypeForNode(node);
        invariant(methodType instanceof FunctionPType, 'type of function must be FunctionPType');
        if (methodType.name !== Constants.symbolNames.logicSigProgramMethodName) {
            logger.error(sourceLocation, `LogicSig classes may only contain a program implementation method named '${Constants.symbolNames.logicSigProgramMethodName}'. Consider making '${methodType.name}' a free subroutine.`);
            return;
        }
        if (!ptypeIn(methodType.returnType, uint64PType, boolPType)) {
            logger.error(sourceLocation, `LogicSig program method must return \`uint64\` or \`boolean\`, found \`${methodType.returnType.name}\` `);
            return;
        }
        this.program = LogicSigProgramVisitor.buildLogicSigProgram(node);
    }
    visitPropertyDeclaration(node) {
        this.throwLogicSigNotSupported(node, 'Property declarations');
    }
    visitSemicolonClassElement(node) {
        // Ignore
    }
    visitSetAccessor(node) {
        this.throwLogicSigNotSupported(node, 'Property declarations');
    }
}

class StructVisitor extends BaseVisitor {
    accept = (node) => accept(this, node);
    static buildStructDef(classDec, ptype) {
        return AwstBuildContext.current.runInChildContext(() => {
            new StructVisitor(classDec, ptype);
            return [];
        });
    }
    constructor(classDec, ptype) {
        super();
        for (const member of classDec.members) {
            try {
                this.accept(member);
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
            }
        }
    }
    throwStructNotSupported(node, desc) {
        throw new CodeError(`${desc} are not supported in ARC4 struct definitions`, {
            sourceLocation: this.sourceLocation(node),
        });
    }
    visitClassStaticBlockDeclaration(node) {
        this.throwStructNotSupported(node, 'Class static block declarations');
    }
    visitConstructor(node) {
        this.throwStructNotSupported(node, 'Constructor declarations');
    }
    visitGetAccessor(node) {
        this.throwStructNotSupported(node, 'Property declarations');
    }
    visitIndexSignature(node) {
        this.throwStructNotSupported(node, 'Index signature declarations');
    }
    visitMethodDeclaration(node) {
        this.throwStructNotSupported(node, 'Method declarations');
    }
    visitPropertyDeclaration(node) {
        this.throwStructNotSupported(node, 'Property declarations');
    }
    visitSemicolonClassElement(node) {
        // Ignore
    }
    visitSetAccessor(node) {
        this.throwStructNotSupported(node, 'Property declarations');
    }
}

class SubroutineVisitor extends FunctionVisitor {
    constructor(node) {
        super(node);
    }
    get result() {
        const sourceLocation = this.sourceLocation(this.node);
        const { args, body, documentation } = this.buildFunctionAwst();
        return new Subroutine({
            id: this._functionType.fullName,
            name: this._functionType.name,
            sourceLocation,
            args,
            returnType: this._functionType.returnType.wtypeOrThrow,
            body,
            documentation,
            inline: null,
        });
    }
    static buildSubroutine(node) {
        return visitInChildContext(SubroutineVisitor, node);
    }
}

class SourceFileVisitor extends BaseVisitor {
    _moduleStatements = [];
    accept = (node) => accept(this, node);
    constructor(sourceFile) {
        super();
        for (const statement of sourceFile.statements) {
            try {
                this._moduleStatements.push(this.accept(statement));
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
            }
        }
    }
    visitInterfaceDeclaration(node) {
        // Ignore these for now
        return [];
    }
    visitTypeAliasDeclaration(_node) {
        // Ignore these for now - but maybe we need to do something with them when it comes to structs
        return [];
    }
    visitFunctionDeclaration(node) {
        const sourceLocation = this.sourceLocation(node);
        return this.context.runInChildContext(() => patchErrorLocation(SubroutineVisitor.buildSubroutine(node), sourceLocation));
    }
    buildModule() {
        return Array.from(this.gatherStatements());
    }
    *gatherStatements() {
        for (const statements of this._moduleStatements) {
            try {
                if (typeof statements === 'function') {
                    for (const s of expandMaybeArray(statements())) {
                        yield s;
                    }
                }
                else {
                    for (const s of expandMaybeArray(statements)) {
                        yield s;
                    }
                }
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
            }
        }
    }
    visitVariableStatement(node) {
        const sourceLocation = this.sourceLocation(node);
        if (!(node.declarationList.flags & ts.NodeFlags.Const)) {
            logger.error(new CodeError(`Module level variable declarations must use the 'const' keyword.`, { sourceLocation }));
        }
        return node.declarationList.declarations.flatMap((dec) => {
            if (!dec.initializer) {
                throw new CodeError(`Module level variable declarations must be initialized with a value.`, { sourceLocation });
            }
            if (!ts.isIdentifier(dec.name)) {
                throw new CodeError(`Module level variable declarations must use plain identifiers.`, { sourceLocation });
            }
            const ptype = this.context.getPTypeForNode(dec.name);
            const initializerBuilder = this.accept(dec.initializer);
            if (ptype instanceof LibClassType) {
                invariant(initializerBuilder.ptype?.equals(ptype), 'Initializer type must match target type');
                return [];
            }
            const value = requireExpressionOfType(initializerBuilder, ptype);
            codeInvariant(isConstant(value) || value instanceof TemplateVar, 'Module level assignments must be compile time constants');
            this.context.addConstant(dec.name, value);
            return [];
        });
    }
    visitImportDeclaration(_node) {
        return [];
    }
    visitClassDeclaration(node) {
        const sourceLocation = this.sourceLocation(node);
        const ptype = this.context.getPTypeForNode(node);
        if (ptype instanceof ContractClassPType) {
            return patchErrorLocation(ContractVisitor.buildContract(node, ptype), sourceLocation);
        }
        else if (ptype instanceof ARC4StructType) {
            return patchErrorLocation(() => StructVisitor.buildStructDef(node, ptype), sourceLocation)();
        }
        else if (ptype instanceof LogicSigPType) {
            return patchErrorLocation(LogicSigVisitor.buildLogicSig(node, ptype), sourceLocation);
        }
        else {
            logger.warn(sourceLocation, `Ignoring class declaration ${ptype.fullName}`);
            return [];
        }
    }
}

function buildLibAwst() {
    const contractCref = ContractReference.fromPType(arc4BaseContractType);
    const baseContractCref = ContractReference.fromPType(baseContractType);
    const baseContract = new ContractClassModel({
        type: baseContractType,
        isAbstract: true,
        propertyInitialization: [],
        ctor: nodeFactory.contractMethod({
            memberName: Constants.symbolNames.constructorMethodName,
            cref: baseContractCref,
            args: [],
            arc4MethodConfig: null,
            sourceLocation: SourceLocation.None,
            returnType: wtypes.voidWType,
            documentation: nodeFactory.methodDocumentation(),
            body: nodeFactory.block({ sourceLocation: SourceLocation.None }),
            inline: true,
        }),
        methods: [],
        appState: [],
        options: undefined,
        description: null,
        sourceLocation: SourceLocation.None,
        approvalProgram: null,
        clearProgram: nodeFactory.contractMethod({
            memberName: Constants.symbolNames.clearStateProgramMethodName,
            cref: baseContractCref,
            args: [],
            arc4MethodConfig: null,
            sourceLocation: SourceLocation.None,
            returnType: wtypes.boolWType,
            documentation: nodeFactory.methodDocumentation(),
            body: nodeFactory.block({
                sourceLocation: SourceLocation.None,
            }, nodeFactory.returnStatement({
                sourceLocation: SourceLocation.None,
                value: nodeFactory.boolConstant({ value: true, sourceLocation: SourceLocation.None }),
            })),
            inline: null,
        }),
    });
    AwstBuildContext.current.addToCompilationSet(baseContractCref, baseContract);
    const contract = new ContractClassModel({
        type: arc4BaseContractType,
        isAbstract: true,
        propertyInitialization: [],
        ctor: null,
        methods: [],
        appState: [],
        options: undefined,
        description: null,
        clearProgram: null,
        sourceLocation: SourceLocation.None,
        approvalProgram: nodeFactory.contractMethod({
            memberName: Constants.symbolNames.approvalProgramMethodName,
            cref: contractCref,
            args: [],
            arc4MethodConfig: null,
            sourceLocation: SourceLocation.None,
            returnType: wtypes.boolWType,
            documentation: nodeFactory.methodDocumentation(),
            body: nodeFactory.block({
                sourceLocation: SourceLocation.None,
            }, nodeFactory.returnStatement({
                sourceLocation: SourceLocation.None,
                value: nodeFactory.aRC4Router({ sourceLocation: SourceLocation.None, wtype: wtypes.boolWType }),
            })),
            inline: null,
        }),
    });
    AwstBuildContext.current.addToCompilationSet(contractCref, contract);
}

function buildAwst({ program, sourceFiles }, options) {
    return AwstBuildContext.run(program, () => {
        buildLibAwst();
        const moduleAwst = [];
        for (const [sourcePath, sourceFile] of Object.entries(sourceFiles)) {
            try {
                AwstBuildContext.current.runInChildContext(() => {
                    const visitor = new SourceFileVisitor(sourceFile);
                    const algoFile = options.filePaths.find((p) => p.sourceFile === sourcePath);
                    const module = visitor.buildModule();
                    if (options.outputAwst && algoFile) {
                        writeArtifact({
                            sourceFile: sourceFile.fileName,
                            outDir: algoFile.outDir,
                            kind: ArtifactKind.Awst,
                            obj: module,
                            buildArtifact(module) {
                                const toCode = new ToCodeVisitor();
                                return module.flatMap((s) => s.accept(toCode)).join('\n');
                            },
                        });
                    }
                    if (options.outputAwstJson && algoFile) {
                        writeArtifact({
                            sourceFile: sourceFile.fileName,
                            outDir: algoFile.outDir,
                            kind: ArtifactKind.AwstJson,
                            obj: module,
                            buildArtifact(module) {
                                return jsonSerializeAwst(module);
                            },
                        });
                    }
                    moduleAwst.push(...module);
                });
            }
            catch (e) {
                invariant(e instanceof Error, 'Only errors should be thrown');
                logger.error(e);
            }
        }
        return [moduleAwst, AwstBuildContext.current.compilationSet];
    });
}

function resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options) {
    return moduleLiterals.map(({ text: moduleName }) => {
        const result = ts.resolveModuleName(moduleName, containingFile, options, {
            fileExists: ts.sys.fileExists,
            readFile: ts.sys.readFile,
        }, undefined, redirectedReference);
        if (!result.resolvedModule && !containingFile.endsWith('.d.ts')) {
            logger.warn(undefined, `Could not resolve typings for module ${moduleName} referenced by file ${containingFile}. `);
        }
        return result;
    });
}

function createTsProgram(options) {
    const compilerOptions = {
        allowJs: false,
        strict: true,
        // Lib names need to be the full file name from the typescript package 'lib' folder.
        lib: ['lib.es2023.d.ts'],
        libReplacement: false,
        target: ts.ScriptTarget.ES2023,
        module: ts.ModuleKind.ESNext,
        moduleResolution: ts.ModuleResolutionKind.Bundler,
    };
    const host = ts.createCompilerHost(compilerOptions);
    const fileMap = options.filePaths.reduce((acc, cur) => acc.set(cur.sourceFile, cur), new Map());
    const { fileExists, readFile } = host;
    host.fileExists = function (fileName) {
        return fileMap.has(fileName) || fileExists(fileName);
    };
    host.readFile = function (fileName) {
        const matchedFile = fileMap.get(fileName);
        if (matchedFile?.fileContents) {
            return matchedFile.fileContents;
        }
        return readFile(fileName);
    };
    host.resolveModuleNameLiterals = resolveModuleNameLiterals;
    const program = ts.createProgram(options.filePaths.map((p) => p.sourceFile), compilerOptions, host);
    const programDirectory = program.getCurrentDirectory();
    const sourceFiles = Object.fromEntries(program
        .getSourceFiles()
        .filter((f) => !f.isDeclarationFile)
        .map((f) => {
        if (!f['externalModuleIndicator']) {
            logger.warn(SourceLocation.fromFile(f, programDirectory), 'File is being interpreted as a script because it has no import or export statements. Containing statements will be evaluated in a global context.');
        }
        return [normalisePath(f.fileName, programDirectory), f];
    }));
    LoggingContext.current.sourcesByPath = Object.fromEntries(Object.entries(sourceFiles).map(([path, file]) => {
        return [path, file.getFullText().replace(/\r\n/g, '\n').split(/\n/g)];
    }));
    reportDiagnostics(program);
    return {
        sourceFiles,
        program,
        programDirectory: program.getCurrentDirectory(),
    };
}
function reportDiagnostics(program) {
    function reportDiagnostic(diagnostic) {
        if (isDiagnosticWithLocation(diagnostic)) {
            const sourceLocation = SourceLocation.fromDiagnostic(diagnostic, program.getCurrentDirectory());
            const text = typeof diagnostic.messageText === 'string' ? diagnostic.messageText : diagnostic.messageText.messageText;
            switch (diagnostic.category) {
                case ts.DiagnosticCategory.Error:
                    logger.error(sourceLocation, text);
                    break;
                case ts.DiagnosticCategory.Warning:
                    logger.warn(sourceLocation, text);
                    break;
            }
        }
    }
    function isDiagnosticWithLocation(d) {
        return Object.hasOwn(d, 'file');
    }
    program.getSemanticDiagnostics().forEach(reportDiagnostic);
    program.getSyntacticDiagnostics().forEach(reportDiagnostic);
}

function jsonSerializeSourceFiles(sourceFiles, programDirectory) {
    return JSON.stringify(Object.fromEntries(Object.entries(sourceFiles).map(([key, value]) => [path.join(programDirectory, key), value])), (key, value) => {
        if (ts.isSourceFile(value)) {
            return value.getFullText().replace(/\r\n/g, '\n').split(/\n/g);
        }
        return value;
    }, 2);
}

function buildCompilationSetMapping({ awst, inputPaths, compilationSet, }) {
    const setIds = new Set(compilationSet.compilationOutputSet.map((s) => s.id));
    return awst.reduce((acc, cur) => {
        if (setIds.has(cur.id.toString())) {
            const matchedPath = inputPaths.find((p) => p.sourceFile === cur.sourceLocation.file);
            if (matchedPath) {
                mkDirIfNotExists(matchedPath.outDir);
                acc[cur.id.toString()] = matchedPath.outDir;
            }
        }
        return acc;
    }, {});
}

class InvokeCliError extends Error {
    exit;
    constructor(exit) {
        this.exit = exit;
        if (exit.code) {
            super(`Exited with code ${exit.code}`);
        }
        else if (exit.signal) {
            super(`Exited with signal ${exit.signal}`);
        }
        else {
            super('Exited with unknown cause');
        }
    }
}
function invokeCli(options) {
    return new Promise((resolve, reject) => {
        const lineAggregator = new LineAggregator(options.onReceiveLine);
        const process = spawn(options.command, options.args, {
            stdio: 'pipe',
        });
        process.stdout.on('data', (data) => lineAggregator.aggregate(data));
        process.once('close', (code) => {
            lineAggregator.flush();
            resolve({
                code: code ?? 0,
                lines: lineAggregator.lines,
            });
        });
        process.once('exit', (code, signal) => {
            if (signal !== null) {
                reject(new InvokeCliError({ signal }));
            }
            lineAggregator.flush();
            resolve({
                code: code ?? 0,
                lines: lineAggregator.lines,
            });
        });
        process.once('error', reject);
    });
}
class LineAggregator {
    onLine;
    #line = '';
    #lines = [];
    constructor(onLine) {
        this.onLine = onLine;
    }
    aggregate(chunk) {
        if (chunk === undefined || chunk === null)
            return;
        const text = chunk.toString('utf-8');
        for (const c of text) {
            switch (c) {
                case '\n':
                    this.flushLine();
                    break;
                case '\r':
                    continue;
                default:
                    this.#line += c;
                    break;
            }
        }
    }
    flush() {
        if (this.#line)
            this.flushLine();
    }
    flushLine() {
        this.#lines.push(this.#line);
        this.onLine?.(this.#line);
        this.#line = '';
    }
    get lines() {
        return this.#lines;
    }
}

async function runPuya({ command, args, cwd, onOutput, }) {
    const result = await invokeCli({
        command,
        args,
        onReceiveLine: onOutput});
    if (result.code !== 0) {
        logger.critical(undefined, `Compilation exited with status ${result.code}`);
    }
}

var VersionCompareVerdict;
(function (VersionCompareVerdict) {
    VersionCompareVerdict["ExactMatch"] = "ExactMatch";
    VersionCompareVerdict["Inconclusive"] = "Inconclusive";
    VersionCompareVerdict["MajorMismatch"] = "MajorMismatch";
    VersionCompareVerdict["MinorMismatch"] = "MinorMismatch";
    VersionCompareVerdict["OlderRevision"] = "OlderRevision";
    VersionCompareVerdict["NewerRevision"] = "NewerRevision";
})(VersionCompareVerdict || (VersionCompareVerdict = {}));
async function comparePuyaVersion(puyaPath) {
    const target = Constants.targetedPuyaVersion;
    const versionParser = new VersionParser();
    await runPuya({
        command: puyaPath,
        args: ['--version'],
        onOutput: (line) => versionParser.receiveLine(line),
    });
    if (!versionParser.version)
        return { target, verdict: VersionCompareVerdict.Inconclusive };
    const ver = versionParser.version;
    // Compare
    const [major, minor, rev] = target.split('.').map((x) => Number(x));
    if (ver.major !== major)
        return { verdict: VersionCompareVerdict.MajorMismatch, target, found: ver.formatted };
    if (ver.minor !== minor)
        return { verdict: VersionCompareVerdict.MinorMismatch, target, found: ver.formatted };
    if (ver.rev < rev)
        return { verdict: VersionCompareVerdict.OlderRevision, target, found: ver.formatted };
    if (ver.rev > rev)
        return { verdict: VersionCompareVerdict.NewerRevision, target, found: ver.formatted };
    return { verdict: VersionCompareVerdict.ExactMatch, target, found: ver.formatted };
}
async function checkPuyaVersion(puyaPath) {
    const result = await comparePuyaVersion(puyaPath);
    switch (result.verdict) {
        case VersionCompareVerdict.Inconclusive:
            logger.warn(undefined, `Unable to verify the version of Puya at ${puyaPath}.`);
            break;
        case VersionCompareVerdict.MajorMismatch:
        case VersionCompareVerdict.MinorMismatch:
            logger.warn(undefined, `Version of Puya at ${puyaPath} (${result.found}) does not match targeted version (${result.target}). There may be compatibility issues.`);
            break;
        case VersionCompareVerdict.OlderRevision:
            logger.warn(undefined, `Revision of Puya at ${puyaPath} (${result.found}) is older than the targeted revision (${result.target})`);
            break;
        case VersionCompareVerdict.NewerRevision:
            logger.debug(undefined, `Revision of Puya at ${puyaPath} (${result.found}) is newer than the targeted revision (${result.target})`);
            break;
    }
}
class VersionParser {
    #ver;
    receiveLine(line) {
        const matched = /^puya ((\d+)\.(\d+)\.(\d+))$/.exec(line);
        if (!matched) {
            logger.debug(undefined, `'puya --version' command returned unexpected output: "${line}"`);
        }
        else {
            this.#ver = {
                formatted: matched[1],
                major: Number(matched[2]),
                minor: Number(matched[3]),
                rev: Number(matched[4]),
            };
        }
    }
    get version() {
        return this.#ver;
    }
}

const puyaLog = z.object({
    level: z.nativeEnum(LogLevel),
    location: z
        .object({
        file: z.string(),
        line: z.number(),
        end_line: z.number().or(z.null()),
        column: z.number(),
        end_column: z.number().or(z.null()),
    })
        .or(z.null()),
    message: z.string(),
});
function deserializeAndLog(logText) {
    try {
        const log = puyaLog.parse(JSON.parse(logText));
        const sourceLocation = log.location
            ? new SourceLocation({
                file: upath.normalize(log.location.file),
                line: log.location.line,
                endLine: log.location.end_line ?? log.location.line + 1,
                column: log.location.column,
                endColumn: log.location.end_column ?? log.location.column,
                scope: 'range',
            })
            : undefined;
        logger.addLog(log.level, sourceLocation, log.message);
    }
    catch (e) {
        logger.error(undefined, `Could not parse log output from puya cli ${e}`);
    }
}

async function invokePuya({ moduleAwst, programDirectory, sourceFiles, options, compilationSet, }) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        if (options.customPuyaPath && !options.skipVersionCheck) {
            checkPuyaVersion(options.customPuyaPath);
        }
        const puyaPath = options.customPuyaPath ?? (await resolvePuyaPath());
        // Write AWST file
        const moduleAwstFile = __addDisposableResource(env_1, generateTempFile(), false);
        logger.debug(undefined, `Writing awst to ${moduleAwstFile.filePath}`);
        const serializer = new AwstSerializer({
            programDirectory: programDirectory,
            sourcePaths: 'absolute',
        });
        moduleAwstFile.writeFileSync(serializer.serialize(moduleAwst), 'utf-8');
        // Write source annotations
        const moduleSourceFile = __addDisposableResource(env_1, generateTempFile(), false);
        logger.debug(undefined, `Write source to ${moduleSourceFile.filePath}`);
        moduleSourceFile.writeFileSync(jsonSerializeSourceFiles(sourceFiles, programDirectory), 'utf-8');
        // Write puya options
        const puyaOptions = options.buildPuyaOptions(buildCompilationSetMapping({
            awst: moduleAwst,
            inputPaths: options.filePaths,
            compilationSet,
        }));
        const optionsFile = __addDisposableResource(env_1, generateTempFile(), false);
        logger.debug(undefined, `Write options to ${optionsFile.filePath}`);
        optionsFile.writeFileSync(new SnakeCaseSerializer().serialize(puyaOptions));
        const puyaArgs = [
            '--options',
            optionsFile.filePath,
            `--awst`,
            moduleAwstFile.filePath,
            `--source-annotations`,
            moduleSourceFile.filePath,
            '--log-level',
            getPuyaLogLevel(options.logLevel),
            '--log-format',
            'json',
        ];
        // Useful to have this in a var to copy/paste when debugging puya
        const puyaArgsStr = puyaArgs.join(' ');
        logger.debug(undefined, `Invoking puya: ${puyaPath} ${puyaArgsStr}`);
        await runPuya({
            command: puyaPath,
            args: puyaArgs,
            cwd: programDirectory,
            onOutput: deserializeAndLog,
        });
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        __disposeResources(env_1);
    }
}
function getPuyaLogLevel(logLevel) {
    switch (logLevel) {
        case LogLevel.Debug:
            return 'debug';
        case LogLevel.Info:
            return 'info';
        case LogLevel.Warning:
            return 'warning';
        case LogLevel.Error:
            return 'error';
        case LogLevel.Critical:
            return 'critical';
    }
}

async function compile(options) {
    const loggerCtx = LoggingContext.current;
    registerPTypes(typeRegistry);
    const programResult = createTsProgram(options);
    if (loggerCtx.hasErrors()) {
        logger.info(undefined, 'Compilation halted due to parse errors');
        return {
            programDirectory: programResult.programDirectory,
            ast: programResult.sourceFiles,
        };
    }
    const [moduleAwst, compilationSet] = buildAwst(programResult, options);
    validateAwst(moduleAwst);
    if (loggerCtx.hasErrors()) {
        logger.info(undefined, 'Compilation halted due to errors');
        return {
            programDirectory: programResult.programDirectory,
            awst: moduleAwst,
            ast: programResult.sourceFiles,
            compilationSet,
        };
    }
    if (!options.dryRun) {
        await invokePuya({
            options,
            moduleAwst,
            programDirectory: programResult.programDirectory,
            compilationSet,
            sourceFiles: programResult.sourceFiles,
        });
    }
    return {
        programDirectory: programResult.programDirectory,
        awst: moduleAwst,
        ast: programResult.sourceFiles,
        compilationSet,
    };
}

function determineOutDir(inputPath, sourceFile, outDir) {
    const outDirBase = findMinimalMatch(upath.normalizeTrim(inputPath), sourceFile);
    const subPath = upath.dirname(sourceFile.slice(outDirBase.length));
    if (upath.isAbsolute(outDir)) {
        return upath.normalizeTrim(upath.join(outDir, subPath));
    }
    return upath.normalizeTrim(upath.join(outDirBase, outDir, subPath));
}
function trimCurrentDir(path) {
    return path.startsWith('./') ? path.slice(2) : path;
}
function findMinimalMatch(inputPath, testPath) {
    if (inputPath === '.' || testPath === '.') {
        return '';
    }
    const [matchedPath] = minimatch.match([trimCurrentDir(testPath)], trimCurrentDir(inputPath));
    if (matchedPath) {
        if (matchedPath.endsWith('.algo.ts')) {
            return upath.dirname(matchedPath);
        }
        return matchedPath;
    }
    return findMinimalMatch(inputPath, upath.dirname(testPath));
}

const processInputPaths = ({ paths, workingDirectory = process.cwd(), outDir = 'out', }) => {
    const filePaths = [];
    for (const p of paths.map((p) => upath.normalizeTrim(p))) {
        if (p.endsWith('.algo.ts')) {
            if (fs__default.existsSync(p)) {
                const sourceFile = normalisePath(p, workingDirectory);
                filePaths.push({
                    sourceFile,
                    outDir: determineOutDir(p, sourceFile, outDir),
                });
            }
            else {
                logger.warn(undefined, `File ${p} could not be found`);
            }
        }
        else if (p.endsWith('.ts')) {
            logger.warn(undefined, `Ignoring path ${p} as it does use the .algo.ts extension`);
        }
        else {
            const matches = globSync(upath.join(p, '**/*.algo.ts'));
            if (matches.length) {
                for (const match of matches) {
                    const sourceFile = normalisePath(match, workingDirectory);
                    filePaths.push({
                        sourceFile,
                        outDir: determineOutDir(p, sourceFile, outDir),
                    });
                }
            }
            else {
                logger.warn(undefined, `Path '${p}' did not match any .algo.ts files`);
            }
        }
    }
    if (filePaths.length === 0) {
        throw new PuyaError('Input paths did not match any .algo.ts files');
    }
    return filePaths.map(replaceOutDirTokens);
};
function replaceOutDirTokens(algoFile) {
    const replacements = {
        name: upath.basename(algoFile.sourceFile).replace('.algo.ts', ''),
    };
    return {
        ...algoFile,
        outDir: algoFile.outDir.replaceAll('[name]', replacements.name),
    };
}

class CompileOptions {
    filePaths;
    logLevel;
    outputAwst;
    outputAwstJson;
    skipVersionCheck;
    /**
     * Don't generate artifacts for puya, or invoke puya
     */
    dryRun;
    outputTeal;
    outputArc32;
    outputArc56;
    outputSsaIr;
    outputOptimizationIr;
    outputDestructuredIr;
    outputMemoryIr;
    outputBytecode;
    outputSourceMap;
    debugLevel;
    optimizationLevel;
    targetAvmVersion;
    cliTemplateDefinitions;
    templateVarsPrefix;
    localsCoalescingStrategy;
    customPuyaPath;
    constructor(options) {
        this.filePaths = options.filePaths;
        this.logLevel = options.logLevel ?? LogLevel.Info;
        this.outputAwst = options.outputAwst ?? false;
        this.outputAwstJson = options.outputAwstJson ?? false;
        this.skipVersionCheck = options.skipVersionCheck ?? false;
        this.dryRun = options.dryRun ?? false;
        this.outputTeal = options.outputTeal ?? false;
        this.outputArc32 = options.outputArc32 ?? false;
        this.outputArc56 = options.outputArc56 ?? false;
        this.outputSsaIr = options.outputSsaIr ?? false;
        this.outputOptimizationIr = options.outputOptimizationIr ?? false;
        this.outputDestructuredIr = options.outputDestructuredIr ?? false;
        this.outputMemoryIr = options.outputMemoryIr ?? false;
        this.outputBytecode = options.outputBytecode ?? false;
        this.outputSourceMap = options.outputSourceMap ?? false;
        this.debugLevel = options.debugLevel ?? defaultPuyaOptions.debugLevel;
        this.optimizationLevel = options.optimizationLevel ?? defaultPuyaOptions.optimizationLevel;
        this.targetAvmVersion = options.targetAvmVersion ?? defaultPuyaOptions.targetAvmVersion;
        this.cliTemplateDefinitions = options.cliTemplateDefinitions ?? defaultPuyaOptions.cliTemplateDefinitions;
        this.templateVarsPrefix = options.templateVarsPrefix ?? defaultPuyaOptions.templateVarsPrefix;
        this.localsCoalescingStrategy = options.localsCoalescingStrategy ?? defaultPuyaOptions.localsCoalescingStrategy;
        this.customPuyaPath = options.customPuyaPath;
    }
    buildPuyaOptions(compilationSet) {
        return new PuyaOptions({ ...this, compilationSet });
    }
}
var LocalsCoalescingStrategy;
(function (LocalsCoalescingStrategy) {
    LocalsCoalescingStrategy["root_operand"] = "root_operand";
    LocalsCoalescingStrategy["root_operand_excluding_args"] = "root_operand_excluding_args";
    LocalsCoalescingStrategy["aggressive"] = "aggressive";
})(LocalsCoalescingStrategy || (LocalsCoalescingStrategy = {}));
const defaultPuyaOptions = {
    outputTeal: true,
    outputArc32: true,
    outputArc56: true,
    outputSsaIr: false,
    outputSourceMap: true,
    outputOptimizationIr: false,
    outputDestructuredIr: false,
    outputMemoryIr: false,
    outputBytecode: false,
    debugLevel: 1,
    optimizationLevel: 1,
    targetAvmVersion: 10,
    cliTemplateDefinitions: {},
    templateVarsPrefix: 'TMPL_',
    localsCoalescingStrategy: LocalsCoalescingStrategy.root_operand,
};
class PuyaOptions {
    outputTeal;
    outputArc32;
    outputArc56;
    outputSsaIr;
    outputOptimizationIr;
    outputDestructuredIr;
    outputMemoryIr;
    outputBytecode;
    outputSourceMap;
    debugLevel;
    optimizationLevel;
    targetAvmVersion;
    cliTemplateDefinitions;
    templateVarsPrefix;
    localsCoalescingStrategy;
    compilationSet;
    constructor(options) {
        this.compilationSet = options.compilationSet;
        this.outputTeal = options.outputTeal;
        this.outputArc32 = options.outputArc32;
        this.outputArc56 = options.outputArc56;
        this.outputSsaIr = options.outputSsaIr;
        this.outputOptimizationIr = options.outputOptimizationIr;
        this.outputDestructuredIr = options.outputDestructuredIr;
        this.outputMemoryIr = options.outputMemoryIr;
        this.outputBytecode = options.outputBytecode;
        this.debugLevel = options.debugLevel;
        this.optimizationLevel = options.optimizationLevel;
        this.targetAvmVersion = options.targetAvmVersion;
        this.cliTemplateDefinitions = options.cliTemplateDefinitions;
        this.templateVarsPrefix = options.templateVarsPrefix;
        this.localsCoalescingStrategy = options.localsCoalescingStrategy;
        this.outputSourceMap = options.outputSourceMap;
    }
}

export { GlobalStateFunction as $, ALL_OP_ENUMS as A, BaseContractClassType as B, BoxGeneric as C, BoxMapFunction as D, BoxMapGeneric as E, BoxMapPType as F, BoxPType as G, BoxRefFunction as H, BoxRefPType as I, ByteClass as J, BytesFunction as K, ClassMethodDecoratorContext as L, ClearStateProgram as M, ClusteredContractClassType as N, ClusteredPrototype as O, ContractClassPType as P, ContractProxyGeneric as Q, ContractProxyType as R, DynamicArrayConstructor as S, DynamicArrayGeneric as T, DynamicArrayType as U, DynamicBytesConstructor as V, DynamicBytesType as W, FunctionPType as X, GeneratorGeneric as Y, GeneratorType as Z, GenericPType as _, ARC4ArrayType as a, UintN8Class as a$, GlobalStateGeneric as a0, GlobalStateType as a1, GroupTransactionPType as a2, InnerTransactionPType as a3, InstanceType as a4, InternalType as a5, IntersectionPType as a6, IntrinsicEnumType as a7, IntrinsicFunctionGroupType as a8, IntrinsicFunctionGroupTypeType as a9, StaticArrayType as aA, StaticBytesConstructor as aB, StaticBytesGeneric as aC, StaticBytesType as aD, StorageProxyPType as aE, StringFunction as aF, SuperPrototypeSelector as aG, SuperPrototypeSelectorGeneric as aH, TemplateVarFunction as aI, TransactionFunction as aJ, TransactionFunctionType as aK, TransientType as aL, TuplePType as aM, TypeParameterType as aN, TypedApplicationCallResponseGeneric as aO, TypedApplicationCallResponseType as aP, UFixedNxMClass as aQ, UFixedNxMGeneric as aR, UFixedNxMType as aS, Uint64EnumMemberType as aT, Uint64EnumType as aU, Uint64Function as aV, UintN128Class as aW, UintN16Class as aX, UintN256Class as aY, UintN32Class as aZ, UintN64Class as a_, IntrinsicFunctionType as aa, IntrinsicFunctionTypeType as ab, IterableIteratorGeneric as ac, IterableIteratorType as ad, ItxnParamsPType as ae, KeyRegistrationTxnFunction as af, LibClassType as ag, LibFunctionType as ah, LocalStateFunction as ai, LocalStateGeneric as aj, LocalStateType as ak, LogicSigPType as al, MutableArrayConstructor as am, MutableArrayGeneric as an, MutableArrayType as ao, NamespacePType as ap, NativeNumericType as aq, NumericLiteralPType as ar, ObjectPType as as, PType as at, PaymentTxnFunction as au, PolytypeClassMethodHelper as av, PromiseGeneric as aw, PromiseType as ax, StaticArrayConstructor as ay, StaticArrayGeneric as az, ARC4BoolClass as b, keyRegistrationItxnType as b$, UintNClass as b0, UintNGeneric as b1, UintNType as b2, UnionPType as b3, UnsupportedType as b4, abiCallFunction as b5, accountPType as b6, anyGtxnType as b7, anyItxnType as b8, anyPType as b9, assetTransferGtxnType as bA, assetTransferItxnFn as bB, assetTransferItxnParamsType as bC, assetTransferItxnType as bD, base64PType as bE, baseContractType as bF, bigIntPType as bG, biguintPType as bH, boolPType as bI, boxRefType as bJ, bytesPType as bK, compileArc4Function as bL, compileFunctionType as bM, compiledContractType as bN, compiledLogicSigType as bO, contractOptionsDecorator as bP, decodeArc4Function as bQ, ecPType as bR, ecdsaPType as bS, encodeArc4Function as bT, ensureBudgetFunction as bU, errFunction as bV, gtxnUnion as bW, interpretAsArc4Function as bX, keyRegistrationGtxnType as bY, keyRegistrationItxnFn as bZ, keyRegistrationItxnParamsType as b_, applicationCallGtxnType as ba, applicationCallItxnFn as bb, applicationCallItxnParamsType as bc, applicationItxnType as bd, applicationPType as be, arc28EmitFunction as bf, arc4AbiMethodDecorator as bg, arc4AddressAlias as bh, arc4BareMethodDecorator as bi, arc4BaseContractType as bj, arc4BooleanType as bk, arc4ByteAlias as bl, arc4EncodedLengthFunction as bm, arc4StringType as bn, arc4StructBaseType as bo, assertFunction as bp, assertMatchFunction as bq, assetConfigGtxnType as br, assetConfigItxnFn as bs, assetConfigItxnParamsType as bt, assetConfigItxnType as bu, assetFreezeGtxnType as bv, assetFreezeItxnFn as bw, assetFreezeItxnParamsType as bx, assetFreezeItxnType as by, assetPType as bz, ARC4EncodedType as c, logFunction as c0, logicSigBaseType as c1, logicSigOptionsDecorator as c2, matchFunction as c3, methodSelectorFunction as c4, mimcConfigurationsPType as c5, neverPType as c6, nullPType as c7, numberPType as c8, onCompleteActionType as c9, opUpFeeSourceType as ca, paymentGtxnType as cb, paymentItxnFn as cc, paymentItxnParamsType as cd, paymentItxnType as ce, ptypeToArc4EncodedType as cf, stringPType as cg, submitGroupItxnFunction as ch, transactionTypeType as ci, uint64PType as cj, undefinedPType as ck, unknownPType as cl, urangeFunction as cm, voidPType as cn, vrfVerifyPType as co, registerPTypes as cp, typeRegistry as cq, TypeResolver as cr, compile as cs, processInputPaths as ct, CompileOptions as cu, defaultPuyaOptions as cv, parseCliTemplateVar as cw, LocalsCoalescingStrategy as cx, ARC4InstanceType as d, ARC4StrClass as e, ARC4StructClass as f, ARC4StructType as g, ARC4TupleType as h, AccountFunction as i, AddressClass as j, AnyPType as k, ApplicationFunctionType as l, ApplicationTxnFunction as m, ApprovalProgram as n, Arc4TupleClass as o, Arc4TupleGeneric as p, ArrayLiteralPType as q, ArrayPType as r, AssetConfigTxnFunction as s, AssetFreezeTxnFunction as t, AssetFunction as u, AssetTransferTxnFunction as v, BigIntLiteralPType as w, BigUintFunction as x, BooleanFunction as y, BoxFunction as z };
//# sourceMappingURL=options-D7OvUjFs.js.map
