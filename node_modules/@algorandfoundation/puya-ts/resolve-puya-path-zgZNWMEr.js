import { __addDisposableResource, __disposeResources } from 'tslib';
import * as fs from 'fs';
import fs__default$1, { rmdirSync, existsSync, statSync, mkdirSync } from 'fs';
import { AsyncLocalStorage } from 'node:async_hooks';
import ts from 'typescript';
import { Buffer as Buffer$1 } from 'node:buffer';
import fs__default from 'node:fs';
import { TextDecoder } from 'node:util';
import upath from 'upath';
import { onExit } from 'signal-exit';
import * as crypto from 'crypto';
import { randomUUID } from 'crypto';
import { fileURLToPath } from 'node:url';
import * as path from 'path';
import * as tar from 'tar';
import { globIterateSync } from 'glob';
import os from 'os';

const algoTsPackage = '@algorandfoundation/algorand-typescript';
const Constants = {
    algoTsPackage,
    moduleNames: {
        polytype: 'polytype/lib/polytype-module.d.ts',
        algoTs: {
            arc28: `${algoTsPackage}/arc-28.d.ts`,
            arc4: {
                index: `${algoTsPackage}/arc4/index.d.ts`,
                encodedTypes: `${algoTsPackage}/arc4/encoded-types.d.ts`,
                c2c: `${algoTsPackage}/arc4/c2c.d.ts`,
            },
            baseContract: `${algoTsPackage}/base-contract.d.ts`,
            box: `${algoTsPackage}/box.d.ts`,
            compiled: `${algoTsPackage}/compiled.d.ts`,
            itxn: `${algoTsPackage}/itxn.d.ts`,
            gtxn: `${algoTsPackage}/gtxn.d.ts`,
            logicSig: `${algoTsPackage}/logic-sig.d.ts`,
            mutableArray: `${algoTsPackage}/mutable-array.d.ts`,
            onCompleteAction: `${algoTsPackage}/on-complete-action.d.ts`,
            op: `${algoTsPackage}/op.d.ts`,
            primitives: `${algoTsPackage}/primitives.d.ts`,
            reference: `${algoTsPackage}/reference.d.ts`,
            state: `${algoTsPackage}/state.d.ts`,
            templateVar: `${algoTsPackage}/template-var.d.ts`,
            transactions: `${algoTsPackage}/transactions.d.ts`,
            util: `${algoTsPackage}/util.d.ts`,
        },
    },
    symbolNames: {
        approvalProgramMethodName: 'approvalProgram',
        clearStateProgramMethodName: 'clearStateProgram',
        arc4BareDecoratorName: 'arc4.baremethod',
        arc4AbiDecoratorName: 'arc4.abimethod',
        contractOptionsDecoratorName: 'contract',
        logicSigOptionsDecoratorName: 'logicsig',
        constructorMethodName: 'constructor',
        logicSigProgramMethodName: 'program',
        defaultCreateMethodName: '__algots__.defaultCreate',
        conventionalRouting: {
            closeOutOfApplicationMethodName: 'closeOutOfApplication',
            createApplicationMethodName: 'createApplication',
            deleteApplicationMethodName: 'deleteApplication',
            optInToApplicationMethodName: 'optInToApplication',
            updateApplicationMethodName: 'updateApplication',
        },
    },
    algo: {
        arc4: {
            logPrefixHex: '151F7C75',
        },
        addressLength: 32,
        encodedAddressLength: 58,
        maxTransactionGroupSize: 16,
        zeroAddressB32: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ',
    },
    supportedAvmVersions: [10n, 11n],
    targetedPuyaVersion: '4.7.0',
    puyaGithubRepo: 'algorandfoundation/puya',
    minNodeVersion: '22.14.0',
    languageServerSource: 'puyats',
};

class PuyaError extends Error {
    sourceLocation;
    constructor(message, options) {
        super(message, options);
        this.sourceLocation = options?.sourceLocation;
    }
}
/**
 * Any error that is 'caused' by a user of Puya
 */
class UserError extends PuyaError {
}
/**
 * Thrown when the user's code is invalid, or not supported
 */
class CodeError extends UserError {
    static unexpectedUnhandledArgs({ sourceLocation }) {
        return new CodeError('Unexpected/unhandled args', {
            sourceLocation,
        });
    }
    static unexpectedTypeArgs({ sourceLocation }) {
        return new CodeError('Function does not accept type arguments', {
            sourceLocation,
        });
    }
    static expectedCompileTimeConstant({ sourceLocation }) {
        return new CodeError('Expected compile time constant', {
            sourceLocation,
        });
    }
    static invalidAssignmentTarget({ sourceLocation, name }) {
        return new CodeError(`${name} is not a valid assignment target`, {
            sourceLocation,
        });
    }
    static cannotResolveToType({ sourceType, targetType, sourceLocation, }) {
        const targetName = targetType instanceof Function ? targetType.name : targetType.fullName;
        return new CodeError(`Cannot resolve ${sourceType} to ${targetName}`, { sourceLocation });
    }
}
/**
 * Thrown when the compiler ends up in an unrecoverable state
 */
class InternalError extends PuyaError {
    static shouldBeUnreachable() {
        return new InternalError('Code should be unreachable');
    }
}
class NotSupported extends CodeError {
    constructor(featureName, options) {
        super(`Not Supported: ${featureName}`, options);
    }
}
const throwError = (error) => {
    throw error;
};
const wrapInCodeError = (func, sourceLocation) => {
    try {
        return func();
    }
    catch (e) {
        if (e instanceof Error) {
            throw new CodeError(e.message, { sourceLocation, cause: e });
        }
        else {
            throw new CodeError(String(e), { sourceLocation });
        }
    }
};

const BASE32_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'.split('');
const CHAR_TO_NUM = BASE32_ALPHABET.reduce((acc, cur, index) => ((acc[cur] = index), acc), {});
const base32ToUint8Array = (value) => {
    let allChars = value
        .split('')
        .filter((c) => c !== '=')
        .map((c) => {
        const cUpper = c.toUpperCase();
        if (cUpper in CHAR_TO_NUM)
            return CHAR_TO_NUM[cUpper];
        throw new Error(`Invalid base32 char ${c}`);
    });
    const bytes = new Array();
    while (allChars.length) {
        const [a, b, c, d, e, f, g, h, ...rest] = allChars;
        if (a === undefined || b === undefined)
            break;
        bytes.push(((a << 3) | (b >>> 2)) & 255);
        if (c === undefined || d === undefined)
            break;
        bytes.push(((b << 6) | (c << 1) | (d >>> 4)) & 255);
        if (e === undefined)
            break;
        bytes.push(((d << 4) | (e >>> 1)) & 255);
        if (f === undefined || g === undefined)
            break;
        bytes.push(((e << 7) | (f << 2) | (g >>> 3)) & 255);
        if (h === undefined)
            break;
        bytes.push(((g << 5) | h) & 255);
        allChars = rest;
    }
    return new Uint8Array(bytes);
};
const uint8ArrayToBase32 = (value) => {
    let allBytes = Array.from(value);
    let base32str = '';
    while (allBytes.length) {
        const [a, b, c, d, e, ...rest] = allBytes ?? [0, 0, 0, 0, 0];
        if (allBytes.length < 1)
            break;
        base32str += BASE32_ALPHABET[a >>> 3];
        base32str += BASE32_ALPHABET[((a << 2) | ((b || 0) >>> 6)) & 31];
        if (allBytes.length < 2)
            break;
        base32str += BASE32_ALPHABET[(b >>> 1) & 31];
        base32str += BASE32_ALPHABET[((b << 4) | (c >>> 4)) & 31];
        if (allBytes.length < 3)
            break;
        base32str += BASE32_ALPHABET[((c << 1) | (d >>> 7)) & 31];
        if (allBytes.length < 4)
            break;
        base32str += BASE32_ALPHABET[(d >>> 2) & 31];
        base32str += BASE32_ALPHABET[((d << 3) | (e >>> 5)) & 31];
        if (allBytes.length < 5)
            break;
        base32str += BASE32_ALPHABET[e & 31];
        allBytes = rest;
    }
    return base32str;
};

class InvariantError extends InternalError {
}
/**
 * Checks an invariant condition hold true. If this check fails it indicates the compiler is in an unstable state. For invariants related to
 * user code, use codeInvariant below.
 *
 * @param condition
 * @param message
 * @param sourceLocation
 */
function invariant(condition, message, sourceLocation) {
    if (!condition) {
        throw new InvariantError(message, { sourceLocation });
    }
}
/**
 * Checks an invariant related to user code holds true. If this check fails it indicates the user code is not valid. For invariants the user
 * has no control over, use invariant above.
 * @param condition
 * @param message
 * @param sourceLocation
 */
function codeInvariant(condition, message, sourceLocation) {
    if (!condition) {
        throw new CodeError(message, {
            sourceLocation,
        });
    }
}
const enumFromValue = (value, enumType, message = 'Invalid enum value: ') => {
    if (Object.values(enumType).some((v) => v === value)) {
        return value;
    }
    throw new Error(`${message} ${value}`);
};
const enumKeyFromValue = (value, enumType, message = 'Invalid enum value: ') => {
    const key = Object.entries(enumType).find(([_, v]) => v === value)?.[0];
    if (key) {
        return key;
    }
    throw new Error(`${message} ${value}`);
};
const tryConvertEnum = (value, fromEnum, toEnum) => {
    const keyOfValue = Object.entries(fromEnum).find(([, v]) => v === value)?.[0];
    if (!keyOfValue) {
        return undefined;
    }
    return toEnum[keyOfValue];
};
const expandMaybeArray = (maybeArray) => {
    return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
};
const uint8ArrayToBase64 = (value) => Buffer$1.from(value).toString('base64');
const hexToUint8Array = (value) => {
    invariant(value.length % 2 === 0, 'Hex string must have even number of characters');
    return Uint8Array.from(Buffer$1.from(value, 'hex'));
};
const base64ToUint8Array = (value) => {
    return Uint8Array.from(Buffer$1.from(value, 'base64'));
};
const utf8ToUint8Array = (value) => {
    const encoder = new TextEncoder();
    return encoder.encode(value);
};
const uint8ArrayToBigInt = (v) => {
    // Assume big-endian
    return Array.from(v)
        .toReversed()
        .map((byte_value, i) => BigInt(byte_value) << BigInt(i * 8))
        .reduce((a, b) => a + b, 0n);
};
const uint8ArrayToHex = (value) => Buffer$1.from(value).toString('hex');
const uint8ArrayToUtf8 = (value) => {
    const decoder = new TextDecoder();
    return decoder.decode(value);
};
const bigIntToUint8Array = (val, fixedSize = 'dynamic') => {
    if (val === 0n && fixedSize === 'dynamic') {
        return new Uint8Array(0);
    }
    const maxBytes = fixedSize === 'dynamic' ? 4096 : fixedSize;
    let hex = val.toString(16);
    // Pad the hex with zeros so it matches the size in bytes
    if (fixedSize !== 'dynamic' && hex.length !== fixedSize * 2) {
        hex = hex.padStart(fixedSize * 2, '0');
    }
    else if (hex.length % 2 === 1) {
        // Pad to 'whole' byte
        hex = `0${hex}`;
    }
    if (hex.length > maxBytes * 2) {
        throw new InternalError(`Cannot encode ${val} as ${maxBytes} bytes as it would overflow`);
    }
    const byteArray = new Uint8Array(hex.length / 2);
    for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {
        byteArray[i] = parseInt(hex.slice(j, j + 2), 16);
    }
    return byteArray;
};
const hasFlags = (value, flags) => (value & flags) === flags;
const intersectsFlags = (value, flags) => Boolean(value & flags);
function* enumerate(iterable) {
    let i = 0;
    for (const item of iterable) {
        yield [i, item];
        i++;
    }
}
function toSubScript(num) {
    const subNumbers = ['\u2080', '\u2081', '\u2082', '\u2083', '\u2084', '\u2085', '\u2086', '\u2087', '\u2088', '\u2089'];
    return num
        .toFixed(0)
        .split('')
        .map((x) => subNumbers[parseInt(x)])
        .join('');
}
function instanceOfAny(x, ...types) {
    return types.some((t) => x instanceof t);
}
/**
 * Normalise a file path to only include relevant segments.
 *
 *  - Anything in /node_modules/ is truncated to <package-name>/path.ext
 *  - Anything in workingDirectory is truncated relative to the workingDirectory
 *  - Forward slashes are used to segment paths
 * @param filePath
 * @param workingDirectory
 */
function normalisePath(filePath, workingDirectory) {
    const localPackageName = /packages\/algo-ts\/dist\/(.*)$/.exec(filePath);
    if (localPackageName) {
        return `${Constants.algoTsPackage}/${localPackageName[1]}`;
    }
    const nodeModuleName = /.*\/node_modules\/(.*)$/.exec(filePath);
    if (nodeModuleName) {
        return nodeModuleName[1];
    }
    const cwd = upath.normalize(`${workingDirectory}/`);
    const normalizedPath = upath.normalize(filePath);
    const moduleName = normalizedPath.startsWith(cwd) ? normalizedPath.slice(cwd.length) : normalizedPath;
    return moduleName.replaceAll('\\', '/');
}
const sortBy = (keySelector, dir = 'asc') => (a, b) => {
    const keyA = keySelector(a);
    const keyB = keySelector(b);
    return (dir === 'desc' ? -1 : 1) * (keyA < keyB ? -1 : keyA > keyB ? 1 : 0);
};
const distinctByEquality = (areEqual) => {
    const set = [];
    return (item) => {
        if (set.some((s) => areEqual(s, item)))
            return false;
        set.push(item);
        return true;
    };
};
function mkDirIfNotExists(dir) {
    if (!fs__default.existsSync(dir)) {
        fs__default.mkdirSync(dir, { recursive: true });
    }
}
function sameSets(a, b) {
    const setA = new Set(a);
    const setB = new Set(b);
    return setA.intersection(setB).size === setA.size;
}
const zipStrict = (array1, array2) => {
    invariant(array1.length === array2.length, 'Array lengths must match');
    return array1.map((t1, idx) => [t1, array2[idx]]);
};
function isIn(subject, items) {
    return items.some((i) => i === subject);
}

class SourceLocation {
    file;
    line;
    endLine;
    column;
    endColumn;
    scope;
    constructor(props) {
        invariant(props.line <= props.endLine, 'Start line must be before end line');
        if (props.line === props.endLine)
            invariant(props.column <= props.endColumn, 'Start column must be before end column');
        this.file = props.file ?? null;
        this.line = props.line;
        this.endLine = props.endLine;
        this.column = props.column;
        this.endColumn = props.endColumn;
        this.scope = props.scope;
        // Exclude scope from enumerable properties so it doesn't end up being serialized
        Object.defineProperty(this, 'scope', {
            enumerable: false,
        });
    }
    static getStartAndEnd(node) {
        if (ts.isClassDeclaration(node)) {
            return fromNodeTillStartOfNode(node, node.members.at(0));
        }
        if (ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) {
            return fromNodeTillStartOfNode(node, node.body);
        }
        if (ts.isForStatement(node) || ts.isForInStatement(node) || ts.isForOfStatement(node)) {
            return fromNodeTillStartOfNode(node, node.statement);
        }
        if (ts.isIfStatement(node)) {
            return fromNodeTillStartOfNode(node, node.thenStatement);
        }
        return {
            start: node.getStart(),
            end: node.getEnd(),
        };
    }
    static fromNode(node, programDirectory) {
        const sourceFile = node.getSourceFile();
        const { start, end } = SourceLocation.getStartAndEnd(node);
        const startLoc = sourceFile.getLineAndCharacterOfPosition(start);
        const endLoc = sourceFile.getLineAndCharacterOfPosition(end);
        return new SourceLocation({
            file: normalisePath(sourceFile.fileName, programDirectory),
            line: startLoc.line + 1,
            endLine: endLoc.line + 1,
            column: startLoc.character,
            endColumn: endLoc.character,
            scope: 'range',
        });
    }
    static fromFile(sourceFile, programDirectory) {
        const endPos = sourceFile.getEnd();
        const endLoc = sourceFile.getLineAndCharacterOfPosition(endPos);
        return new SourceLocation({
            file: normalisePath(sourceFile.fileName, programDirectory),
            line: 1,
            endLine: endLoc.line + 1,
            column: 0,
            endColumn: endLoc.character,
            scope: 'file',
        });
    }
    static fromTextRange(sourceFile, textRange, programDirectory) {
        const startLoc = sourceFile.getLineAndCharacterOfPosition(textRange.pos);
        const endLoc = sourceFile.getLineAndCharacterOfPosition(textRange.end);
        return new SourceLocation({
            file: normalisePath(sourceFile.fileName, programDirectory),
            line: startLoc.line + 1,
            endLine: endLoc.line + 1,
            column: startLoc.character,
            endColumn: endLoc.character,
            scope: 'range',
        });
    }
    static fromDiagnostic(diagnostic, programDirectory) {
        const startLoc = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
        return new SourceLocation({
            file: normalisePath(diagnostic.file.fileName, programDirectory),
            line: startLoc.line + 1,
            endLine: startLoc.line + 1,
            column: startLoc.character,
            endColumn: startLoc.character,
            scope: 'range',
        });
    }
    toString() {
        return `${this.file}:${this.line}:${this.column + 1}`;
    }
    static fromLocations(...sourceLocation) {
        const [first, ...rest] = sourceLocation;
        invariant(first && rest.every((r) => r.file === first.file), 'All locations must of the same file');
        if (rest.length === 0)
            return first;
        return sourceLocation.reduce((acc, cur) => {
            return new SourceLocation({
                file: acc.file,
                line: Math.min(acc.line, cur.line),
                endLine: Math.max(acc.endLine, cur.endLine),
                column: acc.line === cur.line ? Math.min(acc.column, cur.column) : acc.line < cur.line ? acc.column : cur.column,
                endColumn: acc.endLine === cur.endLine ? Math.max(acc.endColumn, cur.endColumn) : acc.endLine > cur.endLine ? acc.endColumn : cur.endColumn,
                scope: 'range',
            });
        });
    }
    static None = new SourceLocation({
        line: 1,
        endLine: 1,
        column: 0,
        endColumn: 1,
        scope: 'file',
    });
}
function fromNodeTillStartOfNode(n1, n2) {
    return {
        start: n1.getStart(),
        end: n2 ? n2.getStart() - n2.getLeadingTriviaWidth() : n1.getEnd(),
    };
}

var LogLevel;
(function (LogLevel) {
    LogLevel["Error"] = "error";
    LogLevel["Info"] = "info";
    LogLevel["Warning"] = "warning";
    LogLevel["Debug"] = "debug";
    LogLevel["Critical"] = "critical";
})(LogLevel || (LogLevel = {}));
const logLevelToInt = {
    [LogLevel.Critical]: 4,
    [LogLevel.Error]: 3,
    [LogLevel.Info]: 1,
    [LogLevel.Warning]: 2,
    [LogLevel.Debug]: 0,
};
const isMinLevel = (logLevel, minLevel) => {
    return logLevelToInt[minLevel] <= logLevelToInt[logLevel];
};
const errorOrCritical = new Set([LogLevel.Error, LogLevel.Critical]);
const isErrorOrCritical = (l) => errorOrCritical.has(l);
class PuyaLogger {
    logSinks = [];
    configure(sinks) {
        this.logSinks = sinks;
    }
    addLog(level, source, message) {
        const logEvent = {
            sourceLocation: source ? (source instanceof SourceLocation ? source : source.sourceLocation) : undefined,
            message,
            level,
        };
        LoggingContext.current.logEvents.push(logEvent);
        for (const sink of this.logSinks) {
            if (isMinLevel(logEvent.level, sink.minLogLevel))
                sink.add(logEvent);
        }
    }
    error(source, message) {
        if (source instanceof Error) {
            // Don't include the stack for user errors as the message and source location is what's relevant
            const stack = source instanceof UserError ? '' : `\n ${source.stack}`;
            this.addLog(LogLevel.Error, tryGetSourceLocationFromError(source), `${source.message}${stack}`);
            if (source.cause) {
                this.addLog(LogLevel.Error, tryGetSourceLocationFromError(source.cause), `Caused by: ${source.cause}`);
            }
        }
        else {
            this.addLog(LogLevel.Error, source, message ?? '');
        }
    }
    info(source, message) {
        this.addLog(LogLevel.Info, source, message);
    }
    debug(source, message) {
        this.addLog(LogLevel.Debug, source, message);
    }
    warn(source, message) {
        this.addLog(LogLevel.Warning, source, message);
    }
    critical(source, message) {
        this.addLog(LogLevel.Critical, source, message);
    }
}
const tryGetSourceLocationFromError = (error) => {
    if (error instanceof PuyaError) {
        return error.sourceLocation;
    }
    return undefined;
};
const logger = new PuyaLogger();
const patchErrorLocation = (action, sourceLocation) => {
    return (...args) => {
        try {
            return action(...args);
        }
        catch (e) {
            if (e instanceof PuyaError && !e.sourceLocation) {
                Object.assign(e, { sourceLocation });
            }
            throw e;
        }
    };
};
class LoggingContext {
    logEvents = [];
    sourcesByPath = {};
    constructor() { }
    hasErrors() {
        return this.logEvents.some((e) => isErrorOrCritical(e.level));
    }
    exitIfErrors() {
        if (this.hasErrors())
            process.exit(1);
    }
    enterContext() {
        LoggingContext.asyncStore.enterWith(this);
        return this;
    }
    run(cb) {
        return LoggingContext.asyncStore.run(this, cb);
    }
    static fallbackContext = new LoggingContext();
    static asyncStore = new AsyncLocalStorage();
    static create() {
        return new LoggingContext();
    }
    static get current() {
        const ctx = this.asyncStore.getStore();
        if (!ctx) {
            return this.fallbackContext;
        }
        return ctx;
    }
}

function ensureTempDir() {
    const tempDir = upath.join(os.tmpdir(), 'puya-ts');
    mkDirIfNotExists(tempDir);
    return tempDir;
}
function generateTempFile(options) {
    const { ext = 'tmp' } = {};
    const filePath = upath.join(ensureTempDir(), `${randomUUID()}.${ext}`);
    return {
        get filePath() {
            return filePath;
        },
        writeFileSync(data, options) {
            fs__default$1.writeFileSync(filePath, data, options);
        },
        [Symbol.dispose]() {
            fs__default$1.rmSync(filePath);
        },
    };
}
function generateTempDir() {
    const dirPath = upath.join(ensureTempDir(), `${randomUUID()}`);
    mkDirIfNotExists(dirPath);
    return {
        get dirPath() {
            return dirPath;
        },
        *files() {
            for (const p of globIterateSync(upath.join(dirPath, '**'), {
                nodir: true,
            })) {
                yield p;
            }
        },
        [Symbol.dispose]() {
            fs__default$1.rmSync(dirPath, { recursive: true, force: true });
        },
    };
}

function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

const lockPaths = new Set();
function acquireLock(path, options) {
    const { staleMs = 60 * 1000 } = options ?? {};
    lockPaths.add(path);
    if (existsSync(path)) {
        const now = Date.now();
        const fileStat = statSync(path);
        if (now - fileStat.mtime.getTime() > staleMs) {
            // Remove the lock file if it has expired
            rmdirSync(path);
        }
        else {
            throw new Error('Lock file already exists');
        }
    }
    mkdirSync(path, { recursive: true });
}
async function createLockFile(path, options) {
    const { maxRetries = 3, delayMs = 1000 } = options ?? {};
    for (let i = 0; i < maxRetries; i++) {
        try {
            acquireLock(path, options);
            return {
                async [Symbol.asyncDispose]() {
                    await unlockFile(path);
                },
            };
        }
        catch (err) {
            logger.debug(undefined, `Failed to acquire lock file ${path}: ${err}`);
            await sleep(delayMs);
        }
    }
    throw new Error('Failed to lock file');
}
async function unlockFile(path) {
    try {
        rmdirSync(path);
        lockPaths.delete(path);
    }
    catch (err) {
        logger.warn(undefined, `Failed to unlock file ${path}: ${err}`);
    }
}
onExit(() => {
    for (const path of lockPaths) {
        unlockFile(path);
    }
});

/**
 * Gets the platform-specific binary name
 * @returns The appropriate binary name for the current platform
 */
function getBinaryName() {
    return process.platform === 'win32' ? 'puya.exe' : 'puya';
}
function getPuyaTsDir() {
    try {
        return upath.dirname(require.resolve('@algorandfoundation/puya-ts'));
    }
    catch {
        return upath.dirname(fileURLToPath(import.meta.url));
    }
}
function getPuyaStorageDir() {
    const puyaTsDirName = getPuyaTsDir();
    return path.join(puyaTsDirName, '.puya');
}
function getCachedPuyaBinaryPath(puyaStorageDir, version) {
    const binaryFileName = getBinaryName();
    return path.join(puyaStorageDir, version.formatted, binaryFileName);
}
/**
 * Gets the platform-specific details for downloads
 * @returns Object containing OS and architecture information
 */
function getPlatformDetails() {
    const cliMessage = `Please refer to the puya-ts CLI documentation for information on how to install the Puya backend manually.`;
    // Map Node.js platform to OS name used in filenames
    let os;
    switch (process.platform) {
        case 'win32':
            os = 'windows';
            break;
        case 'darwin':
            os = 'macos';
            break;
        case 'linux':
            os = 'linux';
            break;
        default:
            throw new InternalError(`Unsupported platform: ${process.platform}. ${cliMessage}`);
    }
    // Map Node.js architecture to architecture name used in filenames
    let arch;
    switch (process.arch) {
        case 'x64':
            arch = 'x64';
            break;
        case 'arm64':
            arch = 'arm64';
            break;
        default:
            throw new InternalError(`Unsupported architecture: ${process.arch}. ${cliMessage}`);
    }
    return { os, arch };
}
/**
 * Downloads the Puya binary for a specific release version
 * @param version The release version to download (e.g., "1.0.0")
 * @returns Promise that resolves to the path of the extracted binary
 */
async function downloadPuyaBinary(puyaStorageDir, version) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        // Get platform-specific details
        const { os, arch } = getPlatformDetails();
        // Build platform-specific filenames
        const platformId = `${os}_${arch}`;
        const archiveFileName = `puya-${version.formatted}-${platformId}.tar.gz`;
        const checksumFileName = `puya-${version.formatted}-${platformId}.sha256.txt`;
        const binaryFileName = getBinaryName();
        const extractedDir = path.join(puyaStorageDir, version.formatted);
        // Ensure our storage directories exist
        if (!fs.existsSync(extractedDir)) {
            fs.mkdirSync(extractedDir, { recursive: true });
        }
        const tempDir = __addDisposableResource(env_1, generateTempDir(), false);
        const archiveFilePath = path.join(tempDir.dirPath, archiveFileName);
        const checksumFilePath = path.join(tempDir.dirPath, checksumFileName);
        const extractedBinaryPath = path.join(extractedDir, binaryFileName);
        logger.debug(undefined, `Downloading Puya binary for version ${version.formatted} and platform ${platformId}`);
        const archiveUrl = `https://github.com/${Constants.puyaGithubRepo}/releases/download/v${version.formatted}/${archiveFileName}`;
        const checksumUrl = `https://github.com/${Constants.puyaGithubRepo}/releases/download/v${version.formatted}/${checksumFileName}`;
        await downloadFile(archiveUrl, archiveFilePath);
        await downloadFile(checksumUrl, checksumFilePath);
        await verifyChecksum(archiveFilePath, archiveFileName, checksumFilePath);
        await tar.extract({
            file: archiveFilePath,
            cwd: extractedDir,
        });
        // Check if extraction was successful and binary exists
        if (!fs.existsSync(extractedBinaryPath)) {
            throw new InternalError(`Binary file ${binaryFileName} not found in the extracted archive`);
        }
        logger.debug(undefined, `Successfully downloaded and extracted Puya binary to ${extractedBinaryPath}`);
        return extractedBinaryPath;
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        __disposeResources(env_1);
    }
}
/**
 * Downloads a file from a URL to a specified path
 * @param url The URL to download from
 * @param destination The local path to save the file to
 * @returns Promise that resolves when the download is complete
 */
async function downloadFile(url, destination) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Failed to download file. Status Code: ${response.status}`);
    }
    const buffer = await response.arrayBuffer();
    return await new Promise((resolve, reject) => {
        const fileStream = fs.createWriteStream(destination);
        const nodeBuffer = Buffer.from(buffer);
        fileStream.write(nodeBuffer);
        fileStream.end();
        fileStream.on('finish', () => {
            resolve();
        });
        fileStream.on('error', (err) => {
            fs.unlinkSync(destination);
            reject(err);
        });
    });
}
/**
 * Verifies the checksum of a downloaded file
 * @param filePath Path to the file to verify
 * @param checksumFilePath Path to the checksum file
 * @returns Promise that resolves to true if the checksum matches, false otherwise
 */
async function verifyChecksum(filePath, fileName, checksumFilePath) {
    return new Promise((resolve, reject) => {
        // Read the checksum file
        const expectedChecksum = fs.readFileSync(checksumFilePath, 'utf8').trim().toLowerCase();
        // Calculate the SHA256 checksum of the downloaded file
        const hash = crypto.createHash('sha256');
        const stream = fs.createReadStream(filePath);
        stream.on('data', (data) => {
            hash.update(data);
        });
        stream.on('end', () => {
            const calculatedChecksum = hash.digest('hex').toLowerCase();
            if (`${calculatedChecksum}  ${fileName}` === expectedChecksum) {
                resolve();
            }
            reject(new InternalError(`Checksum verification failed. Expected checksum: ${expectedChecksum} but got: ${calculatedChecksum}`));
        });
    });
}

function parseSemVer(version) {
    const matched = /^(\d+)\.(\d+)\.(\d+)$/.exec(version);
    if (!matched) {
        throw new InternalError(`Invalid version string: ${version}`);
    }
    return {
        major: Number(matched[1]),
        minor: Number(matched[2]),
        rev: Number(matched[3]),
        formatted: version,
    };
}

async function resolvePuyaPath() {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        const version = parseSemVer(Constants.targetedPuyaVersion);
        const puyaStorageDir = getPuyaStorageDir();
        const cachedBinaryPath = getCachedPuyaBinaryPath(puyaStorageDir, version);
        if (isBinaryCached(cachedBinaryPath)) {
            return cachedBinaryPath;
        }
        const _ = __addDisposableResource(env_1, await createLockFile(`${puyaStorageDir}.lock`, { maxRetries: 30, delayMs: 1000, staleMs: 60 * 1000 })
        // Between the first check and acquiring the lock, the binary may have been downloaded by another process.
        // In this case there is no need to download the binary again.
        , true);
        // Between the first check and acquiring the lock, the binary may have been downloaded by another process.
        // In this case there is no need to download the binary again.
        if (isBinaryCached(cachedBinaryPath)) {
            return cachedBinaryPath;
        }
        return await downloadPuyaBinary(puyaStorageDir, version);
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        const result_1 = __disposeResources(env_1);
        if (result_1)
            await result_1;
    }
}
function isBinaryCached(cachePath) {
    if (fs.existsSync(cachePath)) {
        logger.debug(undefined, `Found cached Puya binary at ${cachePath}`);
        return true;
    }
    return false;
}

export { wrapInCodeError as A, hasFlags as B, Constants as C, isIn as D, intersectsFlags as E, normalisePath as F, toSubScript as G, enumerate as H, InternalError as I, mkDirIfNotExists as J, patchErrorLocation as K, LogLevel as L, sameSets as M, NotSupported as N, expandMaybeArray as O, generateTempFile as P, PuyaError as Q, SourceLocation as S, LoggingContext as a, uint8ArrayToBase64 as b, uint8ArrayToBase32 as c, uint8ArrayToHex as d, uint8ArrayToUtf8 as e, base64ToUint8Array as f, base32ToUint8Array as g, hexToUint8Array as h, isMinLevel as i, bigIntToUint8Array as j, utf8ToUint8Array as k, logger as l, enumFromValue as m, invariant as n, CodeError as o, parseSemVer as p, codeInvariant as q, resolvePuyaPath as r, distinctByEquality as s, sortBy as t, uint8ArrayToBigInt as u, instanceOfAny as v, throwError as w, tryConvertEnum as x, enumKeyFromValue as y, zipStrict as z };
//# sourceMappingURL=resolve-puya-path-zgZNWMEr.js.map
