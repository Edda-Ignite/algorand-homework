import type { SourceLocation } from '../awst/source-location';
import type { DeliberateAny } from '../typescript-helpers';
export { base32ToUint8Array, uint8ArrayToBase32 } from './base-32';
/**
 * Checks an invariant condition hold true. If this check fails it indicates the compiler is in an unstable state. For invariants related to
 * user code, use codeInvariant below.
 *
 * @param condition
 * @param message
 * @param sourceLocation
 */
export declare function invariant(condition: unknown, message: string, sourceLocation?: SourceLocation): asserts condition;
/**
 * Checks an invariant related to user code holds true. If this check fails it indicates the user code is not valid. For invariants the user
 * has no control over, use invariant above.
 * @param condition
 * @param message
 * @param sourceLocation
 */
export declare function codeInvariant(condition: unknown, message: string, sourceLocation?: SourceLocation): asserts condition;
export declare const enumFromValue: <TValue, TEnum extends TValue>(value: TValue, enumType: Record<string, TEnum | string>, message?: string) => TEnum;
export declare const enumKeyFromValue: <TValue, TEnum extends TValue>(value: TValue, enumType: Record<string, TEnum>, message?: string) => string;
export declare const convertEnum: <TEnumIn, TEnumOut, TKeys extends string>(value: TEnumIn, fromEnum: Record<TKeys, TEnumIn>, toEnum: Record<TKeys, TEnumOut>) => TEnumOut;
export declare const tryConvertEnum: <TEnumIn, TEnumOut, TKeys extends string>(value: TEnumIn, fromEnum: Record<TKeys, TEnumIn>, toEnum: Record<string, TEnumOut>) => TEnumOut | undefined;
export declare const expandMaybeArray: <T>(maybeArray: T | T[]) => T[];
export declare const uint8ArrayToBase64: (value: Uint8Array) => string;
export declare const hexToUint8Array: (value: string) => Uint8Array;
export declare const base64ToUint8Array: (value: string) => Uint8Array;
export declare const utf8ToUint8Array: (value: string) => Uint8Array;
export declare const uint8ArrayToBigInt: (v: Uint8Array) => bigint;
export declare const uint8ArrayToHex: (value: Uint8Array) => string;
export declare const uint8ArrayToUtf8: (value: Uint8Array) => string;
export declare const bigIntToUint8Array: (val: bigint, fixedSize?: number | "dynamic") => Uint8Array;
export declare const hasFlags: <T extends number>(value: T, flags: T) => boolean;
export declare const intersectsFlags: <T extends number>(value: T, flags: T) => boolean;
export declare function enumerate<T>(iterable: Iterable<T>): IterableIterator<readonly [number, T]>;
export declare function toSubScript(num: number): string;
export declare function instanceOfAny<T extends Array<{
    new (...args: DeliberateAny[]): DeliberateAny;
}>>(x: unknown, ...types: T): x is InstanceType<T[number]>;
/**
 * Normalise a file path to only include relevant segments.
 *
 *  - Anything in /node_modules/ is truncated to <package-name>/path.ext
 *  - Anything in workingDirectory is truncated relative to the workingDirectory
 *  - Forward slashes are used to segment paths
 * @param filePath
 * @param workingDirectory
 */
export declare function normalisePath(filePath: string, workingDirectory: string): string;
type SortDir = 'asc' | 'desc';
export declare const sortBy: <T, TKey>(keySelector: (item: T) => TKey, dir?: SortDir) => (a: T, b: T) => number;
/**
 * Can be used to filter a collection to a set of distinct items as determined by a specified key.
 * @param keySelector A lambda which when given an item, returns the items unique identifier
 *
 * Usage:
 *
 * ```
 * const distinctItems = nonDistinctItems.filter(distinct(x => x.uniqueId))
 * ```
 */
export declare const distinct: <T>(keySelector?: (item: T) => unknown) => (item: T) => boolean;
export declare const distinctByEquality: <T>(areEqual: (a: T, b: T) => boolean) => (item: T) => boolean;
export declare function mkDirIfNotExists(dir: string): void;
export declare function sameSets<T>(a: Iterable<T>, b: Iterable<T>): boolean;
export declare const zipStrict: <T1, T2>(array1: T1[], array2: T2[]) => [T1, T2][];
export declare function isIn<TSubject, TItem extends TSubject>(subject: TSubject, items: readonly TItem[]): subject is TItem;
export declare function joinUint8Arrays(...arrays: Uint8Array[]): Uint8Array;
