import ts from 'typescript';
import { BinaryBooleanOperator } from '../awst/nodes';
import { BuilderBinaryOp, BuilderComparisonOp, BuilderUnaryOp } from '../awst_build/eb';
import type { DeliberateAny } from '../typescript-helpers';
export declare const SyntaxKindName: {
    readonly 0: "Unknown";
    readonly 1: "EndOfFileToken";
    readonly 2: "SingleLineCommentTrivia";
    readonly 3: "MultiLineCommentTrivia";
    readonly 4: "NewLineTrivia";
    readonly 5: "WhitespaceTrivia";
    readonly 6: "ShebangTrivia";
    readonly 7: "ConflictMarkerTrivia";
    readonly 8: "NonTextFileMarkerTrivia";
    readonly 9: "NumericLiteral";
    readonly 10: "BigIntLiteral";
    readonly 11: "StringLiteral";
    readonly 12: "JsxText";
    readonly 13: "JsxTextAllWhiteSpaces";
    readonly 14: "RegularExpressionLiteral";
    readonly 15: "NoSubstitutionTemplateLiteral";
    readonly 16: "TemplateHead";
    readonly 17: "TemplateMiddle";
    readonly 18: "TemplateTail";
    readonly 19: "OpenBraceToken";
    readonly 20: "CloseBraceToken";
    readonly 21: "OpenParenToken";
    readonly 22: "CloseParenToken";
    readonly 23: "OpenBracketToken";
    readonly 24: "CloseBracketToken";
    readonly 25: "DotToken";
    readonly 26: "DotDotDotToken";
    readonly 27: "SemicolonToken";
    readonly 28: "CommaToken";
    readonly 29: "QuestionDotToken";
    readonly 30: "LessThanToken";
    readonly 31: "LessThanSlashToken";
    readonly 32: "GreaterThanToken";
    readonly 33: "LessThanEqualsToken";
    readonly 34: "GreaterThanEqualsToken";
    readonly 35: "EqualsEqualsToken";
    readonly 36: "ExclamationEqualsToken";
    readonly 37: "EqualsEqualsEqualsToken";
    readonly 38: "ExclamationEqualsEqualsToken";
    readonly 39: "EqualsGreaterThanToken";
    readonly 40: "PlusToken";
    readonly 41: "MinusToken";
    readonly 42: "AsteriskToken";
    readonly 43: "AsteriskAsteriskToken";
    readonly 44: "SlashToken";
    readonly 45: "PercentToken";
    readonly 46: "PlusPlusToken";
    readonly 47: "MinusMinusToken";
    readonly 48: "LessThanLessThanToken";
    readonly 49: "GreaterThanGreaterThanToken";
    readonly 50: "GreaterThanGreaterThanGreaterThanToken";
    readonly 51: "AmpersandToken";
    readonly 52: "BarToken";
    readonly 53: "CaretToken";
    readonly 54: "ExclamationToken";
    readonly 55: "TildeToken";
    readonly 56: "AmpersandAmpersandToken";
    readonly 57: "BarBarToken";
    readonly 58: "QuestionToken";
    readonly 59: "ColonToken";
    readonly 60: "AtToken";
    readonly 61: "QuestionQuestionToken";
    readonly 62: "BacktickToken";
    readonly 63: "HashToken";
    readonly 64: "EqualsToken";
    readonly 65: "PlusEqualsToken";
    readonly 66: "MinusEqualsToken";
    readonly 67: "AsteriskEqualsToken";
    readonly 68: "AsteriskAsteriskEqualsToken";
    readonly 69: "SlashEqualsToken";
    readonly 70: "PercentEqualsToken";
    readonly 71: "LessThanLessThanEqualsToken";
    readonly 72: "GreaterThanGreaterThanEqualsToken";
    readonly 73: "GreaterThanGreaterThanGreaterThanEqualsToken";
    readonly 74: "AmpersandEqualsToken";
    readonly 75: "BarEqualsToken";
    readonly 76: "BarBarEqualsToken";
    readonly 77: "AmpersandAmpersandEqualsToken";
    readonly 78: "QuestionQuestionEqualsToken";
    readonly 79: "CaretEqualsToken";
    readonly 80: "Identifier";
    readonly 81: "PrivateIdentifier";
    readonly 83: "BreakKeyword";
    readonly 84: "CaseKeyword";
    readonly 85: "CatchKeyword";
    readonly 86: "ClassKeyword";
    readonly 87: "ConstKeyword";
    readonly 88: "ContinueKeyword";
    readonly 89: "DebuggerKeyword";
    readonly 90: "DefaultKeyword";
    readonly 91: "DeleteKeyword";
    readonly 92: "DoKeyword";
    readonly 93: "ElseKeyword";
    readonly 94: "EnumKeyword";
    readonly 95: "ExportKeyword";
    readonly 96: "ExtendsKeyword";
    readonly 97: "FalseKeyword";
    readonly 98: "FinallyKeyword";
    readonly 99: "ForKeyword";
    readonly 100: "FunctionKeyword";
    readonly 101: "IfKeyword";
    readonly 102: "ImportKeyword";
    readonly 103: "InKeyword";
    readonly 104: "InstanceOfKeyword";
    readonly 105: "NewKeyword";
    readonly 106: "NullKeyword";
    readonly 107: "ReturnKeyword";
    readonly 108: "SuperKeyword";
    readonly 109: "SwitchKeyword";
    readonly 110: "ThisKeyword";
    readonly 111: "ThrowKeyword";
    readonly 112: "TrueKeyword";
    readonly 113: "TryKeyword";
    readonly 114: "TypeOfKeyword";
    readonly 115: "VarKeyword";
    readonly 116: "VoidKeyword";
    readonly 117: "WhileKeyword";
    readonly 118: "WithKeyword";
    readonly 119: "ImplementsKeyword";
    readonly 120: "InterfaceKeyword";
    readonly 121: "LetKeyword";
    readonly 122: "PackageKeyword";
    readonly 123: "PrivateKeyword";
    readonly 124: "ProtectedKeyword";
    readonly 125: "PublicKeyword";
    readonly 126: "StaticKeyword";
    readonly 127: "YieldKeyword";
    readonly 128: "AbstractKeyword";
    readonly 129: "AccessorKeyword";
    readonly 130: "AsKeyword";
    readonly 131: "AssertsKeyword";
    readonly 132: "AssertKeyword";
    readonly 133: "AnyKeyword";
    readonly 134: "AsyncKeyword";
    readonly 135: "AwaitKeyword";
    readonly 136: "BooleanKeyword";
    readonly 137: "ConstructorKeyword";
    readonly 138: "DeclareKeyword";
    readonly 139: "GetKeyword";
    readonly 140: "InferKeyword";
    readonly 141: "IntrinsicKeyword";
    readonly 142: "IsKeyword";
    readonly 143: "KeyOfKeyword";
    readonly 144: "ModuleKeyword";
    readonly 145: "NamespaceKeyword";
    readonly 146: "NeverKeyword";
    readonly 147: "OutKeyword";
    readonly 148: "ReadonlyKeyword";
    readonly 149: "RequireKeyword";
    readonly 150: "NumberKeyword";
    readonly 151: "ObjectKeyword";
    readonly 152: "SatisfiesKeyword";
    readonly 153: "SetKeyword";
    readonly 154: "StringKeyword";
    readonly 155: "SymbolKeyword";
    readonly 156: "TypeKeyword";
    readonly 157: "UndefinedKeyword";
    readonly 158: "UniqueKeyword";
    readonly 159: "UnknownKeyword";
    readonly 160: "UsingKeyword";
    readonly 161: "FromKeyword";
    readonly 162: "GlobalKeyword";
    readonly 163: "BigIntKeyword";
    readonly 164: "OverrideKeyword";
    readonly 165: "OfKeyword";
    readonly 166: "QualifiedName";
    readonly 167: "ComputedPropertyName";
    readonly 168: "TypeParameter";
    readonly 169: "Parameter";
    readonly 170: "Decorator";
    readonly 171: "PropertySignature";
    readonly 172: "PropertyDeclaration";
    readonly 173: "MethodSignature";
    readonly 174: "MethodDeclaration";
    readonly 175: "ClassStaticBlockDeclaration";
    readonly 176: "Constructor";
    readonly 177: "GetAccessor";
    readonly 178: "SetAccessor";
    readonly 179: "CallSignature";
    readonly 180: "ConstructSignature";
    readonly 181: "IndexSignature";
    readonly 182: "TypePredicate";
    readonly 183: "TypeReference";
    readonly 184: "FunctionType";
    readonly 185: "ConstructorType";
    readonly 186: "TypeQuery";
    readonly 187: "TypeLiteral";
    readonly 188: "ArrayType";
    readonly 189: "TupleType";
    readonly 190: "OptionalType";
    readonly 191: "RestType";
    readonly 192: "UnionType";
    readonly 193: "IntersectionType";
    readonly 194: "ConditionalType";
    readonly 195: "InferType";
    readonly 196: "ParenthesizedType";
    readonly 197: "ThisType";
    readonly 198: "TypeOperator";
    readonly 199: "IndexedAccessType";
    readonly 200: "MappedType";
    readonly 201: "LiteralType";
    readonly 202: "NamedTupleMember";
    readonly 203: "TemplateLiteralType";
    readonly 204: "TemplateLiteralTypeSpan";
    readonly 205: "ImportType";
    readonly 206: "ObjectBindingPattern";
    readonly 207: "ArrayBindingPattern";
    readonly 208: "BindingElement";
    readonly 209: "ArrayLiteralExpression";
    readonly 210: "ObjectLiteralExpression";
    readonly 211: "PropertyAccessExpression";
    readonly 212: "ElementAccessExpression";
    readonly 213: "CallExpression";
    readonly 214: "NewExpression";
    readonly 215: "TaggedTemplateExpression";
    readonly 216: "TypeAssertionExpression";
    readonly 217: "ParenthesizedExpression";
    readonly 218: "FunctionExpression";
    readonly 219: "ArrowFunction";
    readonly 220: "DeleteExpression";
    readonly 221: "TypeOfExpression";
    readonly 222: "VoidExpression";
    readonly 223: "AwaitExpression";
    readonly 224: "PrefixUnaryExpression";
    readonly 225: "PostfixUnaryExpression";
    readonly 226: "BinaryExpression";
    readonly 227: "ConditionalExpression";
    readonly 228: "TemplateExpression";
    readonly 229: "YieldExpression";
    readonly 230: "SpreadElement";
    readonly 231: "ClassExpression";
    readonly 232: "OmittedExpression";
    readonly 233: "ExpressionWithTypeArguments";
    readonly 234: "AsExpression";
    readonly 235: "NonNullExpression";
    readonly 236: "MetaProperty";
    readonly 237: "SyntheticExpression";
    readonly 238: "SatisfiesExpression";
    readonly 239: "TemplateSpan";
    readonly 240: "SemicolonClassElement";
    readonly 241: "Block";
    readonly 242: "EmptyStatement";
    readonly 243: "VariableStatement";
    readonly 244: "ExpressionStatement";
    readonly 245: "IfStatement";
    readonly 246: "DoStatement";
    readonly 247: "WhileStatement";
    readonly 248: "ForStatement";
    readonly 249: "ForInStatement";
    readonly 250: "ForOfStatement";
    readonly 251: "ContinueStatement";
    readonly 252: "BreakStatement";
    readonly 253: "ReturnStatement";
    readonly 254: "WithStatement";
    readonly 255: "SwitchStatement";
    readonly 256: "LabeledStatement";
    readonly 257: "ThrowStatement";
    readonly 258: "TryStatement";
    readonly 259: "DebuggerStatement";
    readonly 260: "VariableDeclaration";
    readonly 261: "VariableDeclarationList";
    readonly 262: "FunctionDeclaration";
    readonly 263: "ClassDeclaration";
    readonly 264: "InterfaceDeclaration";
    readonly 265: "TypeAliasDeclaration";
    readonly 266: "EnumDeclaration";
    readonly 267: "ModuleDeclaration";
    readonly 268: "ModuleBlock";
    readonly 269: "CaseBlock";
    readonly 270: "NamespaceExportDeclaration";
    readonly 271: "ImportEqualsDeclaration";
    readonly 272: "ImportDeclaration";
    readonly 273: "ImportClause";
    readonly 274: "NamespaceImport";
    readonly 275: "NamedImports";
    readonly 276: "ImportSpecifier";
    readonly 277: "ExportAssignment";
    readonly 278: "ExportDeclaration";
    readonly 279: "NamedExports";
    readonly 280: "NamespaceExport";
    readonly 281: "ExportSpecifier";
    readonly 282: "MissingDeclaration";
    readonly 283: "ExternalModuleReference";
    readonly 284: "JsxElement";
    readonly 285: "JsxSelfClosingElement";
    readonly 286: "JsxOpeningElement";
    readonly 287: "JsxClosingElement";
    readonly 288: "JsxFragment";
    readonly 289: "JsxOpeningFragment";
    readonly 290: "JsxClosingFragment";
    readonly 291: "JsxAttribute";
    readonly 292: "JsxAttributes";
    readonly 293: "JsxSpreadAttribute";
    readonly 294: "JsxExpression";
    readonly 295: "JsxNamespacedName";
    readonly 296: "CaseClause";
    readonly 297: "DefaultClause";
    readonly 298: "HeritageClause";
    readonly 299: "CatchClause";
    readonly 300: "ImportAttributes";
    readonly 301: "ImportAttribute";
    readonly 303: "PropertyAssignment";
    readonly 304: "ShorthandPropertyAssignment";
    readonly 305: "SpreadAssignment";
    readonly 306: "EnumMember";
    readonly 307: "SourceFile";
    readonly 308: "Bundle";
    readonly 309: "JSDocTypeExpression";
    readonly 310: "JSDocNameReference";
    readonly 311: "JSDocMemberName";
    readonly 312: "JSDocAllType";
    readonly 313: "JSDocUnknownType";
    readonly 314: "JSDocNullableType";
    readonly 315: "JSDocNonNullableType";
    readonly 316: "JSDocOptionalType";
    readonly 317: "JSDocFunctionType";
    readonly 318: "JSDocVariadicType";
    readonly 319: "JSDocNamepathType";
    readonly 320: "JSDoc";
    readonly 321: "JSDocText";
    readonly 322: "JSDocTypeLiteral";
    readonly 323: "JSDocSignature";
    readonly 324: "JSDocLink";
    readonly 325: "JSDocLinkCode";
    readonly 326: "JSDocLinkPlain";
    readonly 327: "JSDocTag";
    readonly 328: "JSDocAugmentsTag";
    readonly 329: "JSDocImplementsTag";
    readonly 330: "JSDocAuthorTag";
    readonly 331: "JSDocDeprecatedTag";
    readonly 332: "JSDocClassTag";
    readonly 333: "JSDocPublicTag";
    readonly 334: "JSDocPrivateTag";
    readonly 335: "JSDocProtectedTag";
    readonly 336: "JSDocReadonlyTag";
    readonly 337: "JSDocOverrideTag";
    readonly 338: "JSDocCallbackTag";
    readonly 339: "JSDocOverloadTag";
    readonly 340: "JSDocEnumTag";
    readonly 341: "JSDocParameterTag";
    readonly 342: "JSDocReturnTag";
    readonly 343: "JSDocThisTag";
    readonly 344: "JSDocTypeTag";
    readonly 345: "JSDocTemplateTag";
    readonly 346: "JSDocTypedefTag";
    readonly 347: "JSDocSeeTag";
    readonly 348: "JSDocPropertyTag";
    readonly 349: "JSDocThrowsTag";
    readonly 350: "JSDocSatisfiesTag";
    readonly 352: "SyntaxList";
    readonly 353: "NotEmittedStatement";
    readonly 355: "PartiallyEmittedExpression";
    readonly 356: "CommaListExpression";
    readonly 357: "SyntheticReferenceExpression";
    readonly 358: "Count";
};
export declare const getNodeName: (node: ts.Node) => string;
export declare const getSyntaxName: (kind: ts.SyntaxKind) => string;
export type SyntaxKindNameType = typeof SyntaxKindName;
export type ModuleStatements = ts.ClassDeclaration | ts.ImportDeclaration | ts.VariableStatement | ts.FunctionDeclaration | ts.TypeAliasDeclaration | ts.InterfaceDeclaration;
export type PrimaryExpressions = LiteralExpressions | ts.TrueLiteral | ts.FalseLiteral | ts.ArrayLiteralExpression | ts.ClassExpression | ts.FunctionExpression | ts.Identifier | ts.ImportExpression | ts.NewExpression | ts.NullLiteral | ts.ObjectLiteralExpression | ts.PrivateIdentifier | ts.ParenthesizedExpression | ts.SuperExpression | ts.TemplateExpression | ts.ThisExpression;
export type MemberExpressions = PrimaryExpressions | ts.ElementAccessExpression | ts.ExpressionWithTypeArguments | ts.PropertyAccessExpression | ts.TaggedTemplateExpression;
export type LeftHandSideExpression = ts.CallExpression | MemberExpressions | ts.NonNullExpression;
/**
 * All concrete types which extends ts.ClassElement
 */
export type ClassElements = ts.ClassStaticBlockDeclaration | ts.ConstructorDeclaration | ts.GetAccessorDeclaration | ts.IndexSignatureDeclaration | ts.MethodDeclaration | ts.PropertyDeclaration | ts.SemicolonClassElement | ts.SetAccessorDeclaration;
/**
 * All concrete types which extends ts.Statement
 */
export type Statements = ts.EmptyStatement | ts.VariableStatement | ts.ExpressionStatement | ts.IfStatement | ts.DoStatement | ts.WhileStatement | ts.ForStatement | ts.ForInStatement | ts.ForOfStatement | ts.ContinueStatement | ts.BreakStatement | ts.ReturnStatement | ts.WithStatement | ts.SwitchStatement | ts.LabeledStatement | ts.ThrowStatement | ts.TryStatement | ts.DebuggerStatement | ts.ImportDeclaration | ts.ClassDeclaration | ts.TypeAliasDeclaration;
/**
 * All concrete types which extends ts.LiteralExpression
 */
export type LiteralExpressions = ts.NumericLiteral | ts.BigIntLiteral | ts.StringLiteral | ts.RegularExpressionLiteral | ts.NoSubstitutionTemplateLiteral;
/**
 * All concrete types which extend ts.Expression
 */
export type Expressions = ts.PropertyAccessExpression | ts.ElementAccessExpression | ts.TypeAssertion | ts.ParenthesizedExpression | ts.FunctionExpression | ts.DeleteExpression | ts.TypeOfExpression | ts.VoidExpression | ts.AwaitExpression | ts.PrefixUnaryExpression | ts.PostfixUnaryExpression | ts.BinaryExpression | ts.ConditionalExpression | ts.TemplateExpression | ts.YieldExpression | ts.OmittedExpression | ts.ExpressionWithTypeArguments | ts.AsExpression | ts.NonNullExpression | ts.SatisfiesExpression | ts.SpreadElement | PrimaryExpressions | LeftHandSideExpression;
/**
 * Map an inherited base type to a union type of "all" the nodes which extend that base type
 * where "all" is limited to nodes relevant to this compiler.
 */
export type MapBaseType<T> = T extends DeliberateAny ? IfEquals<T, ts.Expression, Expressions, IfEquals<T, ts.LeftHandSideExpression, LeftHandSideExpression, IfEquals<T, ts.Statement, Statements, IfEquals<T, ts.ClassElement, ClassElements, T>>>> : never;
type IfEquals<T, U, Y = unknown, N = never> = ((x: T) => T) extends (x: U) => U ? (((x: U) => U) extends (x: T) => T ? Y : N) : N;
export declare const BinaryOpSyntaxes: {
    readonly 40: BuilderBinaryOp.add;
    readonly 41: BuilderBinaryOp.sub;
    readonly 42: BuilderBinaryOp.mult;
    readonly 44: BuilderBinaryOp.div;
    readonly 45: BuilderBinaryOp.mod;
    readonly 43: BuilderBinaryOp.pow;
    readonly 52: BuilderBinaryOp.bitOr;
    readonly 53: BuilderBinaryOp.bitXor;
    readonly 51: BuilderBinaryOp.bitAnd;
    readonly 48: BuilderBinaryOp.lshift;
    readonly 49: BuilderBinaryOp.rshift;
};
export declare const LogicalOpSyntaxes: {
    56: BinaryBooleanOperator;
    57: BinaryBooleanOperator;
};
export declare const AugmentedAssignmentLogicalOpSyntaxes: {
    77: BinaryBooleanOperator;
    76: BinaryBooleanOperator;
};
export declare function isKeyOf<TMap extends object>(key: PropertyKey, map: TMap): key is keyof TMap;
export declare const ComparisonOpSyntaxes: {
    readonly 37: BuilderComparisonOp.eq;
    readonly 38: BuilderComparisonOp.ne;
    readonly 30: BuilderComparisonOp.lt;
    readonly 33: BuilderComparisonOp.lte;
    readonly 32: BuilderComparisonOp.gt;
    readonly 34: BuilderComparisonOp.gte;
};
export declare const AugmentedAssignmentBinaryOp: {
    readonly 65: BuilderBinaryOp.add;
    readonly 66: BuilderBinaryOp.sub;
    readonly 67: BuilderBinaryOp.mult;
    readonly 69: BuilderBinaryOp.div;
    readonly 70: BuilderBinaryOp.mod;
    readonly 68: BuilderBinaryOp.pow;
    readonly 75: BuilderBinaryOp.bitOr;
    readonly 79: BuilderBinaryOp.bitXor;
    readonly 74: BuilderBinaryOp.bitAnd;
    readonly 71: BuilderBinaryOp.lshift;
    readonly 72: BuilderBinaryOp.rshift;
};
export declare const UnaryExpressionUnaryOps: {
    46: BuilderUnaryOp;
    47: BuilderUnaryOp;
    40: BuilderUnaryOp;
    41: BuilderUnaryOp;
    55: BuilderUnaryOp;
};
export {};
